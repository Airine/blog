<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.banli17.com</id>
    <title></title>
    <updated>2020-01-29T08:19:44.034Z</updated>
    <generator>https://github.com/webmasterish/vuepress-plugin-feed</generator>
    <link rel="alternate" href="https://www.banli17.com"/>
    <link rel="self" href="https://www.banli17.com/feed.atom"/>
    <entry>
        <title type="html"><![CDATA[Home]]></title>
        <id>https://www.banli17.com/</id>
        <link href="https://www.banli17.com/">
        </link>
        <updated>2020-01-29T08:19:43.979Z</updated>
        <summary type="html"><![CDATA[https://www.cnblogs.com/andong2015/p/9981363.html]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[简介]]></title>
        <id>https://www.banli17.com/algo/</id>
        <link href="https://www.banli17.com/algo/">
        </link>
        <updated>2020-01-29T08:19:43.981Z</updated>
        <summary type="html"><![CDATA[简介
数据结构与算法是一块非常不太好学会的内容，平时工作中业务开发也不太会用到，但是它是一门非常重要的基本功。学习它没有其它好的方法，只有反复的练习，加深记忆。
学习资料

极客时间：数据结构与算法之美
极客时间：算法面试通关 40 讲
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组]]></title>
        <id>https://www.banli17.com/algo/array.html</id>
        <link href="https://www.banli17.com/algo/array.html">
        </link>
        <updated>2020-01-29T08:19:43.981Z</updated>
        <summary type="html"><![CDATA[数组
数组在内存一般是连续存储的。
操作

获取：通过 Memory Controller(内存管理器)访问任何下标位置的元素为 O(1)。
插入: 因为要保证是连续的，所以插入后，后面的元素要往后面移动。时间复杂度是 O(n) 的。
删除: 也是 O(n) 的。
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划]]></title>
        <id>https://www.banli17.com/algo/dynamic-program.html</id>
        <link href="https://www.banli17.com/algo/dynamic-program.html">
        </link>
        <updated>2020-01-29T08:19:43.997Z</updated>
        <summary type="html"><![CDATA[动态规划

递归 + 记忆化 -&gt; 递推
状态的定义：opt[n]、dp[n]、fib[n]
状态转移(dp)方程：opt[n] = best_of(opt[n-1], opt[n-2],...)
最优子结构

DP vs 回溯 vs 贪心

回溯(递归) - 重复计算
贪心 - 永远局部最优
DP - 记录局部最优子结构/多种记录值

斐波那契数列（Fibonacci sequence）
如果直接进行递归，算法复杂度是 O(2^n)。使用递归 + 记忆法，从上向下递归计算，算法复杂度是 O(2n)。使用递推法，直接从下向上计算，算法复杂度是 O(n)。
function fib(n, c = [0, 1]) {
    if (n &lt;= 1) return c[n];

    for (let i = 2; i &lt;= n; i++) {
        c[i] = c[i - 1] + c[i - 2];
    }
    return c[n];
}

棋盘路径问题

棋盘从 start 到 end 共有多少种走法? 走动方向只能是右边或下边，中级有石头。

一个格子的走法 = 它下面格子的走法 + 它右边格子的走法。
最下面格子，和最右边格子的走法都是 1。石头格子的走法是 0。
从最右下角，开始往左上角递推。

let stone = {
    1: [2, 6],
    2: [1, 3, 4],
    3: [5],
    4: [2, 5, 7],
    5: [3],
    6: [1, 5]
};

/**
 创建格子
 @param {*} m 格子行数
 @param {*} n 格子列数
 */
function createMap(m, n) {
    let steps = [];
    for (let i = 0; i &lt;= m; i++) {
        for (let j = 0; j &lt;= n; j++) {
            if (!steps[i]) steps[i] = [];
            stepsi = i == 0 || j == 0 ? 1 : 0;
        }
    }
    return steps;
}

/**
 检测是否是石头
 */
function isStone(stone, i, j) {
    return stone &amp;&amp; stone[i] &amp;&amp; stone[i].includes(j);
}

/**
 动态规划走法
 */
function step(steps, m, n) {
    for (let i = 1; i &lt;= m; i++) {
        for (let j = 1; j &lt;= n; j++) {
            if (isStone(stone, i, j)) {
                stepsi = 0;
            } else {
                stepsi = stepsi - 1 + stepsi;
            }
        }
    }
    return steps;
}

爬楼梯问题
leetcode 70 题：楼梯一次只能爬 1 或者 2 步，第 n 层有多少种爬法。
其实就是一个斐波那契问题。
var climbStairs = function(n) {
    if (n &lt;= 2) return n;
    let all = [0, 1, 2];
    for (let i = 3; i &lt;= n; i++) {
        all[i] = all[i - 1] + all[i - 2];
    }
    return all[n];
};

三角形最小路径和
练习地址

https://github.com/banli17/practice/tree/master/algo
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆和栈]]></title>
        <id>https://www.banli17.com/algo/heap-stack.html</id>
        <link href="https://www.banli17.com/algo/heap-stack.html">
        </link>
        <updated>2020-01-29T08:19:43.998Z</updated>
        <summary type="html"><![CDATA[堆和栈

stack 数组或单双链表 查 O(n) 插入，删除 O(1)
queue 数组或单双链表 查 O(n) 插入，删除 O(1)

http://www.bigocheatsheet.com/ 罗列了各种数据结构和算法时间复杂度
Big O Cheat Sheet

https://leetcode.com/problems/backspace-string-compare/description/ 844
https://leetcode.com/problems/implement-queue-using-stacks/solution/ 232
https://leetcode.com/problems/implement-stack-using-queues/description/ 225

只用栈实现队列，或只用队列实现栈
用 input 和 output，两个 stack。如果要出队，就 pop 从 output 里出、入队 push 到 input 里。output 如果没有，就将 input 里的数据移到 output，peek 用于查看末尾的元素，看 output。

https://leetcode.com/problems/valid-parentheses/description/ 20

使用栈

左 push
右 peek
最终看是否 empty

do while 循环 replace () [] {}
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表]]></title>
        <id>https://www.banli17.com/algo/linked-list.html</id>
        <link href="https://www.banli17.com/algo/linked-list.html">
        </link>
        <updated>2020-01-29T08:19:44.000Z</updated>
        <summary type="html"><![CDATA[链表
Linked List
为了解决数组的插入和删除操作时间复杂度高的问题。
head tail 最后一个节点的 next 指向 null

插入: 前一个节点的 next 指向插入元素，插入元素的 next 指向下一个节点。时间复杂度是 O(1)
删除: 前一个节点的 next 指向要删除元素的下个节点。时间复杂度是 O(1)

但是查找的时间为 O(n)。
双向链表

lookup: O (n)
插入: O(1) insert prepend append
删除: O(1) delete
空间复杂度 O(n)

练习题：

https://leetcode.com/problems/reverse-linked-list/ 206

方法 1 迭代法
方法 2 递归
方法 3 es6 https://leetcode.com/problems/reverse-linked-list/discuss/313728/Javascript-ES6-less-code-solution

https://leetcode.com/problems/linked-list-cycle 141

新建节点进行迭代：https://leetcode.com/problems/swap-nodes-in-pairs/discuss/284762/js-solution-faster-than-100

暴力法，循环等 1s 没相遇就没有环
将前面节点记录一下，然后查找。
快慢指针: https://leetcode.com/problems/linked-list-cycle/discuss/371507/Javascript-Solutions-(using-Set-slow-and-fast-pointers)

https://leetcode.com/problems/swap-nodes-in-pairs 24

加一个头节点，防止赋值导致节点断裂的问题

https://leetcode.com/problems/linked-list-cycle-ii
https://leetcode.com/problems/reverse-nodes-in-k-group/
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[优先队列]]></title>
        <id>https://www.banli17.com/algo/priority-queue.html</id>
        <link href="https://www.banli17.com/algo/priority-queue.html">
        </link>
        <updated>2020-01-29T08:19:44.000Z</updated>
        <summary type="html"><![CDATA[优先队列
优先队列(PriorityQueue)
正常⼊、按照优先级出
实现可以是

堆

二叉堆 查找是 O(1)，删除、插入是 O(logn)，合并是 O(n)
fibonacci 堆 查、插入、合并都是 O(1)，删除是 O(logn)

二分查找树

复杂度
题目

https://leetcode.com/problems/kth-largest-element-in-a-stream
https://leetcode.com/problems/sliding-window-maximum/
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[树和图]]></title>
        <id>https://www.banli17.com/algo/tree.html</id>
        <link href="https://www.banli17.com/algo/tree.html">
        </link>
        <updated>2020-01-29T08:19:44.001Z</updated>
        <summary type="html"><![CDATA[树和图
理论
链表是特殊的树(后继节点可以多个)，树是特殊的图(可以乱指)。
二叉搜索树(binary search tree)：有序二叉树、排序二叉树，是指一棵空树或具有下列性质的二叉树：

左子树上所有节点的值都小于它的根节点的值。
右子树上所有节点的值都大于它的根节点的指。
recursively，坐、右子树也分别为二叉搜索树。

时间复杂度是O(logN)，最差是O(n)，比如只有右子节点，就是一个链表了。

验证二叉排序树
validate BST，leetcode 98 题。

in-order 中序遍历（左、根、右），应该是一个升序的 array。
递归
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[概述]]></title>
        <id>https://www.banli17.com/browser/</id>
        <link href="https://www.banli17.com/browser/">
        </link>
        <updated>2020-01-29T08:19:44.006Z</updated>
        <summary type="html"><![CDATA[概述
chrome 架构
多进程架构

为什么打开一个页面，有 4 个进程？

进程和线程
线程是用来执行任务的，它不能独立存在，必须由进程来启动和管理。
进程是程序的运行实例，程序启动时，操作系统给程序分配的一块内存，用来存放代码、运行中的数据和一个执行任务的主线程。这样一个运行环境叫做进程。
进程使用多线程来提高运算效率。
特点：

进程中一个线程出错，会导致整个进程崩溃。
线程之间共享进程的数据。
当一个进程关闭后，操作系统会回收进程所占用的内存。
进程之间是相互隔离的，一个挂了不影响另一个。之间数据通信需要使用 IPC 的机制。

单进程

不稳定，一个线程出错，就导致进程崩溃。
不流畅，如果只有一个线程，死循环时，其它的任务都要等待。
不安全，插件或页面代码能使用主进程数据，对系统进行操作,，直接控制电脑。因为主进程不可能隔离，这样浏览器就不能读写系统了。另外，其它页面的内容，如果是在写邮件，也没了。

多进程

解决不稳定，因为进程是隔离的，互不影响
解决不流畅，即使 js 阻塞，也不影响浏览器和其它页面，死循环只影响当前 tab
解决不安全，使用安全沙箱，给渲染进程和插件进程上锁。无法获取系统权限。

架构

渲染进程: 负责 html css js 转成网页，排版引擎 blink 和 js 引擎 v8 都在这，默认情况下，每个 tab 会创建一个渲染进程。同一个站点如,x.y.com z.y.com 新页面会复用同一个进程，因为有时需要共享 js 执行环境。iframe 也会新开进程。
插件进程
网络进程
浏览器主进程： 负责界面显示，用户交互，子进程管理，存储
GPU 进程：初衷是实现 css 3d，后来用来绘制 UI 界面
v8 代理解析工具 chrome 支持 js 写连接代理的脚本，叫在线 pac 代理脚本，这个进程叫 Utility: V8 Proxy Resolver。
Audio 服务进程，对所有页面提供基础服务。

缺点：

更高的资源占用
更复杂的体系架构：耦合高、扩展性差

未来的架构

面向服务的架构，将原来的模块重构成服务，每个服务定义好接口，通过 IPc 来通信，从而内聚，松耦合，易于维护和扩展

此外，chrome 还提供了灵活的弹性架构，在资源受限制的设备上，会将很多服务整合到一个进程，节省内存

TCP 协议
衡量 web 性能有个重要的指标 FP(first paint)，是从页面加载到首次开始绘制的时长，这个指标直接影响了用户的跳出率。更快的页面响应意味着更多的 pv，更高的参与度，以及更高的转换率。
影响 FP 的一个重要因素是网络加载速度。

ip 把数据包送达目的主机

传输前，数据包会带上自身的 ip 地址(为了可以让目标主机回复)、目标主机的 ip 地址信息(为了可以送达)。
ip 头包含 ip 版本、源 ip 地址、目标 ip 地址、生存时间等信息。

UDP 把数据包送达应用程序

ip 层并不知道数据要交给哪个应用程序，所以需要用户数据包协议 UDP(user datagram protocol)。
UDP 中有端口号，通过端口号将数据包发送给指定程序。发送数据时，端口号也会被放入到 UDP 头中，到达目标主机时，也会拆开 UDP 头。
UDP 的特点

能校验数据
不能保证数据可靠性(只管发，不确认)，传输速度快
不能将乱序小包组成完整文件

TCP

transmission contrl protocol 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。

对于数据包丢失的情况，会重传
引入了数据包排序机制(有序号)，可以把乱序的数据包组合成完整的文件

一个 tcp 完整的连接:

建立连接阶段，三次握手。
传输数据阶段，接收端需要对每个数据包进行确认操作，在规定时间内没有收到接收端的反馈，就判断为数据包丢失，会触发重发机制。大文件传输时会拆成小包，在接收端按照 tcp 头里的序号进行排序，组成完整的包。
断开连接阶段，四次挥手。

所以 tcp 为了保证数据传输的可靠性，牺牲了数据包的传输速度，三次握手和数据包校验机制等在传输过程中将数据包的数量提升了一倍。
网络进程知道每个 tcp 链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。
一个包从主机 A 到主机 B 的旅程：

应用层加上 http 头，发给 tcp 层。
tcp 层加上 tcp 头，包含端口号。
数据包交给网络层，网络层加上 ip 头，组成新的 ip 数据包交给底层。
底层通过物理网络将数据包发送给 B。
数据包传输到 B 的网络层，拆开数据包的 ip 头信息，并将拆开的数据部分交给 tcp 层。
tcp 进行拆包取出端口号，交给浏览器。
浏览器的网络进程知道 tcp 连接对应的标签。所以收到数据后，会分发给对应的渲染进程。

tcp 交给 http 时丢包？应该会重新再发给 http，tcp 已经收到包了，本地给 http 很快。
http 过程
请求

构建请求

GET /index.html HTTP1.1

查找缓存

发起请求之前，会查找缓存。如果有，则直接返回并结束，而不会发起请求。好处是：缓解服务器压力，提升性能。如果没有缓存，则发请求

为 tcp 连接准备 ip 和端口

http 工作前，浏览器会通过 tcp 与服务器建立连接，也就是 http 的内容是通过 tcp 传输数据阶段来实现的。
但是现在只有一个域名，所以需要 DNS(域名系统) 解析，将域名映射为 ip。
浏览器还有 DNS 数据缓存服务，如果没有过期会直接使用，这样会减少一次网络请求。
拿到 ip 后，开始获取端口号，如果没有指明，http 协议默认是 80 端口。

等待 tcp 队列

chrome 有个机制，同一个域名最多只有 6 个 tcp 连接，超出的会进入排队等待。如果数量小于 6，会直接进行下一步，建立 tcp 连接。

建立 tcp 连接

发起 http 请求

浏览器会发送请求行：请求方法、请求 uri(uniform resource identifier) 和 http 版本号。

服务器处理 http 请求。

并不是所有请求都会被服务器处理，服务器通过状态码告诉浏览器它的处理结果。如 200、400。

断开连接

一旦服务器向客户端返回了结果，它就要关闭 tcp 连接，不过如果有头信息:
Connection: Keep-Alive

那么 tcp 连接会在发送完后保持打开，保持 tcp 连接可以省去下次建立连接的时间，提升资源加载速度。

重定向

浏览器收到 301，会根据响应头的 Location 字段重新导航。
返回 301 不返回 location 会怎么样？
为什么很多站点第二次打开速度会很快？
主要是第一次缓存了数据。哪些数据会缓存？DNS 缓存和页面资源缓存。

服务器响应头返回 Cache-Control 字段设置资源是否缓存。
Cache-Control: Max-age=2000

缓存过期，会发送网络请求，请求头会带上:
If-None-Match:&quot;4f80f-13c-3a1xb&quot;

服务器收到后，会根据 If-None-Match 判断请求资源是否有更新。

如果没有更新，则返回 304，告诉浏览器这个缓存可以继续用，这次就不发送重复数据给你了。
如果资源有更新，服务器就直接返回最新资源。

登录状态是如何保持的？
服务器返回 Set-Cookie，客户端每次发送 Cookie 字段。

如果一个网络请求时间过久，怎么分析是哪个地方出了问题？

首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过 ping curl 看看对应的时延高不高。
然后通过 wireshake 看看具体哪里出了问题。
假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。

导航流程

从输入 URL 到页面展示，这中间发生了什么？

整个过程需要各个进程之间的配合。

浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
网络进程是面向浏览器和渲染进程等提供网络下载功能。
渲染进程主要是把网络进程下载的 html、js、css、图片等解析为可以显示和交互的页面，因为渲染进程所有内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程的代码是不被信任的，渲染进程在安全沙箱里运行。

整个过程大致如下：

用户在浏览器进程里输入请求信息。
网络进程发起 URL 请求。
服务器响应 URL 请求之后，浏览器进程开始准备渲染进程。
渲染进程准备好之后，需要先向渲染进程提交页面数据，称为提交文档阶段。
渲染进程接受完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

这其中，用户发出 URL 请求到页面开始解析的过程，叫做导航。
1.用户输入。
用户输入时，地址栏会判断用户输入的是关键字，还是请求的 URL。如果是关键字，地址栏会使用浏览器默认搜索引擎来合成带搜索关键字的 URL。如果输入的内容符合 URL 规则，那么地址栏会根据规则，将内容加上协议，合成完整的 URL。
回车之后，浏览器刚开始加载地址，标签页图标进入加载状态，开始转圈。但是页面显示的内容还是之前的，需要等到提交文档阶段，页面内容才会被替换。
2.URL 请求过程
接下来，开始页面请求资源过程，浏览器进程会通过进程间通信(IPC)把 URL 请求发送给网络进程，网络进程收到 URL 请求后，发起真正的 URL 请求过程。
首先，网络进程查看本地缓存，如果有缓存，则直接返回给浏览器进程；如果没有，则进入网络请求流程，第一步是 DNS 解析，获取 IP 地址，如果请求协议是 HTTPS，则需要建立 TLS 连接。
然后，利用 IP 和服务器建立 TCP 连接，建立连接后，浏览器构建 http 报文。包括请求行、请求头等信息，并把 cookie 等数据附加在请求头中，发送给服务器。
服务器收到请求后，会根据请求信息生成响应数据，发送给网络进程，网络进程收到响应行和响应头后，开始解析响应头。

重定向

网络进程发现状态码是 301 或 302，会从头的 Location 字段读取重定向地址，然后发起新的请求。

响应数据的类型处理 content-type

它告诉浏览器返回的响应体数据是什么类型，如果是application/octet-stream(字节流)，浏览器会按照下载类型来处理，该请求会交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。如果是 HTML，浏览器会继续进行导航流程。
3.准备渲染进程
默认情况下，chrome 会给每个页面分配一个渲染进程，但是同一个站点（协议和顶级域名相同）会运行在一个渲染进程中，这个策略叫 process-per-site-instance。
在碰到rel=noopener属性时，它告诉浏览器新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。浏览器解析时，会新开一个渲染进程。
4.提交文档
渲染进程准备好之后，浏览器进程会发出提交文档的消息，渲染进程收到消息后，会和网络进程建立传输数据的管道，等文档数据传输完成后，渲染进程会发送确认提交消息给浏览器进程。浏览器进程收到确认提交消息后，会更新浏览器界面状态，包括安全状态、地址栏 URL、前进后退的历史状态，并更新 Web 页面。
5.渲染进程
一旦文档被提交，渲染开始页面解析和子资源加载。如果页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器收到后，会停止标签图标的加载动画。

keep-alive 是为了解决连接效率不高的问题，http1.0 时代，http 请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接。为什么是 6 个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。

渲染流程]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[垃圾回收机制]]></title>
        <id>https://www.banli17.com/browser/gc.html</id>
        <link href="https://www.banli17.com/browser/gc.html">
        </link>
        <updated>2020-01-29T08:19:44.007Z</updated>
        <summary type="html"><![CDATA[垃圾回收机制]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[v8 工作原理]]></title>
        <id>https://www.banli17.com/browser/v8.html</id>
        <link href="https://www.banli17.com/browser/v8.html">
        </link>
        <updated>2020-01-29T08:19:44.008Z</updated>
        <summary type="html"><![CDATA[v8 工作原理
垃圾回收
栈中的垃圾回收
执行栈中有一个记录当前执行状态的指针（ESP)，指向栈顶的函数执行上下文，函数执行完成后，ESP 会下移，函数执行上下文就是无效内存了，如果调用新函数，这块内存会被覆盖掉，用来存放新函数的执行上下文。
所以说，当一个函数执行完后，JS 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。
堆中的垃圾回收
堆中的垃圾回收，就用到了 JS 的垃圾回收器。
代际假说有两个特点：

大部分对象在内存中存在的时间很短。
不死的对象，会存活的更久。

V8 将堆分为新生代和老生代两个区域，新生代存放生存时间短的对象，老生代存放生存时间长的对象。
新生区通常只支持 1-8M 容量，老生区支持的容量大。V8 分别堆这两个区使用了不同的垃圾回收器。

副垃圾回收器，负责新生代的垃圾回收。
主垃圾回收器，负责老生代的垃圾回收。

垃圾回收器工作流程
垃圾回收器的工作流程是一致的：

标记空间中活动对象和非活动对象。
回收非活动对象所占用的内存。即清理标记为非活动对象的内存。
内存整理，通常垃圾回收后，内存会变得不连续，有内存碎片。

副垃圾回收器
副垃圾回收器主要负责新生区的垃圾回收，通常小的对象分配到这里。
新生代中用 Scavenge 算法来处理，即把新生区对半分为两个区域，一般是对象区域，一半是空闲区域。新加入的对象会存放在对象区域，当对象区域快满时，就需要一次垃圾回收。
垃圾回收过程中，首先标记对象区域中的垃圾，标记完成后，进行垃圾清理阶段，副垃圾回收器会把存活的对象复制到空闲区域，同时将它们有序的排列起来，所以这个复制过程相当于是内存整理。
复制完成后，对象区域和空闲区域进行反转，这种角色反转的操作能让新生代的两块内存可以无限重复使用下去。
因为 Scavenge 算法，每次要复制存活对象到空闲区域，复制需要时间成本，所以如果新生区空间太大，每次清理需要很长时间，为了执行效率，新生区会设置的比较小。
但是由于新生区空间不大，会很快被装满，所以 JS 引擎采用对象晋升策略，即经过两次垃圾回收还存活的对象，会被移动到老生区中。
主垃圾回收器
主垃圾回收器负责老生区的垃圾回收，除了新生区晋升的对象，一些大的对象也会直接分配到老生区，所以老生区中的对象有两个特点：占用空间大、存活时间长。
如果使用 Scavenge 算法，复制大对象会花很长时间，同时还会浪费一半的空间。所以主垃圾回收器采用的是标记-清除(Mark-Sweep)算法。

标记过程，从根元素开始，进行递归遍历，能到达的元素就标记为活动对象，没有到达的就是垃圾数据。
垃圾清除

但是上面的标记-清除算法，如果多次执行后，会有大量的内存碎片，会导致大对象无法分配到足够的连续内存。所以有产生了一个新的算法标记-整理(Mark-Compact)，是直接将活动对象从开始进行排列，然后将边界后面的内存一次清空。
全停顿
JS 是运行在主线程上的，一旦执行垃圾回收算法，JS 脚本会停止执行，等待垃圾回收完毕后再恢复执行，这种行为叫做全停顿(Stop-The-World)。
如果堆中数据 1.5G，V8 清理垃圾的时间会超过 1s。这样会让应用的性能和响应能力下降。新生代小，影响不大，但是老生代就不能这样了，所以为了降低卡顿，V8 将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替执行，直到标记阶段完成，这个算法叫增量标记算法(Incremental Marking)。
新生代和老生代的标记过程是同一过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。
V8 还维护了一个空闲列表，也就是没有被使用的空闲空间列表，垃圾清理过程就是把没有标记的添加到空闲列表中！
增量标记会受到中间穿插的 js 应用逻辑影响么？会造成标记结果不全或者错误么？
不全没关系，新产生的垃圾下次再回收，分配内存使用空闲列表里面的。
怎么看内存泄露

一般是感官上的长时间运行页面卡顿，猜可能会有内存泄漏。
使用 chrome 的 Performance 面板，观察内存变化 如何多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！
确定不使用的临时变量置为 null，当前 es6 普及场景下少使用闭包也是一种方法。

可能导致内存泄露

全局变量过大
定时器没有清除
闭包
DOM 引用
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[css 常用]]></title>
        <id>https://www.banli17.com/css/</id>
        <link href="https://www.banli17.com/css/">
        </link>
        <updated>2020-01-29T08:19:44.013Z</updated>
        <summary type="html"><![CDATA[css 常用
滚动条样式
::-webkit-scrollbar {
    display: none;
}
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[兼容性问题]]></title>
        <id>https://www.banli17.com/css/compatible.html</id>
        <link href="https://www.banli17.com/css/compatible.html">
        </link>
        <updated>2020-01-29T08:19:44.020Z</updated>
        <summary type="html"><![CDATA[兼容性问题
line-height android 不居中
css reset
http://meyerweb.com/eric/tools/css/reset/
多行文字显示几行
文本超出 ...，只是 firefox 上文字会被截断。
.box {
    white-space: nowrap;
    text-overflow: ellipsis;
    -o-text-overflow: ellipsis;
    overflow: hidden;
}

.box(@n) {
    display: -webkit-box;
    -webkit-line-clamp: @n;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

关于文字内容溢出用点点点(…)省略号表示

滚动条隐藏
&amp;::-webkit-scrollbar {
    display: none;
}

vivo banner 没有显示，加个 width:100% 可以
iphone 6p 10 系统，卡片商品名称内容不显示，
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[extend()]]></title>
        <id>https://www.banli17.com/jquery/extend.html</id>
        <link href="https://www.banli17.com/jquery/extend.html">
        </link>
        <updated>2020-01-29T08:19:44.022Z</updated>
        <summary type="html"><![CDATA[extend 源码分析
用法
jQuery 里的 extend 主要有下面几种用法：

拷贝对象

$.extend({}, { name: "zs" }, { age: 12 });
// {name:"zs", age:12}

$.extend([], [1, 2, 3], [4, 5, 6, 7]);
// [4, 5, 6, 7];

第一个参数为 true，表示深拷贝

$.extend(
  true,
  {},
  { name: "zs", child: { name: "lisi" } },
  { child: { age: 12 } }
);

// {name:'zs',child:{name:'lisi', age:'12'}}

扩展静态方法

$.extend({
  show() {}
});

$.show();

扩展原型上的方法

$.fn.extend({
  show() {}
});

$("div").show();

原理
看完上面的用法之后，再去看 extend 的源码就简单了。它最核心的技巧就是：参数规格化。也就是保证 extend 调用方式一致。
我们来看看上面几个使用方法，实际上 extend 源码将它们进行了统一处理。即都转成了下面的形式来调用:
extend(deep, target, copy);

再看看下面示例，相信就明白了。
// 1
$.extend({}, { name: "zs" }, { age: 12 });
// 转成了
$.extend(false, {}, { name: "zs" }, { age: 12 });

// 2
$.extend({
  show() {}
});
// 转成了
// 这里 this，就是 jQuery 对象
$.extend(false, this, {
  show() {}
});

// 3
$.fn.extend({
  show() {}
});
// 转成了
// 这里 this 就是 jQuery.prototype 对象
$.fn.extend(false, this, {
  show() {}
});

练习

extend 练习地址
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[架构]]></title>
        <id>https://www.banli17.com/jquery/overall.html</id>
        <link href="https://www.banli17.com/jquery/overall.html">
        </link>
        <updated>2020-01-29T08:19:44.022Z</updated>
        <summary type="html"><![CDATA[jQuery 整体架构]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[选择器]]></title>
        <id>https://www.banli17.com/jquery/selector.html</id>
        <link href="https://www.banli17.com/jquery/selector.html">
        </link>
        <updated>2020-01-29T08:19:44.022Z</updated>
        <summary type="html"><![CDATA[选择器]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[3.系统组成和帮助命令]]></title>
        <id>https://www.banli17.com/linux/3.html</id>
        <link href="https://www.banli17.com/linux/3.html">
        </link>
        <updated>2020-01-29T08:19:44.028Z</updated>
        <summary type="html"><![CDATA[Linux 系统组成和获取命令帮助
获取命令使用帮助详解
命令的语法通用格式
COMMAND OPTIONS ARGUMENTS

发起一个命令：请求内核将某个二进制程序运行为一个进程。
程序 --&gt; 进程
静态 --&gt; 动态 (有生命周期)
命令本身是一个可执行的程序文件：二进制格式的文件，有可能会调用共享库文件
多数程序文件都存放在: /bin /sbin /usr/bin /usr/sbin 安装的有可能在 /usr/local/bin /usr/local/sbin
普通命令： /bin /usr/bin /usr/local/bin
管理命令：/sbin /usr/sbin /usr/local/sbin
共享库 /lib /lib64 /usr/lib /usr/lib64 /usr/local/lib /usr/local/lib64
32bits 的库: /lib /usr/lib /usr/local/lib
64bits 的库 /lib64 /usr/lib64 /usr/local/lib64
绿色是可执行文件，青色是链接文件
命令必须遵循特定的格式规范：exe msi ELF(linux)
查看命令文件的格式详情
file /bin/ls

命令分为两类：

shell 程序自带的命令：内置命令(builtin)
独立的可执行程序文件，文件名即命令名：外部命令

shell 程序是一个独特的程序，负责解析用户提供的命令，会去环境变量查找命令文件
环境变量 PATH: 从哪些路径中查找用户键入的命令字符串所对应的命令文件，查找次序是自左到右
echo $PATH
查看命令类型，内置还是外部命令
type COMMAND
OPTIONS
指定命令的运行特性
选项有两种表现形式

短选项 -C，如 -l -d，注意有的命令选项没有-。同一个命令同时使用多个短选项，多数可合并
长选项，--word，如 --help，--human-readable。长选项不能合并

有些选项可以带参数，叫做选项参数
ARGUMENTS: 命令的作用对象，命令对什么生效
不同的命令的参数格式不同，有些命令可同时带多个参数，多个之间以空白字符分隔。
ls /etc
ls /etc /var
le -l -d /var

获取命令的使用帮助
内部命令：help COMMAND
type type
help type

外部命令：

命令自带简要格式的使用帮助 COMMAND --help
使用手册 manual: ``

man
ls 手册位置
ls /usr/share/man

man COMMAND

SECTION
NAME 功能性说明
SYNOPSIS 语法格式
DESCRIPTION: 描述
OPTIONS 选项
EXAMPLES
AUTHOR
BUGS
SEE ALSO 参考

SYNOPSIS
[] 可选内容
&lt;&gt; 必须提供的内容
a|b 多选一
... 同类内容可出现多个
使用手册：压缩格式的文件，有章节之分
/usr/share/man
man1 man2

用户命令
系统调用
C 库调用
设备文件及特殊文件
文件格式 (配置文件格式)
游戏使用帮助
杂项
系统工具及守护进程

~]# man CHAPTER COMMAND

注意：并非每个 COMMAND 在所有章节下都有手册
查看命令在手册哪些地方有。
~]# whatis COMMAND
其执行过程是查询数据库进行的
手动更新数据库：
~]# makewhatis

man 命令打开手册以后的操作方法
翻屏：
空格键，向文件尾部翻一屏幕
b: 向文件首部翻一屏幕
ctrl+d：翻半屏幕 down
ctrl+u 上翻半屏 up
回车键 向文件尾部翻一行
k 向文件首部翻一行
G 跳至最后一行
#G 跳到指定行
1G 跳到第一行
文本搜索
/keyword 从文件首部向文件尾部依次查找，不区分字符大小写
?keyword 从文件尾部向文件首部依次查找
n 与查找命令方向相同 N 与查找命令方向相反
退出 q: quit
选项
-M /PATH/TO/SOMEDIR 到指定位置目录查找命令手册并打开
练习：useradd 命令的用法

1)添加用户 gentoo
2)添加用户 slackware 要求指定其所用的 shell 为 /bin/tcsh

useradd -s /bin/tcsh slackware
id slaceware
tail -1 /etc/passwd # 查看最后一行，可以显示 shell 类型

info COMMAND 获取命令的在线文档

很多应用程序都自带帮助文档 /usr/share/doc/APP-VERSION
README 程序的相关的信息
INSTALL 安装帮助
CHANGES 版本迭代时的改动信息

主流发行版官方文档 http://www.redhat.com/doc

程序官方的文档：官方站点上的 Document

搜索引擎
keyword filetype:pdf
keyword site:domain.tld

centeos 修改语言 https://www.jianshu.com/p/8dc24d5e893d
linux 文件系统

文件名名称严格区分字符大小写
文件可以使用除/以外的任意字符
文件名长度不能超过255字符
以.开头的文件为隐藏文件

. 当前目录
.. 当前目录的上一层目录

工作目录 working directory
家目录 home
常用基本命令实战应用
pwd
printing working directory 显示工作目录
cd
切换目录(change directory)，用法：cd [/PATH/TO/SOMEDIR]

cd 不带参数，表示切回家目录 ~也表示家目录
cd ~
cd ~USERNAME: 切换至指定用户的家目录
cd - 上一次所在目录和当前目录来回切换，shell保存了相关的变量

PWD: 当前目录
OLDPWD: 上一次的工作目录

ls
ls: list 列出指定目录下的内容，用法是ls [OPTION]... [FILE]...。

-a: 显示所有文件，包括隐藏文件，目录可以.开头，文件也可以.开头
-A: 显示除.和..之外的所有文件
-l: --long, 长格式列表，即显示文件的详细属性信息

-rw-r--r--, 1 root  root   8957 10月 14 19:34 boot.log

-表示文件类型 - d b c l s p
rw-r--r--:

rw-: 文件属主的权限
r--: 文件属性的权限
r--: 其它用户(非属主、属组)的权限

1: 数字表示文件被硬链接的次数
root: 文件的属主
root：文件的属组
8957: 数字表示文件的大小，单位是字节
10月 14 19:34: 文件最近一次被修改的时间
boot.log: 文件名

-h, --human-readable: 对文件大小单位换算，换算后结果可能为非精确值
-d: 查看目录自身而非其内部的文件列表，配合 -l 使用才有意义
-r: reverse 按逆序排序，文件名字母
-R: recursive 递归显示

cat
cat: concatenate 表示连接并显示文件内容， 文件文件查看工具

-n: 显示行号
-E: 显示行结束符$

cat /etc/fstab
cat /etc/passwd
cat /etc/issue

cat /etc/fstab /etc/passwd

tac 和 cat 一样，只是内容是逆序的
通过 file 命令可以看文件是不是文本文件，如:file /etc/fstab。
file
file 查看文件内容类型，用法：file [FILE]...
echo
echo: 回显命令，语法是echo [SHORT-OPTION]... [STRING]...。

-n: 不自动进行换行
-e: 让转义符生效  \b  \v  \t

显示颜色
echo -e &quot;\033[31mhello\033[0m everyone&quot;

其中，STRING 可以使用引号。

单引号：&quot;&quot; 强引用，变量引用不执行替换 echo '$SHELL'。
双引号：'' 弱引用，变量引用会被替换  echo &quot;$SHELL&quot;。

注意变量引用的正规符号 ${name}
shutdown
关机或重启命令，语法是shutdown [OPTIONS...] [TIME] [WALL...]。
OPTIONS

-h: halt  和 -P, --poweroff 一样
-r: reboot
-c: cancel

TIME

now
+minutes: 多少分钟后
hh:mm: 几点几分

WALL
和wall命令一样，用于向每个终端发一个消息 wall &quot;hello&quot;，默认会发送
~]# shutdown -h now
~]# shutdown -r +20 &quot;hello goodbye&quot;
Shutdown scheduled for Mon 2019-10-28 00:14:29 CST, use &#39;shutdown -c&#39; to cancel.
~]# shutdown -c

Broadcast message from root@banli.linux (Sun 2019-10-27 23:54:42 CST):

The system shutdown has been cancelled at Sun 2019-10-27 23:55:42 CST!

shutdown/halt/poweroff/reboot 的区别

shutdown 以一种安全的方式关闭系统。所有登陆用户都可以看到关机信息提示，并且 login  将被阻塞。
halt命令，若系统的 runlevel 为 0 或 6 ，则关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。
poweroff命令用来关闭计算机操作系统并且切断系统电源。
reboot执行reboot指令可让系统停止运作，并重新开机。

init 0 关机，init 6 重启。
日期相关的命令
linux 系统启动时，从硬件读取日期和时间信息，读取完成后，就不再与硬件时间相关联。

系统时钟
硬件时钟

date 系统时钟
显示和设置系统日期格式，语法是date [OPTION]... [+FORMAT]。

%F
%T
%Y
%m
%d
%H
%M
%S
%s 时间戳，从1970.1.1(unix元年)到命令执行时经历的秒数

~]# date
Mon Oct 21 00:51:45 CST 2019
~]# date +%F
2019-10-21
~]# date +%T
00:52:34
~]# date +%F +%T
date: extra operand ‘+%T’
Try &#39;date --help&#39; for more information.

~]# date +&#39;%F %T&#39;
2019-10-21 00:22:56

设置日期时间：date MMDDhhmm[[CC]YY]
如果不写年，则表示计算机当前的时间年份。
~]# date 10271108
Sun Oct 27 11:08:00 CST 2019

[[CC]YY] 表示年，可以是2位或4位
clock/hwclock 硬件时钟
查询和设置硬件时钟。主板上有个纽扣电池给硬件供电，即使关机了。
~]# hwclock --set --date=&quot;2011-08-14 16:45:05&quot;

hwclock 和 clock 是同一个命令。一个是硬连接、一个是软连接。
~]# which clock
/usr/sbin/clock
~]# file /usr/sbin/clock
/usr/sbin/clock: symbolic link to `hwclock&#39;
~]# which hwclock
/usr/sbin/hwclock
~]# file /usr/sbin/hwclock
/usr/sbin/hwclock: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=f3cee5ecdad7f100e9e0a46ff922ec2c60abb6e6, stripped

-s, --hctosys: 根据硬件时间设置系统时间。
-w, --systohc: 根据系统时间设置硬件时间。

同步远程时间
ntp常用服务器：

中国国家授时中心：210.72.145.44
NTP服务器(上海) ：ntp.api.bz

~]# yum -y install ntpdate
~]# ntpdate -u ntp.api.bz

cal 日历
用法：cal [[month] year]
~]# cal 11 19
     November 19
Su Mo Tu We Th Fr Sa
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30

课外作用，学习 which, whereis who w 命令]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[4.根文件系统和目录结构及bash特性]]></title>
        <id>https://www.banli17.com/linux/4.html</id>
        <link href="https://www.banli17.com/linux/4.html">
        </link>
        <updated>2020-01-29T08:19:44.029Z</updated>
        <summary type="html"><![CDATA[Linux根文件系统和目录结构及bash特性
10、Linux目录结构和根文件系统全面讲解
Linux: glibc
程序编译方式：

动态链接: 程序执行时会去引用特定路径下的库文件，多个程序可以共享库文件，但是移植的机器需要有这个库文件。
静态编译: 程序编译就将库文件打包进去了，体积会大，如果本机多个程序都这样做，会占用较大体积。

进程的类型：

终端： 硬件设备，关联一个用户接口

与终端相关：通过终端启动
与终端无关：操作引导启动过程当中自动启动
操作系统的组成：

静态: kernel, application
文件系统： 层级结构

FHS: Filesystem Hierarchy Standard 文件层级标准

/bin 所有用户可用的基本命令程序文件
/sbin 供系统管理使用的工具程序
/boot 引导加载器必须用到的各静态文件：kernel, initramfs(initrd), grub 等
/dev 存储特殊文件或设备文件
设备有两种类型：字符设备(键盘，一个字符一个字符发送，线性设备，有时序)、块设备(硬盘，将字符打包后发送，随机设备)
/etc  系统程序的配置文件，只能是静态文件，不能是可执行文件
/home 普通用户家目录的集中位置(可选)
/root 管理员的家目录：可选。管理员不应该登录系统。
/lib  为系统启动或根文件系统上的应用程序(/bin 、 /sbin等)提供共享库，以及为内核提供内核模块

libc.so.* 动态链接的 C 库
ld*: 运行时链接器/加载器
modules: 用于存储内核模块的目录

/lib64 64位系统特有的存放64位共享库的路径
/media 便携式设备挂载点，cdrom, floppy 等
/mnt 其它文件系统的临时挂载点
/opt 附加(第三方)应用程序的安装位置: 可选路径
/srv  当前主机为服务提供的数据
/tmp 为那些会产生临时文件的程序提供的用于存储临时文件的目录，可供所有用户执行写入操作，有特殊权限
/usr  usr hierarchy 全局共享的只读数据路径

bin sbin lib lib64
include: c程序头文件
share: 命令手册页和自带文档等架构特有的文件的存储位置
local: 另一个层级目录
X11R6: X-Window程序的安装位置
src:

/usr/local 让系统管理员安装本地应用程序，也通常用于安装第三方程序
/var 存储经常发生变化的数据的目录，如日志

log

/proc 基于内存的虚拟文件系统(临时的)，用于为内核及进程存储其相关信息，它们多为内核参数，例如 net.ipv4.ipforward 虚拟为 net/ipv4/ipforward 存储于 /proc/sys/
/sys sysfs 虚拟文件系统提供了一种必 proc 更为理想的访问内核数据的途径，其主要作用在于为管理linux设备提供了一种统一模型的接口
]]></summary>
    </entry>
    <entry>
        <title type="html"><![CDATA[5.用户组管理及用户权限]]></title>
        <id>https://www.banli17.com/linux/5.html</id>
        <link href="https://www.banli17.com/linux/5.html">
        </link>
        <updated>2020-01-29T08:19:44.029Z</updated>
        <summary type="html"><![CDATA[Linux用户组管理及用户权限]]></summary>
    </entry>
</feed>