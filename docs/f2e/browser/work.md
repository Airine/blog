---
title: 浏览器工作原理
sidebar_label: 浏览器工作原理
---

这篇文章主要讨论从打开一个 url 到网页呈现的过程中，浏览器做了哪些事情？

从用户输入 http://www.banli17.com 开始。

http://www.banli17.com 是一个 URL，因为格式是统一的，所以当输入到浏览器地址栏回车的时候，浏览器知道如何进行处理。

## DNS 解析

浏览器会将 www.banli17.com 发送给 DNS 服务器，让它解析为 IP 地址。具体查找顺序如下：

![](/img/net/dns.jpg)

1. 浏览器查找自身的 DNS 缓存。
2. 查找系统的 DNS 缓存。
3. 查找本地的 /etc/hosts 文件。
4. 发送 DNS 请求，如果路由器缓存中有则返回。
5. 查询运营商 DNS 服务器(ISP DNS)缓存。如果没有，则运营商会去做下面事情：
    - 运营商 DNS 服务器请求根 DNS 服务器，获得顶级域(com 域)的 IP 地址。
    - 运营商 DNS 服务器再请求顶级 DNS 服务器，获得权威域(banli17.com) 的 IP 地址。
    - 运营商 DNS 服务器再请求权威 DNS 服务器，获得主机的 IP 地址。
6. 将主机 IP 地址，并返回给客户端。


> 注：全球有 13 组根 DNS 服务器，负责返回顶级域 DNS 服务器的 IP 地址。顶级域 DNS 服务器，负责返回权威 DNS 服务器的 IP 地址。权威 DNS 服务器负责返回响应主机的 IP 地址。

## TCP 连接

解析到主机的 ip 地址后，就需要进行 TCP 连接了。TCP 连接的建立过程就是经典的三次握手。时序图如下：

![](/img/net/tcp3.jpg)

1. 服务端正在监听 80 端口。
2. 客户端发起 TCP 连接请求，会发送 SYN 信号，包信息是 seq = x，状态变为 SYN_SENT。
3. 服务器收到后将状态改为 SYN_RCVD(syn_received, 信号收到)，并返回 SYN,ACK 信号，seq=y, ack=x+1(确认收到客户端信号后加1)。
4. 客户端收到信号后，返回 ACK 信号，包信息是 seq=x+1，ack=y+1。
5. 服务器收到数据后，即表示握手成功。
6. 开始进行数据传输。

> 三次握手实际是为了保证客户端和服务器相互知道对方有可以发送和接收数据的能力。第 3 步时，服务器知道客户端可以发送数据，第 4 步时，客户端知道服务器可以发送和接收数据(因为ack=x+1)。第 5 步时，服务器知道客户端可以收到数据(因为客户端发送的数据是ack=y+1)。

## HTTP 请求

### 请求的构建

TCP 连接后，就开始发送 HTTP 请求了。HTTP 请求报文的格式如下：

```
方法 URL HTTP版本号    ---- 请求行
key: value           -
key: value           | --- 请求头
key: value           -

body                 ---- 实体
```

可以通过命令`curl -v www.banli17.com`。`-v`表示显示详细信息。

具体请求报文信息如下：

```
> GET / HTTP/1.1
> Host: www.banli17.com
> User-Agent: curl/7.54.0
> Accept: */*
```

```
HTTP/1.1 301 Moved Permanently
Server: nginx/1.12.2
Date: Mon, 09 Sep 2019 03:26:17 GMT
Content-Type: text/html
Content-Length: 185
Connection: keep-alive
Location: https://www.banli17.com//blog
```

HTTP 请求报文格式构建完成后，浏览器会将它通过 socket 发给传输层。

### 请求的发送

HTTP 协议是基于 TCP 协议的，它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。到了 TCP 层，他会把二进制流变成一个报文段发给服务器。

在发送每个报文段时，都需要对方有一个回应 ACK，来保证报文可靠的到达了对方，如果没有回应，那么 TCP 层会进行重传，直到可以到达。

TCP 会给每个报文加上自己的端口和目标端口，将这两个信息放在 IP 头里面，交给 IP 层进行传输。

IP 层首先看自己的地址和目标地址是否在同一个局域网，如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放在 MAC 头，发送出去即可；如果不再同一个局域网，就需要发送到网关，还需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。

网关收到包发现 MAC 符合，去除目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳的路由器。

最终到达目标的局域网，这个时候，最后一个路由器能够发现，目标地址就在自己的某个出口的局域网上，于是，在这个局域网上发送 ARP，获得这个目标的 MAC 地址，将包发出去。

目标机器发现 MAC 地址符合，就将包收起来；发现 IP 符合，根据 IP 头协议，知道上一层是 TCP 协议，就解析 TCP 头，里面有序列号，看这个序列号是不是想要的，如果是就放入缓存，返回一个 ACK，如果不是就丢弃。

TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号，于是目标机器将包发给这个进程，HTTP 服务器进程看到这个请求是访问一个网页，于是就把网页发给客户端。

### 响应报文构建

HTTP 响应报文也是有格式的。

![](/img/net/http-res.png)

构建好响应的报文后，就将这个报文发送出去，还是通过 socket 发送给 TCP 层，将 TCP 将 HTML 分成一个个小段，并保证每个段都可靠到达。

这些段加上 TCP 头后会交给 IP 层，将刚才发送过程反着走一遍。

客户端发现 MAC 地址、IP 地址符合，就交给 TCP 层，根据序列号看是不是自己的报文段，如果是，就根据 TCP 头中的端口号，发给相应的进程，即浏览器，浏览器作为客户端也在监听某个端口。

浏览器拿到 HTTP 的报文，发现返回 200，一切正常，就从正文将 HTML 拿出来解析展示。


## 解析页面

### 构建 DOM 树

客户端拿到 HTML 代码后，开始解析并构建 DOM 树。步骤如下：

1. 字符流解析成 token。通常的方案是使用状态机。
2. 根据 token 生成 DOM 数据，通常方案是使用栈。这里还要能容错处理。
3. CSS 也会生成一棵可用的抽象语法树。将 CSS 规则应用到 DOM 树，为 DOM 结构添加属性。
4. 为元素排版




### 计算 DOM 树上的 CSS 属性

### 排版

### 渲染和合成

### 绘制

## 浏览器组成

- 渲染引擎
    - html 解释器
    - css 解释器
    - 布局
- js 引擎
- 网络
- 存储
- 2D/3D 图形
- 音频和视频
- 图片解码器


渲染引擎
- chrome、opera: blink
- edge/ie: trident
- safari: webkit
- firefox: gecko


html/css/js -> 词法解析 -> 语法解析 -> 树

渲染过程画图



## 构建 DOM 树


js 会阻塞 dom 树的构建。

dom 树和render tree的区别

不严格一一对应
渲染树中通常是可显示元素，不含 head，display:none
定位的元素

### 重绘和重排

layout(reflow)  repaint

