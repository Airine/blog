# v8 工作原理

## 垃圾回收

### 栈中的垃圾回收

执行栈中有一个记录当前执行状态的指针（ESP)，指向栈顶的函数执行上下文，函数执行完成后，ESP 会下移，函数执行上下文就是无效内存了，如果调用新函数，这块内存会被覆盖掉，用来存放新函数的执行上下文。

所以说，当一个函数执行完后，JS 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

## 堆中的垃圾回收

堆中的垃圾回收，就用到了 JS 的垃圾回收器。

代际假说有两个特点：

1. 大部分对象在内存中存在的时间很短。
2. 不死的对象，会存活的更久。

V8 将堆分为新生代和老生代两个区域，新生代存放生存时间短的对象，老生代存放生存时间长的对象。

新生区通常只支持 1-8M 容量，老生区支持的容量大。V8 分别堆这两个区使用了不同的垃圾回收器。

- 副垃圾回收器，负责新生代的垃圾回收。
- 主垃圾回收器，负责老生代的垃圾回收。

### 垃圾回收器工作流程

垃圾回收器的工作流程是一致的：

1. 标记空间中活动对象和非活动对象。
2. 回收非活动对象所占用的内存。即清理标记为非活动对象的内存。
3. 内存整理，通常垃圾回收后，内存会变得不连续，有内存碎片。

### 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收，通常小的对象分配到这里。

新生代中用 Scavenge 算法来处理，即把新生区对半分为两个区域，一般是对象区域，一半是空闲区域。新加入的对象会存放在对象区域，当对象区域快满时，就需要一次垃圾回收。

垃圾回收过程中，首先标记对象区域中的垃圾，标记完成后，进行垃圾清理阶段，副垃圾回收器会把存活的对象复制到空闲区域，同时将它们有序的排列起来，所以这个复制过程相当于是内存整理。

复制完成后，对象区域和空闲区域进行反转，这种角色反转的操作能让新生代的两块内存可以无限重复使用下去。

因为 Scavenge 算法，每次要复制存活对象到空闲区域，复制需要时间成本，所以如果新生区空间太大，每次清理需要很长时间，为了执行效率，新生区会设置的比较小。

但是由于新生区空间不大，会很快被装满，所以 JS 引擎采用对象晋升策略，即经过两次垃圾回收还存活的对象，会被移动到老生区中。

### 主垃圾回收器

主垃圾回收器负责老生区的垃圾回收，除了新生区晋升的对象，一些大的对象也会直接分配到老生区，所以老生区中的对象有两个特点：占用空间大、存活时间长。

如果使用 Scavenge 算法，复制大对象会花很长时间，同时还会浪费一半的空间。所以主垃圾回收器采用的是`标记-清除(Mark-Sweep)`算法。

1. 标记过程，从根元素开始，进行递归遍历，能到达的元素就标记为活动对象，没有到达的就是垃圾数据。
2. 垃圾清除

但是上面的`标记-清除`算法，如果多次执行后，会有大量的内存碎片，会导致大对象无法分配到足够的连续内存。所以有产生了一个新的算法`标记-整理(Mark-Compact)`，是直接将活动对象从开始进行排列，然后将边界后面的内存一次清空。

### 全停顿

JS 是运行在主线程上的，一旦执行垃圾回收算法，JS 脚本会停止执行，等待垃圾回收完毕后再恢复执行，这种行为叫做全停顿(Stop-The-World)。

如果堆中数据 1.5G，V8 清理垃圾的时间会超过 1s。这样会让应用的性能和响应能力下降。新生代小，影响不大，但是老生代就不能这样了，所以为了降低卡顿，V8 将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替执行，直到标记阶段完成，这个算法叫`增量标记算法(Incremental Marking)`。

新生代和老生代的标记过程是同一过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。

V8 还维护了一个空闲列表，也就是没有被使用的空闲空间列表，垃圾清理过程就是把没有标记的添加到空闲列表中！

增量标记会受到中间穿插的 js 应用逻辑影响么？会造成标记结果不全或者错误么？
不全没关系，新产生的垃圾下次再回收，分配内存使用空闲列表里面的。

### 怎么看内存泄露

1. 一般是感官上的长时间运行页面卡顿，猜可能会有内存泄漏。
2. 使用 chrome 的 Performance 面板，观察内存变化 如何多次垃圾回收后，整体趋势是向上，就存在内部泄漏的可能！
3. 确定不使用的临时变量置为 null，当前 es6 普及场景下少使用闭包也是一种方法。

### 可能导致内存泄露

- 全局变量过大
- 定时器没有清除
- 闭包
- DOM 引用
