(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{240:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return r}),a.d(n,"rightToc",function(){return c}),a.d(n,"default",function(){return p});a(0);var t=a(251);function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function o(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var r={title:"webpack (2): 原理"},c=[{value:"bundle.js",id:"bundlejs",children:[{value:"分析",id:"分析",children:[]},{value:"异步加载",id:"异步加载",children:[]},{value:"总结",id:"总结",children:[]}]},{value:"webpack loader",id:"webpack-loader",children:[{value:"理解 loader",id:"理解-loader",children:[]},{value:"babel-loader",id:"babel-loader",children:[]},{value:"style-loader 和 css-loader",id:"style-loader-和-css-loader",children:[]},{value:"file-loader 和 url-loader",id:"file-loader-和-url-loader",children:[]}]},{value:"webpack 插件原理",id:"webpack-插件原理",children:[{value:"原理",id:"原理",children:[]}]},{value:"tapable",id:"tapable",children:[{value:"官网文档总结",id:"官网文档总结",children:[]},{value:"SyncHook",id:"synchook",children:[]},{value:"SyncBailHook",id:"syncbailhook",children:[]},{value:"SyncWaterfallHook",id:"syncwaterfallhook",children:[]},{value:"SyncLoopHook",id:"syncloophook",children:[]},{value:"AsyncParallelHook",id:"asyncparallelhook",children:[]},{value:"AsyncParallelBailHook",id:"asyncparallelbailhook",children:[]},{value:"AsyncSeriesHook",id:"asyncserieshook",children:[]},{value:"AsyncSeriesBailHook",id:"asyncseriesbailhook",children:[]},{value:"AsyncSeriesWaterfallHook",id:"asyncserieswaterfallhook",children:[]}]},{value:"参考资料",id:"参考资料",children:[]}],s={rightToc:c},i="wrapper";function p(e){var n=e.components,a=o(e,["components"]);return Object(t.b)(i,l({},s,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",{id:"bundlejs"},"bundle.js"),Object(t.b)("p",null,"这里来分析一下打包后的 bundle.js。"),Object(t.b)("h3",{id:"分析"},"分析"),Object(t.b)("p",null,"webpack 打包后的主要代码如下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'(function (modules){\n    var installedModules = {};\n    function __webpack_require__(moduleId){\n        if (installedModules[moduleId]){\n            return installedModules[moduleId].exports\n        }\n        var module = installedModules[moduleId] = {\n            i: moduleId,\n            l: false,  // 模块是否已经加载过\n            exports: {}\n        }\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)\n\n        module.l = true\n\n        return module.exports\n    }\n\n    // __webpack_public_path__, 也就是output 配置里的 publicPath\n    __webpack_require__.p = "./xx/"\n\n    return __webpack_require__(__webpack_require__.s = \'./src/index.js\')\n({\n   // 省略其它模块...\n\n   "./src/images/1.jpg": (function (module, exports, __webpack_require__) {\n     eval("module.exports = __webpack_require__.p +\\"1_5a6aef13d80078566b424bce4385c7f2.jpg\\"\\n\\n//# sourceURL=webpack:///./src/images/1.jpg?");\n   }),\n   "./src/index.js": (function (module, exports, __webpack_require__) {\n     "use strict";\n     eval("\\n\\n var fn = function fn() {\\n  console.log(\'this is index\');\\n};\\n\\nfn();\\nvar img = new Image();\\nimg.src = __webpack_require__(/*! ./images/1.jpg */ \\"./src/images/1.jpg\\");\\n\\n//# sourceURL=webpack:///./src/index.js?");\n   })\n });\n')),Object(t.b)("p",null,"上面代码可以看出这几点："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"installedModules 是用来做缓存的，如果重复 require，会使用缓存。"),Object(t.b)("li",{parentName:"ol"},"webpack 将我们写的 require() 函数转换成了",Object(t.b)("inlineCode",{parentName:"li"},"__webpack_require__()"),"，这个函数会返回",Object(t.b)("inlineCode",{parentName:"li"},"modlue.exports"))),Object(t.b)("p",null,"这段代码首先执行入口模块",Object(t.b)("inlineCode",{parentName:"p"},"./src/index.js"),"，发现里面使用了图片，即",Object(t.b)("inlineCode",{parentName:"p"},"img.src = __webpack_require('./src/images/1.jpg"),")`，它的返回结果就是图片的 url。"),Object(t.b)("p",null,"另外，还有一些转换规则如下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// a.js\nexport const a = () => {\n    console.log('aaaaaaa')\n}\n\n// b.js\nconst b = 'hello'\nexport default b\n\n// 代码\nimport {a} from './a.js'  // export a\nimport b from './b.js'   // export default b\nconsole.log(b)\n\n// 上面代码转换为\nvar _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./a.js\"); \n  console.log(_a__WEBPACK_IMPORTED_MODULE_0__[\"a\"])\nconsole.log(_a__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"])\n\n// a.js 会转换为\n__webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return a; });\\nconst a = () => {\\n    console.log('aaaaaaa')\\n}\n// 相当于 __webpack_exports__.a = a\n\n// b.js 会转换为\n__webpack_exports__[\\\"default\\\"] = (b)\n")),Object(t.b)("p",null,"可以看到 export default 导出时会挂到模块的 default 属性下面。"),Object(t.b)("p",null,"除此之外，",Object(t.b)("inlineCode",{parentName:"p"},"__webpack_require__"),"函数还有一些其它的属性和方法："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// 将模块对象暴露出去\n__webpack_require__.m = modules;\n\n// 将缓存对象暴露出去\n__webpack_require__.c = installedModules;\n\n// define getter function for harmony exports\n__webpack_require__.d = function(exports, name, getter) {\n  if(!__webpack_require__.o(exports, name)) {\n    Object.defineProperty(exports, name, { enumerable: true, get: getter });\n  }\n};\n\n// define __esModule on exports\n__webpack_require__.r = function(exports) {\n  if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n    \n    Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n  }\n  Object.defineProperty(exports, '__esModule', { value: true });\n};\n\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n  if(mode & 1) value = __webpack_require__(value);\n  if(mode & 8) return value;\n  if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n  var ns = Object.create(null);\n  __webpack_require__.r(ns);\n  Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n  if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n  return ns;\n};\n\n// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n  var getter = module && module.__esModule ?\n    function getDefault() { return module['default']; } :\n    function getModuleExports() { return module; };\n  __webpack_require__.d(getter, 'a', getter);\n  return getter;\n};\n\n// Object.prototype.hasOwnProperty.call\n__webpack_require__.o = function(object, property) { \n    return Object.prototype.hasOwnProperty.call(object, property); \n};\n\n// __webpack_public_path__, 也就是output 配置里的 publicPath\n__webpack_require__.p = \"./xx/\";\n")),Object(t.b)("h3",{id:"异步加载"},"异步加载"),Object(t.b)("p",null,"如果代码是异步加载的，会打包成什么样呢？编写 2 个模块：main.js 和 c.js。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// main.js\ndocument.onclick = function () {\n    import('./c').then(test => {\n        // Module {default: {key: 'something'}}\n        console.log(test)\n    })\n}\n\n// c.js\nexport default {\n    key: 'something'\n}\n")),Object(t.b)("p",null,"进行 webpack 打包后，会产生 2 个打包文件，分别是 bundle.js 和 0.bundle.js。"),Object(t.b)("p",null,"c.js 被编译成了 0.bundle.js，代码如下:"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'// 0.bundle.js\n(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{\n    "./src/c.js": (function(module, __webpack_exports__, __webpack_require__) {\n        eval(" __webpack_require__.r(__webpack_exports__);\n            __webpack_exports__["default"] = ({\n              key: \'something\'\n            })")\n    })\n}]);\n')),Object(t.b)("p",null,"上面的代码相当于是往 window",'["webpackJsonp"]',".push 了一个数组，后面的 c.js 模块导出了",Object(t.b)("inlineCode",{parentName:"p"},"__webpack_exports__ : {[Symbol.toStringTag]:'Module', default: {key: 'something'}"),"。"),Object(t.b)("p",null,"bundle.js 代码片段如下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'"./src/main.js": (function(module, exports, __webpack_require__) {\n    eval("document.onclick = function () {\n         __webpack_require__.e(0)\n            .then( __webpack_require__.bind(null, \\"./src/c.js\\"))\n            .then(test => { \n                console.log(test)\n            })\n    }\n})\n')),Object(t.b)("p",null,"可以看到，当点击 document 时，会执行",Object(t.b)("inlineCode",{parentName:"p"},"__webpack_require__.e(0)"),"，来看看函数 ",Object(t.b)("inlineCode",{parentName:"p"},"__webpack_require__.e")," 的代码:"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"__webpack_require__.e = function requireEnsure(chunkId) {\n    var promises = [];\n    var installedChunkData = installedChunks[chunkId];\n    if (installedChunkData !== 0) { // 0 表示已经加载过\n\n        // 如果有缓存过\n        if (installedChunkData) {\n            promises.push(installedChunkData[2]);\n        } else {\n            // 没有缓存则创建\n            var promise = new Promise(function (resolve, reject) {\n                installedChunkData = installedChunks[chunkId] = [resolve, reject];\n            });\n            promises.push(installedChunkData[2] = promise);\n            // 相当于 installedChunkData =installedChunks[0] = [resolve,reject,promise]\n\n            // 开始创建并加载 chunk js脚本\n            var script = document.createElement('script');\n            var onScriptComplete;\n            script.charset = 'utf-8';\n            script.timeout = 120;\n            if (__webpack_require__.nc) {\n                script.setAttribute(\"nonce\", __webpack_require__.nc);\n            }\n            script.src = jsonpScriptSrc(chunkId);\n            // 相当于是 <script charset='utf-8' timeout=120 nonce=__webpack_require__.nc src=`__webpack_require.p + 0.bundle.js`><\/script>\n\n            // 在栈前面创建错误，否则得不到有用的信息\n            var error = new Error();\n            onScriptComplete = function (event) {\n                // 避免ie内存泄露\n                script.onerror = script.onload = null;\n                clearTimeout(timeout);\n                var chunk = installedChunks[chunkId];\n                if (chunk !== 0) {\n                    if (chunk) {\n                        var errorType = event && (event.type === 'load' ? 'missing' : event.type);\n                        var realSrc = event && event.target && event.target.src;\n                        error.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n                        error.name = 'ChunkLoadError';\n                        error.type = errorType;\n                        error.request = realSrc;\n                        chunk[1](error);\n                    }\n                    installedChunks[chunkId] = undefined;\n                }\n            };\n            var timeout = setTimeout(function () {\n                onScriptComplete({\n                    type: 'timeout',\n                    target: script\n                });\n            }, 120000);\n            script.onerror = script.onload = onScriptComplete;\n            document.head.appendChild(script);  // 插入脚本\n        }\n    }\n    return Promise.all(promises);\n};\n")),Object(t.b)("p",null,"可以看到，大致就是将 0.bundle.js 插入到 head 中，但是 promise 在哪里执行的 resolve() 呢？"),Object(t.b)("p",null,"其实下面还有一段："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];\nvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\njsonpArray.push = webpackJsonpCallback;\njsonpArray = jsonpArray.slice();\nfor (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\nvar parentJsonpFunction = oldJsonpFunction;\n')),Object(t.b)("p",null,"webpack 重置了 window","['webpackJsonp']"," 的 push 方法，修改为了 webpackJsonpCallback。webpackJsonpCallback 的代码如下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'function webpackJsonpCallback(data) {\n    var chunkIds = data[0];\n    var moreModules = data[1];\n    // add "moreModules" to the modules object,\n    // then flag all "chunkIds" as loaded and fire callback\n    var moduleId, chunkId, i = 0,\n        resolves = [];\n    for (; i < chunkIds.length; i++) {\n        chunkId = chunkIds[i];\n        if (installedChunks[chunkId]) {\n            // 如果没有加载过 chunk，installedChunks[0] = [resolve,reject,promise]\n            // resolves.push(resolve)\n            resolves.push(installedChunks[chunkId][0]);\n        }\n        // 然后将它设为0，表示加载过了，后面会执行 resolve()\n        installedChunks[chunkId] = 0;\n    }\n\n    // 将 chunk 里的模块挂到 modules 上，方便如果还有其它地方引入时直接使用\n    for (moduleId in moreModules) {\n        if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n            modules[moduleId] = moreModules[moduleId];\n        }\n    }\n    if (parentJsonpFunction) parentJsonpFunction(data);  // 这里是\n    while (resolves.length) {\n        resolves.shift()();   // 执行 resolve()\n    }\n};\n')),Object(t.b)("p",null,"所以在 0.bundle.js 执行时，其 window","['webpackJsonp']",".push 相当于是执行了上面的 webpackJsonpCallback 方法。data 为 ",Object(t.b)("inlineCode",{parentName:"p"},"[[0], {'.src/c.js': ...}]"),"。在着里面执行了 resolve() 方法。"),Object(t.b)("p",null,"关于 parentJsonpFunction 的代码："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];\n// 同步异步模块\nfor (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\nvar parentJsonpFunction = oldJsonpFunction\n\n// webpackJsonpCallback中\nif (parentJsonpFunction) parentJsonpFunction(data);\n')),Object(t.b)("p",null,"上面代码会对 window",'["webpackJsonp"]'," 中的内容一一执行 webpackJsonpCallback，并且在异步加载时也执行一次。这样如果有在一个页面加载了多个入口文件，多个入口文件都使用了 0.js，它会只加载一次。注意这里需要 bundle2.js 在 0.js 之后加载才行。"),Object(t.b)("h3",{id:"总结"},"总结"),Object(t.b)("p",null,"总结一下上面学到的东西:"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"模块的设计，同步的模块统一存放在 modules，有缓存机制 installedModules；异步的模块会额外打包成一个 chunk，通过 ",Object(t.b)("strong",{parentName:"li"},"webpack_require"),".e 加载 chunk js，并插入到 head 头部，返回一个 promise.all()，再通过执行修改后的 webpackJsonpCallback(",Object(t.b)("inlineCode",{parentName:"li"},"window['webpackJsonp'].push = webpackJsonpCallback"),")方法，从而执行 promise 的 resolve()。"),Object(t.b)("li",{parentName:"ol"},"script 的 nonce 是用于 CSP 的。页面内嵌脚本必须有这个 nonce 才能执行。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// 服务器返回头\nContent-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'\n\n// 脚本\n<script nonce=EDNnf03nceIOfn39fn3e9h3sdfa>\n  // some code\n<\/script>\n")),Object(t.b)("h2",{id:"webpack-loader"},"webpack loader"),Object(t.b)("h3",{id:"理解-loader"},"理解 loader"),Object(t.b)("p",null,"loader 的思想是将所有的模块都当作 js 模块来处理，如 css、图片等都通过 loader 转换成 js 模块。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"对于 css: 可以转成一段功能是将 css 插入 dom 中的 js 模块。"),Object(t.b)("li",{parentName:"ul"},"对于图片，可以转成 base64 字符串内嵌，或者拷贝图片后导出图片的 URL。")),Object(t.b)("p",null,"每一个 loader 负责一件事情，符合单一职责原则。另外还可以将它们任意组合起来。如写 less 时，使用 less-loader 将 less 源文件处理为 css，再用 css-loader、style-loader 处理。"),Object(t.b)("p",null,"loader 实际是一个函数，会通过",Object(t.b)("inlineCode",{parentName:"p"},"run-loaders"),"进行执行，最终的返回值会被打包成模块形式的代码："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'"./src/index.css": (function(module, exports) {\neval("\\n        var style = document.createElement(\'style\');\\n        style.innerHTML = \\"body {\\\\n    background: red;\\\\n}\\";\\n        document.head.appendChild(style)\\n    \\n\\n//# sourceURL=webpack:///./src/index.css?");\n')),Object(t.b)("p",null,"当用 ",Object(t.b)("inlineCode",{parentName:"p"},'__webpack_require__("./src/index.css")')," 引入时，会执行这个返回值代码。"),Object(t.b)("p",null,"自己写的 loader 引用的方式："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"做成 npm 包直接引用"),Object(t.b)("li",{parentName:"ol"},"使用",Object(t.b)("inlineCode",{parentName:"li"},"resolveLoader"))),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"module.exports = {\n    ...\n    resolveLoader: {\n        alias: {\n            'babel-loader': path.resolve(__dirname, './loaders/babel-loader.js')\n        }\n    },\n    module: {\n        rules: [{\n            test: /\\.js$/,\n            loader: 'babel-loader'\n        }]\n    }\n}\n")),Object(t.b)("p",null,"loader 配置的实际是一个路径，内部会调用 require(babelLoader的路径)。"),Object(t.b)("h3",{id:"babel-loader"},"babel-loader"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"babel-loader")," 的主要功能是将 es6 源代码进行转换 es5。我们需要使用",Object(t.b)("inlineCode",{parentName:"p"},"@babel-core"),"和",Object(t.b)("inlineCode",{parentName:"p"},"@babel/preset-env"),"。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// babel-loader.js\nconst babel = require('@babel-core')\nmodule.exports = (content, map, meta) => {\n    const babelOptions = {\n        presets: ['@babel/preset-env']\n    }\n    const result = babel.transform(content, babelOptions)\n    return result.code\n}\n")),Object(t.b)("p",null,"如果需要生成 sourceMap，则要配置 babelOptions："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const babelOptions = {\n    sourceMaps: true,\n    filename: this.request.split('!')[1].split('/').pop()\n}\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"sourceMaps: true"),"告诉 babel 需要生成 sourceMap，filename 是 sourceMap 的文件名，如果不提供则是 unKnown。",Object(t.b)("inlineCode",{parentName:"p"},"this.request"),"是一个字符串，格式为",Object(t.b)("inlineCode",{parentName:"p"},"loader绝对路径!处理文件的绝对路径"),"："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"/Users/banli/Desktop/training/webpack-study/loaders/babel-loader.js!/Users/banli/Desktop/training/webpack-study/src/index.js\n")),Object(t.b)("h3",{id:"style-loader-和-css-loader"},"style-loader 和 css-loader"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"css-loader"),"的作用是解析 css 中的 @import 和 url()，将它们转为 js 模块，即转为 require() 并导出。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"style-loader"),"的作用是将样式插入到 DOM 中。大致流程如下：")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"const style = document.createElement('style')\nstyle.innerHTML = css\ndocument.head.appendChild(style)\n")),Object(t.b)("h3",{id:"file-loader-和-url-loader"},"file-loader 和 url-loader"),Object(t.b)("p",null,"我们使用图片时，代码如下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const img = new Image()\nimg.src = require('./imgs/1.png')\n")),Object(t.b)("p",null,"可以看到如果要写一个 loader，它需要将图片转成一个",Object(t.b)("inlineCode",{parentName:"p"},"module.exports=imgUrl"),"这样的模块。"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"file-loader"),"的功能就是将文件拷贝到 output 的目录，并返回 url。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const loaderUtils = require('loader-utils')\nconst fileLoader = function (content) { // 不能是箭头函数，否则里面的this有问题\n    // 获取file-loader的配置\n    const options = loaderUtils.getOptions(this) || {}\n    // options 是 {name: '[name]_[hash].[ext]'} \n    // interpolateName 是根据 name 和 content 生成唯一的文件名 url\n    let url = loaderUtils.interpolateName(this, options.name, {\n        content\n    })\n    // 生成文件\n    this.emitFile(options.outputPath ? path.join(options.outputPath ,url) : url, content)\n    // 导出 url\n    return 'module.exports = __webpack_public_path__ +' + JSON.stringify(url)\n}\n\nmodule.exports = fileLoader\n// 默认 loader 间传递的 content 是 utf8 ，raw 表示使用 raw-loader，这样收到的就是 Buffer 类型\nmodule.exports.raw = true\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"url-loader"),"比",Object(t.b)("inlineCode",{parentName:"p"},"file-loader"),"多了一个功能，是根据 limit 决定是生成文件还是生成 base64。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const loaderUtils = require('loader-utils')\nconst mime = require('mime')\n\nmodule.exports = function (content) {\n    const options = loaderUtils.getOptions(this) || {}\n    let limit = options.limit\n    if (limit) {\n        limit = parseInt(limit, 10)\n    }\n    const mimetype = options.mimetype || mime.getType(this.resourcePath);\n\n    if (!limit || content.length < limit) {\n        if (typeof content === 'string') {\n            content = new Buffer(content)\n        }\n        const base64 = `data:${mimetype};base64${content.toString('base64')}`\n        return `module.exports=${JSON.stringify(base64)}`\n    }\n\n    // 如果大于 limit，则用 file-loader 处理\n    const fallback = options.fallback || 'file-loader'\n    const fallbackLoader = require(fallback)\n    return fallbackLoader.call(this, content)\n}\n\nmodule.exports.raw = true\n")),Object(t.b)("h2",{id:"webpack-插件原理"},"webpack 插件原理"),Object(t.b)("h3",{id:"原理"},"原理"),Object(t.b)("p",null,"webpack 实现插件机制的大体过程："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"创建：在内部创建各种钩子。"),Object(t.b)("li",{parentName:"ol"},"注册：插件将自己的方法注册到对应的钩子上。"),Object(t.b)("li",{parentName:"ol"},"调用：webpack编译时，会触发对应的钩子，所以也就触发了插件的方法。")),Object(t.b)("h2",{id:"tapable"},"tapable"),Object(t.b)("h3",{id:"官网文档总结"},"官网文档总结"),Object(t.b)("p",null,"tapable 是一个类似 nodejs EventEmitter 的发布订阅模式库。它提供了一些 api："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'const {\n    SyncHook,\n    SyncBailHook,\n    SyncWaterfallHook,\n    SyncLoopHook,\n    AsyncParallelHook,\n    AsyncParallelBailHook,\n    AsyncSeriesHook,\n    AsyncSeriesBailHook,\n    AsyncSeriesWaterfallHook\n} = require("tapable");\n')),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"Sync 开头的是同步钩子，Async 开头的是异步钩子。"),Object(t.b)("li",{parentName:"ol"},"同步钩子只能用 tap 绑定事件，用",Object(t.b)("inlineCode",{parentName:"li"},"call()"),"触发，绑定事件时需要传入事件名和事件函数；异步钩子可以用 tap、tapAsync、tapPromise 绑定事件，但是它没有 call 方法，对应的需要用",Object(t.b)("inlineCode",{parentName:"li"},"callAsync()"),"、",Object(t.b)("inlineCode",{parentName:"li"},"promise()"),"触发。"),Object(t.b)("li",{parentName:"ol"},"同步钩子只支持串行，即执行完一个再执行下一个。异步钩子分为串行和并行。并行相当于 Promise.all()。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"普通钩子 Hook")," 与事件函数执行的返回值无关；",Object(t.b)("inlineCode",{parentName:"li"},"保险钩子 BailHook")," 一旦事件函数返回 null，则后面的钩子不再执行；",Object(t.b)("inlineCode",{parentName:"li"},"瀑布流钩子 WaterfallHook")," 上一个事件函数执行结果会作为参数传递给下一个事件函数，如果当前没有返回值，则上一个返回结果会穿透给下一个函数。",Object(t.b)("inlineCode",{parentName:"li"},"循环钩子 LoopHook")," 是如果事件函数返回值不为 undefined，则重复执行，否则(",Object(t.b)("inlineCode",{parentName:"li"},"即return 或 return undefined"),")会执行下一个。"),Object(t.b)("li",{parentName:"ol"},"所有的钩子都接受一个可选参数，用来声明事件函数要接收的参数。如下：")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const { SyncHook } = require(\"tapable\");\n// 只声明了一个参数name，结果 call 时传入了多的参数，会被忽略掉\nlet queue = new SyncHook(['name'])\nqueue.tap('1', function (name, age) {\n    console.log(11, name, age)  // 11, zhangsan, undefined\n})\nqueue.call('zhangsan', 12)\n")),Object(t.b)("ol",{start:6},Object(t.b)("li",{parentName:"ol"},"拦截器 intercept() 方法可以钩子运行期间做一些事情。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'myCar.hooks.calculateRoutes.intercept({\n    call: (source, target, routesList) => {\n        console.log("Starting to calculate routes");\n    },\n    register: (tapInfo) => {\n        // tapInfo = { type: "promise", name: "GoogleMapsPlugin", fn: ... }\n        console.log(`${tapInfo.name} is doing its job`);\n        return tapInfo; // may return a new tapInfo object\n    },\n    loop:(...args) =>{},\n    tap: (tap) => {}\n})\n')),Object(t.b)("ol",{start:7},Object(t.b)("li",{parentName:"ol"},"context 对象，可以通过这个对象传递自己需要的数据给后续插件或拦截器。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'myCar.hooks.accelerate.intercept({\n    context: true,\n    tap: (context, tapInfo) => {\n        // tapInfo = { type: "sync", name: "NoisePlugin", fn: ... }\n        console.log(`${tapInfo.name} is doing it\'s job`);\n\n        // `context` starts as an empty object if at least one plugin uses `context: true`.\n        // If no plugins use `context: true`, then `context` is undefined.\n        if (context) {\n            // Arbitrary properties can be added to `context`, which plugins can then access.\n            context.hasMuffler = true;\n        }\n    }\n});\n\nmyCar.hooks.accelerate.tap({\n    name: "NoisePlugin",\n    context: true\n}, (context, newSpeed) => {\n    if (context && context.hasMuffler) {\n        console.log("Silence...");\n    } else {\n        console.log("Vroom!");\n    }\n});\n')),Object(t.b)("ol",{start:8},Object(t.b)("li",{parentName:"ol"},"HookMap 是用来映射 key -> Hook 的一个帮助类。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'const keyedHook = new HookMap(key => new SyncHook(["arg"]))\nkeyedHook.tap("some-key", "MyPlugin", (arg) => { /* ... */ });\nkeyedHook.tapAsync("some-key", "MyPlugin", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise("some-key", "MyPlugin", (arg) => { /* ... */ });\nconst hook = keyedHook.get("some-key");\nif(hook !== undefined) {\n    hook.callAsync("arg", err => { /* ... */ });\n}\n')),Object(t.b)("ol",{start:9},Object(t.b)("li",{parentName:"ol"},"MultiHook 可以将多个 hook 合起来一起操作。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'const { MultiHook } = require("tapable");\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n')),Object(t.b)("h3",{id:"synchook"},"SyncHook"),Object(t.b)("p",null,"串行同步执行，当调用 ",Object(t.b)("inlineCode",{parentName:"p"},"call()"),"方法时它会一个个执行 tap 绑定的函数，如下。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const { SyncHook } = require(\"tapable\");\nlet queue = new SyncHook(['name'])\nqueue.tap('1', function (name) {\n    console.log(11, name)\n})\nqueue.tap('2', function (name) {\n    console.log(22, name)\n})\nqueue.tap('3', function (name) {\n    console.log(33, name)\n})\nqueue.call('hi')\n")),Object(t.b)("p",null,"下面简单实现一下，就是一个发布订阅模式，代码如下:"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class SyncHook {\n    constructor() {\n        this.tasks = []\n    }\n    tap(name, task) {\n        this.tasks.push(task)\n    }\n    call(...args) {\n        this.tasks.forEach(task => task(...args))\n    }\n}\n")),Object(t.b)("h3",{id:"syncbailhook"},"SyncBailHook"),Object(t.b)("p",null,"同步保险钩子，如果有一个事件函数返回值为 null 则停止执行后面的事件函数。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let {SyncBailHook} = require('tapable')\nlet h = new SyncBailHook(['name'])\nh.tap('1', function (name) {\n    console.log('1', name)\n})\nh.tap('2', function (name) {\n    console.log('2', name)\n    return null\n})\nh.tap('3', function (name) {\n    console.log('3', name)\n})\nh.call('hi')\n")),Object(t.b)("p",null,"简单实现一下，代码如下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class SyncBailHook {\n    constructor(name) {\n        this.tasks = []\n    }\n    tap(name, task) {\n        this.tasks.push(task)\n    }\n    call(...args) {\n        let ret,\n            i = 0,\n            len = this.tasks.length\n        // do {\n        //     ret = this.tasks[i++](...args)\n        // } while (ret !== null && i < len)\n        for (; i < len; i++) {\n            ret = this.tasks[i](...args)\n            if (ret === null) break\n        }\n    }\n}\n")),Object(t.b)("h3",{id:"syncwaterfallhook"},"SyncWaterfallHook"),Object(t.b)("p",null,"同步瀑布流钩子，上一个事件函数的返回值会作为下一个事件函数的参数，如果当前没有返回值或返回 undefined 则上一个事件函数的返回值会穿透给下一个事件函数的参数。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let {\n    SyncWaterfallHook\n} = require('tapable')\nlet h = new SyncWaterfallHook(['name'])\nh.tap('1', function (name) {\n    console.log(name, 1)\n    return 11\n})\nh.tap('2', function (data) {\n    console.log(data, 2)\n})\nh.tap('3', function (data) {\n    console.log(data, 3)\n})\nh.call('zs')\n\n// zs 1\n// 11 2\n// 11 3\n")),Object(t.b)("p",null,"简单实现一下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class SyncWaterfallHook {\n    constructor(name) {\n        this.tasks = []\n    }\n    tap(name, task) {\n        this.tasks.push(task)\n    }\n    call(...args) {\n        let ret = args\n        let result\n        this.tasks.forEach(task => {\n            if (typeof result !== 'undefined') {\n                ret = [result]\n            }\n            result = task(...ret)\n        })\n    }\n}\n")),Object(t.b)("h3",{id:"syncloophook"},"SyncLoopHook"),Object(t.b)("p",null,"同步循环钩子，如果当前事件函数的返回值为 undefined，则继续执行下一个，否则一直循环执行。要注意的是返回值不会传递给下一个事件函数，只有瀑布流钩子与返回值有关。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const {SyncLoopHook } = require('tapable')\nlet h = new SyncLoopHook(['name'])\nlet count = 0\nh.tap('1', function (name) {\n    console.log(count)\n    count++\n    if (count === 3) {\n        return \n    }\n    return true\n})\nh.tap('2', function (name) {\n    console.log(name)\n})\nh.call('hi')\n")),Object(t.b)("p",null,"简单实现一下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class SyncLoopHook {\n    constructor() {\n        this.tasks = []\n    }\n    tap(name, task) {\n        this.tasks.push(task)\n    }\n    call(...args) {\n        this.tasks.forEach(task => {\n            let ret\n            do {\n                ret = task(...args)\n            } while (typeof ret !== 'undefined')\n        })\n    }\n}\n")),Object(t.b)("h3",{id:"asyncparallelhook"},"AsyncParallelHook"),Object(t.b)("p",null,"异步并行钩子，可以通过 tap、tapAsync、tapPromise 三种方式绑定事件，对应的需要用 callAsync()、callAsync()、promise() 方法触发，它们的最后一个参数是一个回调函数。"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"tap + callAsync() 搭配，和 SyncHook 效果一样。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let { AsyncParallelHook } = require('tapable')\nlet h = new AsyncParallelHook(['name'])\nconsole.time('cost')\nh.tap('1', function (name) {\n    setTimeout(() => {\n        console.log(1, name)\n    }, 1000)\n})\nh.tap('2', function (name) {\n    setTimeout(() => {\n        console.log(2, name)\n    }, 2000)\n})\nh.tap('3', function (name) {\n    setTimeout(() => {\n        console.log(3, name)\n    }, 3000)\n})\nh.callAsync('hi', err => {\n    console.log('err:', err)\n    console.timeEnd('cost')  \n})\n\n// err:undefined\n// cost: 10.181ms\n// 1 hi\n// 2 hi\n// 3 hi\n")),Object(t.b)("ol",{start:2},Object(t.b)("li",{parentName:"ol"},"tapAsync + callAsync() 搭配，则需要使用事件回调函数的最后一个参数 callback，表示事件执行完成了，如果有一个事件回调函数没有调用 callback()，则不会触发 callAsync() 的回调。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let { AsyncParallelHook } = require('tapable')\nlet h = new AsyncParallelHook(['name'])\nconsole.time('cost')\nh.tapAsync('1', function (name,callback) {\n    setTimeout(() => {\n        console.log(1, name)\n        callback()\n    }, 1000)\n})\nh.tapAsync('2', function (name,callback) {\n    setTimeout(() => {\n        console.log(2, name)\n        callback()   \n    }, 2000)\n})\nh.tapAsync('3', function (name,callback) {\n    setTimeout(() => {\n        console.log(3, name)\n        callback()\n    }, 3000)\n})\nh.callAsync('hi', err => {\n    // 假设其中一个不使用callback()，则这里回调不会执行\n    console.log('err:',err)\n    console.timeEnd('cost')\n})\n// 1 hi\n// 2 hi\n// 3 hi\n// err:undefined\n// cost: 3008.706ms\n")),Object(t.b)("p",null,"下面来实现一个 tapAsync 和 callAsync()。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class AsyncParallelHook{\n    constructor() {\n        this.tasks=[];\n    }\n    tapAsync(name,task) {\n        this.tasks.push(task);\n    }\n    callAsync() {\n        let args=Array.from(arguments);\n        let callback=args.pop();\n        let i=0,length = this.tasks.length;\n        function done(err) {\n            if (++i == length) {\n                callback(err);\n            }\n        }\n        this.tasks.forEach(task => {\n            task(...args,done);\n        });\n    }\n}\n")),Object(t.b)("ol",{start:3},Object(t.b)("li",{parentName:"ol"},"tapPromis + promise() 搭配，事件处理函数需要返回一个 promise。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let { AsyncParallelHook } = require('tapable')\nlet h = new AsyncParallelHook(['name'])\nconsole.time('cost')\nh.tapPromise('1', function (name, callback) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(1, name)\n            resolve('xx')\n        }, 1000)\n    })\n})\nh.tapPromise('2', function (name, callback) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(2, name)\n            resolve('xx')\n        }, 2000)\n    })\n})\nh.tapPromise('3', function (name) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(3, name)\n            resolve('xx')\n        }, 3000)\n    })\n})\nh.promise('hi').then((data)=> {\n    // 这里data 不会接收resolve(data)的返回值，除非用 waterfall 类型的钩子\n    console.log(`data:${data}`) \n    console.timeEnd('cost')\n})\n\n// 1 hi\n// 2 hi\n// 3 hi\n// cost: 3008.312ms\n")),Object(t.b)("p",null,"下面简单实现一下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class AsyncParallelHook {\n    constructor() {\n        this.tasks = []\n    }\n    tapPromise(name, task) {\n        this.tasks.push(task)\n    }\n    promise(...args) {\n        let promises = this.tasks.map(task => task(...args));\n        return Promise.all(promises).then(() => undefined)\n    }\n}\n")),Object(t.b)("ol",{start:4},Object(t.b)("li",{parentName:"ol"},"不要用 tapAsync + promise() 搭配或其它搭配方式，有很多问题，而且从名字来看也是不合理的。")),Object(t.b)("h3",{id:"asyncparallelbailhook"},"AsyncParallelBailHook"),Object(t.b)("p",null,"异步并行保险钩子，一旦有事件函数返回值为真值(",Object(t.b)("inlineCode",{parentName:"p"},"if(data)"),")，则终止。"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"tap + callAsync() 搭配。一旦有事件函数返回值为真，则执行 callAsync 回调不再执行其它事件函数。"),Object(t.b)("li",{parentName:"ol"},"tapAsync + callAsync() 搭配，一旦有事件函数的回调 callback(真值)，则执行 callAsync 回调，继续执行其它事件函数。"),Object(t.b)("li",{parentName:"ol"},"tapPromsie + promise() 搭配，一旦有reject()，则执行 promise.then() 的 onRejected，只有全部都 resolve()，才执行promise.then 的 onFullfilled。")),Object(t.b)("h3",{id:"asyncserieshook"},"AsyncSeriesHook"),Object(t.b)("p",null,"异步串行钩子"),Object(t.b)("h3",{id:"asyncseriesbailhook"},"AsyncSeriesBailHook"),Object(t.b)("p",null,"异步串行保险钩子"),Object(t.b)("h3",{id:"asyncserieswaterfallhook"},"AsyncSeriesWaterfallHook"),Object(t.b)("p",null,"异步串行瀑布流钩子"),Object(t.b)("h2",{id:"参考资料"},"参考资料"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://github.com/lihongxun945/diving-into-webpack"}),"webpack 源码解析")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://www.zhihu.com/question/41922432?sort=created"}),"如何评价 Webpack 2 新引入的 Tree-shaking 代码优化技术？")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://github.com/DDFE/DDFE-blog#webpack%E7%B3%BB%E5%88%97"}),"滴滴webpack系列")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://www.zhufengpeixun.cn/architecture/html/26.webpack-3.tapable.html"}),"珠峰架构师成长计划")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://segmentfault.com/a/1190000015088834"}),"webpack原理"))))}p.isMDXComponent=!0},251:function(e,n,a){"use strict";a.d(n,"a",function(){return c}),a.d(n,"b",function(){return b});var t=a(0),l=a.n(t),o=l.a.createContext({}),r=function(e){var n=l.a.useContext(o),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},c=function(e){var n=r(e.components);return l.a.createElement(o.Provider,{value:n},e.children)};var s="mdxType",i={inlineCode:"code",wrapper:function(e){var n=e.children;return l.a.createElement(l.a.Fragment,{},n)}},p=function(e){var n=e.components,a=e.mdxType,t=e.originalType,o=e.parentName,c=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),s=r(n),p=a,b=s[o+"."+p]||s[p]||i[p]||t;return n?l.a.createElement(b,Object.assign({},c,{components:n})):l.a.createElement(b,c)};function b(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=a.length,r=new Array(o);r[0]=p;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=e,c[s]="string"==typeof e?e:t,r[1]=c;for(var b=2;b<o;b++)r[b]=a[b];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"}}]);