(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{166:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return r}),a.d(n,"rightToc",function(){return c}),a.d(n,"default",function(){return o});a(0);var t=a(245);function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function b(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},b=Object.keys(e);for(t=0;t<b.length;t++)a=b[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(t=0;t<b.length;t++)a=b[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var r={title:"正则表达式之理论与实战",sidebar_label:"正则表达式"},c=[{value:"元字符",id:"元字符",children:[{value:"行首、行尾符",id:"行首、行尾符",children:[]},{value:"字符组",id:"字符组",children:[]},{value:"排除型字符组",id:"排除型字符组",children:[]},{value:"用点号匹配任意字符",id:"用点号匹配任意字符",children:[]},{value:"单词边界符",id:"单词边界符",children:[]}]},{value:"多选结构",id:"多选结构",children:[]},{value:"量词",id:"量词",children:[]},{value:"括号与反向引用",id:"括号与反向引用",children:[]},{value:"特殊字符",id:"特殊字符",children:[]},{value:"转义",id:"转义",children:[]},{value:"匹配不捕获",id:"匹配不捕获",children:[]},{value:"例子",id:"例子",children:[]},{value:"子表达式",id:"子表达式",children:[]},{value:"字符",id:"字符",children:[]},{value:"总结",id:"总结",children:[]},{value:"总结",id:"总结-1",children:[]},{value:"贪婪匹配和非贪婪匹配",id:"贪婪匹配和非贪婪匹配",children:[]},{value:"学习资料",id:"学习资料",children:[]},{value:"简介",id:"简介",children:[{value:"创建正则表达式",id:"创建正则表达式",children:[]},{value:"标志",id:"标志",children:[]}]},{value:"字符串的实例方法",id:"字符串的实例方法",children:[]},{value:"实战",id:"实战",children:[]},{value:"学习资料",id:"学习资料-1",children:[]}],p={rightToc:c},i="wrapper";function o(e){var n=e.components,a=b(e,["components"]);return Object(t.b)(i,l({},p,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("p",null,"正则表达式是一种匹配字符串的模式。可以通过它来检测一个字符串是否满足这个模式，进而对字符串进行处理。"),Object(t.b)("h2",{id:"元字符"},"元字符"),Object(t.b)("p",null,"理解正则表达式要单个字符的理解，比如",Object(t.b)("inlineCode",{parentName:"p"},"/abcd/"),"要理解成匹配字符的第一个字符是a，后面是b，再后面是c，后面是d。而不要直接理解为匹配",Object(t.b)("inlineCode",{parentName:"p"},"abcd"),"字符串。"),Object(t.b)("p",null,"元字符有",Object(t.b)("inlineCode",{parentName:"p"},"( [ { \\ ^ $ | ) ? * + .] }"),"。"),Object(t.b)("h3",{id:"行首、行尾符"},"行首、行尾符"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"^"),"表示行首符，",Object(t.b)("inlineCode",{parentName:"p"},"$"),"表示行尾符。即",Object(t.b)("inlineCode",{parentName:"p"},"^a$"),"表示行首字符是 a，行尾字符也是 a。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"/^a$/.test('a')    // true\n/^a$/.test('ali')  // false\n")),Object(t.b)("h3",{id:"字符组"},"字符组"),Object(t.b)("p",null,"字符组用来匹配某些字符中的一个。比如",Object(t.b)("inlineCode",{parentName:"p"},"1[abc]"),"用于匹配开始是字符1，后面字符是 a 或 b 或 c。"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"[]"),"里还可以用",Object(t.b)("inlineCode",{parentName:"p"},"-"),"表示范围，比如",Object(t.b)("inlineCode",{parentName:"p"},"[a-z]"),"表示字母 a-z 中的一个。还可以组合使用",Object(t.b)("inlineCode",{parentName:"p"},"[a-z0-9A-Z]"),"或",Object(t.b)("inlineCode",{parentName:"p"},"[a-z!?]"),"等。这里的 ? 不再是当做元字符，而是字符本身。"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"[^a]"),"表示非 a 的字符。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"/a[^a]/.test('a')   // false\n/a[^a]/.test('ae')  // true\n\n// [^cat$]  匹配单行cat\n// [^$]  匹配空行\n// [^]  没意义，任何一行都行\n\n/[\\w]/.test('t')  // true，也表示单个元字符，表示[A-Za-z0-9_]\n/[\\t]/.test('   ')\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"-"),"表示字符组元字符，只有在字符组 [] 里才表示元字符。在外面表示普通字符。"),Object(t.b)("h3",{id:"排除型字符组"},"排除型字符组"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"[^...]"),"表示这个字符组匹配任何未列出的字符。比如",Object(t.b)("inlineCode",{parentName:"p"},"[^1-6]"),"匹配除了1到6以外的任何字符。在字符组里",Object(t.b)("inlineCode",{parentName:"p"},"^"),"表示排除。"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"q[^u]"),"表示第一个字符是q，后面字符不是u。"),Object(t.b)("h3",{id:"用点号匹配任意字符"},"用点号匹配任意字符"),Object(t.b)("p",null,"元字符",Object(t.b)("inlineCode",{parentName:"p"},"."),"用来匹配任意字符(除了行结束符\\n \\r \\u2028或\\u2029)。比如要搜索 03/19/76、03-19-76 或者 03.19.76，可以使用03","[.-/]","19","[.-/]","76，或者是 03.19.76。"),Object(t.b)("p",null,"字符组",Object(t.b)("inlineCode",{parentName:"p"},"[]"),"只能匹配其中的一个字符，而.能够匹配任何字符。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"/./.test('\\n')   // false\n")),Object(t.b)("h3",{id:"单词边界符"},"单词边界符"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"\\b"),"表示单词边界。",Object(t.b)("inlineCode",{parentName:"p"},"\\B"),"表示非单词边界。边界大致是空格、-、结束、开始、$等字符，但是边界又不是字符，它是一个界限。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"/\\bcat\\b/.test('hellocat')  // false\n/\\bcat\\b/.test('hello cat')  // true\n/\\bcat\\b/.test('hello我cat') // true\n/\\b我\\b/.test('hello我cat')  // true\n\n\n// 不是字符，是界限\nconst a = /\\b/g\nconst str = 'helhlo hi'\n\nconst b = str.replace(a, 'x')\nconsole.log(b)  // xhelhlox xhix\n\n// 下面代码会死循环，因为边界不是字符，所以lastIndex不会移动\nconst a = /\\b/g\nconst str = 'helhlo hi'\n\nwhile (true) {\n    const c = a.test(str)\n    console.log(c, a.lastIndex) // true 0\n    if(!c) break\n}\n")),Object(t.b)("h2",{id:"多选结构"},"多选结构"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"|"),"表示或，用来匹配任意子表达式，比如",Object(t.b)("inlineCode",{parentName:"p"},"Bob|Robert"),"，注意它匹配的是 Bob 或 Robert，而不是 Bobobert 或 BoRobert。如果要匹配他们，需要写成",Object(t.b)("inlineCode",{parentName:"p"},"Bob(b|R)obert"),"。",Object(t.b)("inlineCode",{parentName:"p"},"|"),"通常也确实是和",Object(t.b)("inlineCode",{parentName:"p"},"()"),"一起使用。"),Object(t.b)("h2",{id:"量词"},"量词"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"?"),"：有或者没有，即 {0, 1}"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"+"),"：1个或多个，即 {1,}"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"*"),"：0个或多个，即 {0,}"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"{m, n}"),"：m个到n个都可以，如果n不确定，可以写成",Object(t.b)("inlineCode",{parentName:"li"},"{m,}"),"表示大于m个，注意",Object(t.b)("inlineCode",{parentName:"li"},"{,n}"),"不表示小于n个，而是表示本意。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"{m}"),"：m个")),Object(t.b)("h2",{id:"括号与反向引用"},"括号与反向引用"),Object(t.b)("p",null,"括号的作用有将字符组成一个单元组，用于搭配量词或者多选结构使用。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"/(abc)?/\n/(abc|def)/\n")),Object(t.b)("p",null,"不过它还有一个重要的用途，就是反向引用，括号会记忆匹配到的文本，可以用 \\n 的方式引用这些记忆的文本。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"/(\\d+)(\\1)(\\2)\\3/.test('123123123123')\n")),Object(t.b)("p",null,"上面的",Object(t.b)("inlineCode",{parentName:"p"},"\\1"),"表示引用第一个括号(也叫子表达式)匹配到的文本，也就是 123。同理 \\2、\\3 就是第二个、第三个括号里的内容都是 123。"),Object(t.b)("p",null,"注意括号在字符组 [] 里是括号本身字符，而不是单元组的意思。"),Object(t.b)("h2",{id:"特殊字符"},"特殊字符"),Object(t.b)("p",null,"正则表达式对一些不能打印的特殊字符，提供了表达方法。"),Object(t.b)("p",null,"\\cX 表示Ctrl-","[X]","，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。\n","[\\b]"," 匹配退格键(U+0008)，不要与\\b混淆。\n\\n 匹配换行键。\n\\r 匹配回车键。\n\\t 匹配制表符 tab（U+0009）。\n\\v 匹配垂直制表符（U+000B）。\n\\f 匹配换页符（U+000C）。\n\\0 匹配null字符（U+0000）。\n\\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。\n\\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符。"),Object(t.b)("h2",{id:"转义"},"转义"),Object(t.b)("p",null,"我们知道 . 表示元字符，会匹配任意字符。但是我们要匹配",Object(t.b)("inlineCode",{parentName:"p"},"0.1"),"怎么写呢？"),Object(t.b)("p",null,"这时就需要用到",Object(t.b)("inlineCode",{parentName:"p"},"\\."),"，叫做转义。转义后，元字符就失去了其意义，直接可以将",Object(t.b)("inlineCode",{parentName:"p"},"\\."),"看做是匹配.字符。"),Object(t.b)("h2",{id:"匹配不捕获"},"匹配不捕获"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"()"),"里的内容默认是捕获的，如果需要不捕获，则使用",Object(t.b)("inlineCode",{parentName:"p"},"(?:)"),"。"),Object(t.b)("h2",{id:"例子"},"例子"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),'# 匹配标志符\n[a-zA-Z_][a-zA-Z_0-9]{0, 31}\n\n# 引号内的字符串\n"[^"]*"\n\n# 美元金额\n$[0-9]*(\\.[0-9]{2})?\n\n# html tag\n<.*?>\n')),Object(t.b)("h2",{id:"子表达式"},"子表达式"),Object(t.b)("p",null,"子表达式是正则表达式的一部分。比如",Object(t.b)("inlineCode",{parentName:"p"},"H[1-6]"),"，H 和 ","[1-6]"," 都是子表达式。"),Object(t.b)("h2",{id:"字符"},"字符"),Object(t.b)("p",null,"字符的值代表的字符在不同编码中可能不一样。不过现在基本都是采用unicode编码处理数据。"),Object(t.b)("h2",{id:"总结"},"总结"),Object(t.b)("p",null,Object(t.b)("img",l({parentName:"p"},{src:"./imgs/reg1.png",alt:null}))),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"各个egrep程序有差异，支持的元字符以及元字符的意义有差异。"),Object(t.b)("li",{parentName:"ul"},"括号用于：限制多选结构、分组、捕获文本"),Object(t.b)("li",{parentName:"ul"},"转义的3种情况",Object(t.b)("ul",{parentName:"li"},Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"\\ + 元字符"),"：表示匹配元字符所使用的普通字符"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"\\ + 非元字符"),"：组成有意义的元字符序列，比如",Object(t.b)("inlineCode",{parentName:"li"},"\\<"),"表示单词边界"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"\\ + 任意字符"),"：默认表示匹配该字符，也就是反斜杠会被忽略")))),Object(t.b)("h2",{id:"总结-1"},"总结"),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"4.字符含义解释")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"() 的作用是提取匹配的字符串，也叫子表达式"),Object(t.b)("li",{parentName:"ul"},"[] 定义匹配的范围，比如","[a-zA-Z0-9]"),Object(t.b)("li",{parentName:"ul"},"^ 和 $ 表示开始和结尾，注意如果^出现在[]中，表示取反"),Object(t.b)("li",{parentName:"ul"},"\\d 非负数字，等价于","[0-9]"),Object(t.b)("li",{parentName:"ul"},"\\s 空白字符"),Object(t.b)("li",{parentName:"ul"},"\\w 英文字符或数字，等价于","[a-zA-Z0-9_]"),Object(t.b)("li",{parentName:"ul"},". 除了换行以外的任意字符，等价于",Object(t.b)("sup",l({parentName:"li"},{id:"fnref-\\n"}),Object(t.b)("a",l({parentName:"sup"},{href:"#fn-\\n",className:"footnote-ref"}),"\\n"))),Object(t.b)("li",{parentName:"ul"},"\\b 单词边界，不代表任何字符。所以/\\w\\b\\w/不能匹配任何字符。"),Object(t.b)("li",{parentName:"ul"},"\\B 非单词边界"),Object(t.b)("li",{parentName:"ul"},"|  选择符，表示或者"),Object(t.b)("li",{parentName:"ul"},"\\r  回车符"),Object(t.b)("li",{parentName:"ul"},"\\W ",Object(t.b)("sup",l({parentName:"li"},{id:"fnref-a-za-z0-9_"}),Object(t.b)("a",l({parentName:"sup"},{href:"#fn-a-za-z0-9_",className:"footnote-ref"}),"A-Za-z0-9_")))),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"5.量词有哪些?")),Object(t.b)("p",null,"用来表示数量的字符。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("ul",{parentName:"li"},Object(t.b)("li",{parentName:"ul"},"表示匹配0次或多次，比如\\d*，表示0个或多个数字"))),Object(t.b)("li",{parentName:"ul"},Object(t.b)("ul",{parentName:"li"},Object(t.b)("li",{parentName:"ul"},"表示匹配1次或多次"))),Object(t.b)("li",{parentName:"ul"},"? 表示0次或1次，相当于{0, 1}"),Object(t.b)("li",{parentName:"ul"},"{} 表示匹配的长度，比如\\n{3}表示匹配3个数字，\\d{1, 3}表匹配1-3个数字，\\d{3,}表示匹配3个以上数字")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"6.存储")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"RegExp.$1 - RegExp.$9 存放着最近一次匹配9个子表达式结果，如果没有则是空字符串",Object(t.b)("inlineCode",{parentName:"li"},'""'),"。"),Object(t.b)("li",{parentName:"ul"},"\\n   如果n是正整数表示反向引用，比如\\1,表示和对应子表达式一样。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'/(\\d)(\\d)/.test(\'15helo\')\n\nRegExp.$1  //1\nRegExp.$2  //5\n\n//在replace中使用\n"2016-03-26".replace(/(\\d+)-(\\d+)-(\\d+)/,"$1年$2月$3日")\n\nvar rgx = /\\d{4}(\\-|\\/|.)\\d{1,2}\\1\\d{1,2}"/\n')),Object(t.b)("h2",{id:"贪婪匹配和非贪婪匹配"},"贪婪匹配和非贪婪匹配"),Object(t.b)("p",null,"默认情况下正则会匹配更多的字符，这叫做贪婪匹配。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var a = 'hellox'\nvar reg = /(l+)/\nvar c = a.match(reg)\nconsole.log(RegExp.$1)   // ll\n")),Object(t.b)("p",null,"上面的例子匹配了更多的l:",Object(t.b)("inlineCode",{parentName:"p"},"ll"),"，而没有只匹配一个l，这就是贪婪匹配。"),Object(t.b)("p",null,"如果要匹配l，则是非贪婪匹配，需要在",Object(t.b)("inlineCode",{parentName:"p"},"+"),"这种量词后面加上",Object(t.b)("inlineCode",{parentName:"p"},"?"),"即可。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var a = 'hellox'\nvar reg = /(l+?)/\nvar c = a.match(reg)\nconsole.log(RegExp.$1)   // l\n\n// 其它\n'abb'.match(/ab*b/) // [\"abb\"]\n'abb'.match(/ab*?b/) // [\"ab\"]\n\n'abb'.match(/ab?b/) // [\"abb\"]\n'abb'.match(/ab??b/) // [\"ab\"]\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"匹配不捕获")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"?:"),"表示匹配但不捕获。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'// 例1\nvar m = \'abc\'.match(/(?:.)b(.)/);\nm // ["abc", "c"]\n\n// 例2，匹配foo，或foofoo\nvar a = /(?:foo){1, 2}/\n')),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"正向预查和反向预查")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"x(?=y)  先行断言，x只有在y前面才匹配，y不会被计入返回结果。"),Object(t.b)("li",{parentName:"ul"},"x(?!y)  先行否定断言，x只有不在y前面才匹配，y不会被计入返回结果。"),Object(t.b)("li",{parentName:"ul"},"x(?<=y) 后行断言"),Object(t.b)("li",{parentName:"ul"},"x(?<!y) 后行否定断言")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 先行否定断言\nvar a = 'hello nihao xhell'\nvar reg = /\\b\\w+(?!\\b)/g\nconsole.log(a.match(reg))  //[ 'hell', 'niha', 'xhel' ]\n\n// 后行断言\n/(?<=\\$)\\d+/.exec('Benjamin Franklin is on the $100 bill')\n// 结果[\"100\", index: 29, input: \"Benjamin Franklin is on the $100 bill\"]\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"1. 提取浏览器参数")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var str = \"name=zhangsan&age=12\"\nvar reg = /([^&=]+)=([^&=]*)/gi; // [^&=]+表示匹配非=&的连续字符串\n\nvar paramObj = {}\nstr.replace(reg, (...args)=> {\n    obj[args[1]] = args[2]\n})\n\nconsole.log(paramObj);  // { name: 'zhangsan', age: '12' }\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"2. 扩展typeof")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"function getTypeOf(obj){\n    return Object.prototype.toString.call(obj)\n           .replace(/\\[object\\s(\\w+)\\]/,'$1'); //[object Xxx]\n}\n\ngetDataType(1); //number\ngetDataType('a'); //string\ngetDataType(null); //null\ngetDataType([]); //array\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"3. 在字符串指定位置插入新字符串")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'String.prototype.insetAt = function(str,offset){\n\n    offset = offset + 1;\n    //使用RegExp()构造函数创建正则表达式\n    var regx = new RegExp("(^.{"+offset+"})");\n\n    return this.replace(regx,"$1"+str);\n};\n\n"abcd".insetAt(\'xyz\',2); //在c字符后插入xyz\n>> "abcxyzd"\n')),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"4. 将手机号12988886666转化成129**"),"6666**"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'function telFormat(tel){\n\n    tel = String(tel);\n\n    //方式一\n    return tel.replace(/(\\d{3})(\\d{4})(\\d{4})/,function (rs,$1,$2,$3){\n       return $1+"****"+$3\n    });\n\n    //方式二\n    return tel.replace(/(\\d{3})(\\d{4})(\\d{4})/,"$1****$3");\n}\n')),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},'5. 实现HTML编码，将< / > " & ` 等字符进行转义，避免XSS攻击')),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'function htmlEncode(str) {\n    //匹配< / > " & `\n    return str.replace(/[<>"&\\/`]/g, function(rs) {\n        switch (rs) {\n            case "<":\n                return "&lt";\n                break;\n            case ">":\n                return "&gt";\n                break;\n            ...\n        }\n    });\n}\n')),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"6.格式化货币")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 先行断言，转化货币格式\n'9999999'.replace(/\\B(?=(\\d{3})+(?!\\d))/g/, ',')\n")),Object(t.b)("p",null,"这个正则有点复杂，先看下面代码，然后再分析一下："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"const a = '0123456789'\nconst reg = /\\B/g\n\nconst b = a.replace(reg, ',')\nconsole.log(b)  // 0,1,2,3,4,5,6,7,8,9\n\nconst reg1 = /\\b/g\nconst c = a.replace(reg1, ',')\nconsole.log(c)  // ,0123456789,\n\nconst reg2 = /\\B(?=(\\d{3})+(?!\\d))/g\nconst d = a.replace(reg2, ',')\nconsole.log(d)  // 0,123,456,789\n")),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"\\B 表示非单词边界，所以每个数字中间都是一个\\B"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"(?=(\\d{3})+(?!\\d))")," 表示n * 3个数字，这3个数字后面不能是数字。"),Object(t.b)("li",{parentName:"ol"},"所以边界后面必须是n倍的3个数字。")),Object(t.b)("h2",{id:"学习资料"},"学习资料"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://www.cnblogs.com/onepixel/p/5218904.html"}),"JavaScript 中的正则表达式")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://www.cnblogs.com/aaronjs/archive/2012/06/30/2570970.html"}),"精通 JS正则表达式")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://segmentfault.com/a/1190000008088937"}),"JS正则表达式一条龙讲解")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://www.cnblogs.com/onepixel/articles/7717789.html"}),"正则表达式零宽断言详解")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://wangdoc.com/javascript/stdlib/regexp.html"}),"阮一峰 regexp对象")),Object(t.b)("li",{parentName:"ul"},"[正则原理]"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://juejin.im/post/5965943ff265da6c30653879"}),"JS正则表达式完整教程（略长）"))),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"工具")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://rubular.com/"}),"Rubular在线正则工具")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://scriptular.com/"}),"scriptular在线正则工具")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"https://regexper.com/"}),"regexper正则学习工具"))),Object(t.b)("h2",{id:"简介"},"简介"),Object(t.b)("h3",{id:"创建正则表达式"},"创建正则表达式"),Object(t.b)("p",null,"创建正则表达式的方式有2种："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 1. 字面量方式\nconst reg = /\\w+/i\n\n// 2. 构造函数方式\nconst reg = new RegExp('hello', 'i')\nconst reg = new RegExp('\\\\w+', 'i')\n")),Object(t.b)("p",null,"这两种方式的区别是："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"构造函数方式所有元字符都需要双重转义（比如\\w要写成","\\","w）。"),Object(t.b)("li",{parentName:"ol"},"字面量方式会在引擎编译代码时创建正则表达式，构造函数方式是在运行时创建，所以前者效率更高。"),Object(t.b)("li",{parentName:"ol"},"构造函数方式可以拼接变量")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 构造函数方式拼接变量\nconst a = 'hello'\nconst reg = new RegExp('x'+ a + 'y')\n")),Object(t.b)("h3",{id:"标志"},"标志"),Object(t.b)("p",null,"正则表达式可以加标志，比如上面例子中的字母",Object(t.b)("inlineCode",{parentName:"p"},"i"),"，表示忽略大小写。它的标志有3个："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"g: 默认只匹配第一个就结束，加上g会匹配所有的。"),Object(t.b)("li",{parentName:"ul"},"i: 默认是区分大小写的，加上i表示忽略大小写。"),Object(t.b)("li",{parentName:"ul"},"m: 多行匹配。正则匹配时默认是将字符串当作一行来匹配的，只有一个^$；如果加了标志符m，就是以\\n换行，每行都有^$。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 不加m，表示将字符串当作一行，所以匹配不到\nconst reg = /^hello/\nconst str = 'ahello \\n\\rhello'\n\nconsole.log(str.match(reg))  // null\n\n// 加m\nconst reg = /^hello/m\nconst str = 'ahello \\n\\rhello'\n\nconsole.log(str.match(reg))  // [ 'hello' ]\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"正则实例的属性")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.prototype.flags"),": 获取实例的标志符，比如'm'"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.prototype.global"),": 是否设置了g"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.prototype.ignoreCase"),": 是否设置了i"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.prototype.multiline"),": 是否设置了m"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.prototype.lastIndex"),": 返回一个整数，表示下一次开始搜索的位置。可读写，只有在连续搜索时有意义。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.protoptye.source"),": 返回正则表达式的字符串形式，不包括反斜杠，只读。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'const r = /abc/igm;\n\nr.lastIndex // 0\nr.source // "abc"\n')),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"正则实例的方法")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.protoptye.test(str)"),": 返回布尔值，表示正则是否匹配字符串。")),Object(t.b)("p",null,"如果有g标志，正则表达式会记住上次",Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"属性，从",Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"开始匹配。如果没有g标志，则每次",Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"都是从0开始匹配。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 有 g 标志\nvar r = /x/g;\nvar s = '_x_x';\n\nr.lastIndex // 0\nr.test(s) // true\n\nr.lastIndex // 2\nr.test(s) // true\n\nr.lastIndex // 4\nr.test(s) // false\n\n// 之后lastIndex会重置为0\nr.lastIndex // 0\nr.test(s) // true\n\n// 没有g标志\nconst reg = /a/\nconst str = 'helnaixxa'\nconsole.log(reg.lastIndex)  // 0 \nconsole.log(reg.test(str)) //  true\nconsole.log(reg.lastIndex)  // 0\nconsole.log(reg.test(str)) // true\n")),Object(t.b)("p",null,"要注意的是，如果有g标志，正则表达式会记住上次",Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"属性，所以不应该更换所要匹配的字符串，否则会出错。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"const r = /bb/g\n\nconsole.log(r.test('bb'))  // true\nconsole.log(r.test('bb')) // false ，这里lastIndex不是0了\nconsole.log(r.test('bb'))  // true\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"属性只对同一个正则表达式有效，所以下面的代码是错误的。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var count = 0;\nwhile (/a/g.test('babaa')) count++;\n")),Object(t.b)("p",null,"上面的代码每次循环都会创建一个新的正则，",Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"每次都是0，所以会导致死循环。"),Object(t.b)("p",null,"如果正则模式是空字符，则匹配所有字符串。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"new RegExp('').test('abc')  // true\n\n// 下面写法错误，是当作注释\nconst r = //\nconsole.log(r.test('hello'))  // r is not defined\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"RegExp.prototype.exec()"),": 用来返回匹配结果，如果发现匹配就返回一个数组，成员是匹配成功的子字符串，否则返回",Object(t.b)("inlineCode",{parentName:"li"},"null"),"。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var s = '_x_x';\nvar r1 = /x/;\nvar r2 = /y/;\n\nr1.exec(s) // [\"x\"]\nr2.exec(s) // null\n")),Object(t.b)("p",null,"如果正则表达式包含圆括号(即组匹配)，则返回的数组会包含多个成员，第一个是匹配成功的结果，后面成员是圆括号对应的匹配成功的结果。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'var s = \'_x_x\';\nvar r = /_(x)/;\n\nr.exec(s) // ["_x", "x"]\n')),Object(t.b)("p",null,"exec方法返回的数组还包括两个属性："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"input"),": 原字符串"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"index"),": 整个模式匹配成功的开始位置")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),'var r = /a(b+)a/;\nvar arr = r.exec(\'_abbba_aba_\');\n\narr // ["abbba", "bbb"]\n\narr.index // 1\narr.input // "_abbba_aba_"\n')),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"exec()"),"默认是匹配到第一个结果就返回；如果加上标志g，则可以使用多次",Object(t.b)("inlineCode",{parentName:"p"},"exec"),"方法，下次搜索的位置从上一次匹配成功结束的位置开始。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"const reg = /a/g\nconst str = 'helloanihaoahia'\n\nwhile (true) {\n    let match = reg.exec(str)\n    console.log(match, reg.lastIndex)\n    if (!match) break\n}\n\n// [ 'a', index: 5, input: 'helloanihaoahia' ] 6\n// [ 'a', index: 9, input: 'helloanihaoahia' ] 10\n// [ 'a', index: 11, input: 'helloanihaoahia' ] 12\n// [ 'a', index: 14, input: 'helloanihaoahia' ] 15\n// null 0\n")),Object(t.b)("p",null,"每次调用正则的方法匹配，lastIndex会移动"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"const reg = /ab/g\nconst str = 'cabxxx_abeee_abcc'\nreg.test(str)\nreg.exec(str)\nconsole.log(reg.lastIndex) // 9\n")),Object(t.b)("h2",{id:"字符串的实例方法"},"字符串的实例方法"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"String.prototype.match()"),": 返回一个数组，成员是所有匹配的子字符串；否则返回null。")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"match()"),"和",Object(t.b)("inlineCode",{parentName:"p"},"exec()"),"方法在没有标志g时返回结果类似；但是当有标志g时，它会返回匹配结果的数组，而且没有",Object(t.b)("inlineCode",{parentName:"p"},"input"),"，",Object(t.b)("inlineCode",{parentName:"p"},"index"),"属性。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var s = '_x_x_';\nvar r1 = /x(_)/;\nvar r2 = /y/;\n\nconsole.log(s.match(r1)) // [ 'x_', '_', index: 1, input: '_x_x_' ]\nconsole.log(s.match(r2)) // null\n\nvar s1 = '_x_x_';\nvar r3 = /x(_)/g;\nvar r4 = /y/;\n\nconsole.log(s.match(r3)) // [ 'x_', 'x_' ]\nconsole.log(s.match(r4)) // null\n")),Object(t.b)("p",null,"设置正则的",Object(t.b)("inlineCode",{parentName:"p"},"lastIndex"),"属性，对match方法无效，它总是从第一个字符开始匹配。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var r = /a|b/g;\nr.lastIndex = 7;\n'xaxb'.match(r) // ['a', 'b']\nr.lastIndex // 0\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"String.prototype.search()"),": 返回第一个匹配结果的位置，没有则返回-1。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"String.prototype.replace()"),": 可以替换匹配的值。不会改变原字符串。返回改变后的字符串。")),Object(t.b)("p",null,"如果不加标志g，则替换第一个匹配的值，否则替换所有的。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"'aaa'.replace('a', 'b') // \"baa\"\n'aaa'.replace(/a/, 'b') // \"baa\"\n'aaa'.replace(/a/g, 'b') // \"bbb\"\n")),Object(t.b)("p",null,"下面用replace去除字符串首尾空格："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var str = '  #id div.class  ';\nstr.replace(/^\\s+|\\s+$/g, '')\n// \"#id div.class\"\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"replace"),"方法第二个参数可以使用$来指代所替换的内容。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"$& 匹配的子字符串"),Object(t.b)("li",{parentName:"ul"},"$` 匹配结果前面的文本"),Object(t.b)("li",{parentName:"ul"},"$' 匹配结果后面的文本"),Object(t.b)("li",{parentName:"ul"},"$n 匹配成功的第n组内容，n从1开始"),Object(t.b)("li",{parentName:"ul"},"$$ 只带美元符号$")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"'hello world'.replace(/(\\w+)\\s(\\w+)/, '$2 $1')\n// \"world hello\"\n\n'abc'.replace('b', '[$`-$&-$\\']')\n// \"a[a-b-c]c\"\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"replace()"),"方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"'3 and 5'.replace(/[0-9]+/g, function (match) {\n  return 2 * match;\n})\n// \"6 and 10\"\n\nvar a = 'The quick brown fox jumped over the lazy dog.';\nvar pattern = /quick|brown|lazy/ig;\n\na.replace(pattern, function replacer(match) {\n  return match.toUpperCase();\n});\n// The QUICK BROWN fox jumped over the LAZY dog.\n")),Object(t.b)("p",null,"作为replace方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"const d = /hello(你)/g\nconst str = 'hello你我他hello你我'\n\nlet e = str.replace(d, function (a, b, c, d) {\n    console.log(a, b, c, d)\n})\n\n// hello你 你 0 hello你我他hello你我\n// hello你 你 8 hello你我他hello你我\n")),Object(t.b)("p",null,"下面是一个网页模板替换的例子。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var prices = {\n    'p1': '$1.99',\n    'p2': '$9.99',\n    'p3': '$5.00'\n};\n\nvar template = '<span id=\"p1\"></span>'\n    + '<span id=\"p2\"></span>'\n    + '<span id=\"p3\"></span>';\n\n\nvar t = template.replace(/(<span id=\"(.+?)\">)(<\\/span>)/, function (match, $1, $2, $3) {\n    return $1 + prices[$2] + $3\n})\n\nconsole.log(t) // <span id=\"p1\">$1.99</span><span id=\"p2\"></span><span id=\"p3\"></span>\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"String.prototype.split(separator[, limit])"),": 按照正则分割字符串。第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"// 非正则分隔\n'a,  b,c, d'.split(',')\n// [ 'a', '  b', 'c', ' d' ]\n\n// 正则分隔，去除多余的空格\n'a,  b,c, d'.split(/, */)\n// [ 'a', 'b', 'c', 'd' ]\n\n// 指定返回数组的最大成员\n'a,  b,c, d'.split(/, */, 2)\n// [ 'a', 'b' ]\n\n'aaa*a*'.split(/a*/)\n// [ '', '*', '*' ]\n\n'aaa**a*'.split(/a*/)\n// [\"\", \"*\", \"*\", \"*\"]\n\n// 如果有括号，会将括号里的匹配部分也当作数组元素返回\n'aaa*a*'.split(/(a*)/)\n// [ '', 'aaa', '*', 'a', '*' ]\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"7.js中使用正则")),Object(t.b)("p",null,"js中使用正则，主要是字符串的match()、search()、replace()、split()方法，和正则的test()、exec()方法。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"str.match(reg)"),Object(t.b)("li",{parentName:"ul"},"str.replace(","[RegExp|String]",",","[String|Function]",")")),Object(t.b)("p",null,"如果第二个参数是函数，函数的参数有四个："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"result: 本次匹配的结果"),Object(t.b)("li",{parentName:"ol"},"$1,...$9: 正则表达式有多少个子表达式，就会传递几个参数"),Object(t.b)("li",{parentName:"ol"},"offset: 本次匹配的开始位置"),Object(t.b)("li",{parentName:"ol"},"source: 接受匹配的原始字符串")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"var str1 = '2018-11-12'\nvar reg2 = /(\\d)(\\d)/g\nvar new_str2 = str1.replace(reg2, (...args)=> {\n    console.log(args)\n})\n\n// 结果\n[ '20', '2', '0', 0, '2018-11-12' ]\n[ '18', '1', '8', 2, '2018-11-12' ]\n[ '11', '1', '1', 5, '2018-11-12' ]\n[ '12', '1', '2', 8, '2018-11-12' ]\n")),Object(t.b)("p",null,"replace第二个参数还有一些符号有特殊含义，比如: $1 - $99，$& 表示整个匹配字符串，$`是匹配字符串左侧文本，$'是右侧文本。$$是直接量符号。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"reg.test(str)  匹配则返回true，否则返回false"),Object(t.b)("li",{parentName:"ul"},"reg.exec(str)")),Object(t.b)("h2",{id:"实战"},"实战"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://ife.baidu.com/course/detail/id/30"}),"正则表达式之简易markdown文件解析器")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://ife.baidu.com/course/detail/id/29"}),"正则表达式之入门"))),Object(t.b)("h2",{id:"学习资料-1"},"学习资料"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",l({parentName:"li"},{href:"http://www.cppblog.com/vczh/archive/2008/05/22/50763.aspx"}),"《构造正则表达式引擎》和 《构造可配置词法分析器》"))))}o.isMDXComponent=!0},245:function(e,n,a){"use strict";a.d(n,"a",function(){return c}),a.d(n,"b",function(){return j});var t=a(0),l=a.n(t),b=l.a.createContext({}),r=function(e){var n=l.a.useContext(b),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},c=function(e){var n=r(e.components);return l.a.createElement(b.Provider,{value:n},e.children)},p="mdxType",i={inlineCode:"code",wrapper:function(e){return l.a.createElement(l.a.Fragment,{},e.children)}},o=function(e){var n=e.components,a=e.mdxType,t=e.originalType,b=e.parentName,c=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),p=r(n);return l.a.createElement(p[b+"."+a]||p[a]||i[a]||t,n?Object.assign({},c,{components:n}):c)};function j(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var b=a.length,r=new Array(b);r[0]=o;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=e,c[p]="string"==typeof e?e:t,r[1]=c;for(var j=2;j<b;j++)r[j]=a[j];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,a)}o.displayName="MDXCreateElement"}}]);