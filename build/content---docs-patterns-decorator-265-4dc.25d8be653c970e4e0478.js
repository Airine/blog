(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{229:function(e,n,t){"use strict";t.d(n,"a",function(){return o}),t.d(n,"b",function(){return i});var r=t(0),a=t.n(r),l=a.a.createContext({}),c=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=c(e.components);return a.a.createElement(l.Provider,{value:n},e.children)};var u="mdxType",b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},p=function(e){var n=e.components,t=e.mdxType,r=e.originalType,l=e.parentName,o=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),u=c(n),p=t,i=u[l+"."+p]||u[p]||b[p]||r;return n?a.a.createElement(i,Object.assign({},o,{components:n})):a.a.createElement(i,o)};function i(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,c=new Array(l);c[0]=p;var o={};for(var b in n)hasOwnProperty.call(n,b)&&(o[b]=n[b]);o.originalType=e,o[u]="string"==typeof e?e:r,c[1]=o;for(var i=2;i<l;i++)c[i]=t[i];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},97:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return c}),t.d(n,"rightToc",function(){return o}),t.d(n,"default",function(){return p});t(0);var r=t(229);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c={title:"javascript 装饰器模式",sidebar_label:"装饰器模式"},o=[],u={rightToc:o},b="wrapper";function p(e){var n=e.components,t=l(e,["components"]);return Object(r.b)(b,a({},u,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"装饰器模式是不改变原来的结构和功能，给对象添加新功能。"),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"./decorator/uml.png",alt:null}))),Object(r.b)("p",null,"下面是实现的代码："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"class A{\n    plus(){}\n}\n\nclass Decorator{\n    constructor(target){\n        this.target = target\n    }\n    plus(){this.target.plus()}\n    subtract(){}\n}\n\nclass Client{\n    constructor(a, decorator){\n        this.a = a\n        this.decorator = decorator\n    }\n}\n\nlet a = new A()\nlet d = new Decorator(a)\nd.plus()\nd.substract()\n\nlet c = new Client(a, decorator)\nc.a.plus()\nc.decorator.substract()\n")),Object(r.b)("p",null,"上面的代码可以看到，装饰器实际是对原来的对象进行了一层包装，它具有原来对象的方法，并且能新增一些方法。可以个人认为有些问题："),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"如果A里面有很多个方法。Decorator里岂不是都需要写一遍？可以使用克隆原型属性的方法解决。"),Object(r.b)("li",{parentName:"ol"},"如何给A添加新的属性呢？可以在装饰器里定义一个方法给target设置新属性解决。"),Object(r.b)("li",{parentName:"ol"},"为什么不使用继承呢？")),Object(r.b)("p",null,"《javascript设计模式与开发实践》里解释了为什么不使用继承。原因如下："),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"继承使父类和子类强耦合，父类改变后，子类实际也改变了。"),Object(r.b)("li",{parentName:"ol"},"父类对子类是可见的，也就是通过子类，知道父类的实现，这破坏了封装性。")),Object(r.b)("p",null,"上面的装饰器模式确实没有这2个问题。实际上上面的Decorator完全可以用一个函数来实现："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function decorator(target){\n    target.num = 13\n    target.prototype.substract = function(){}\n}\n")),Object(r.b)("p",null,"使用函数可以很方便的增加属性和方法，个人觉得这种用法要比上面用Decorator类更好些。"),Object(r.b)("p",null,"实际应用场景"),Object(r.b)("p",null,"AOP切面"),Object(r.b)("p",null,"装饰器的目的就是新增一些功能。比如需要在函数执行前后执行一些方法，可以写下面2个方法："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function before(fn, beforeFn) {\n    return function () {\n        beforeFn.apply(this, arguments)\n        return fn.apply(this, arguments)\n    }\n}\n\nfunction after(fn, afterFn) {\n    return function () {\n        let ret = fn.apply(this, arguments)\n        afterFn.apply(this, arguments)\n        return ret\n    }\n}\n")),Object(r.b)("p",null,"因为before方法里的fn,beforeFn都使用了arguments，所以可以在beforeFn里对arguments进行修改。"),Object(r.b)("p",null,"比如希望在点击按钮后上报一些数据："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function clickHandler(){}\nfunction log(){\n    // 上报数据\n}\nel.onclick = after(clickHandler, log)\n")),Object(r.b)("p",null,"或者在当前项目请求数据需要添加token，但是其它项目不需要。为了不修改基础的ajax方法。我们可以像下面这样："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function ajax(options){}\najax = ajax.before(function(options){\n    options.params.token = 'xxx'\n})\n")),Object(r.b)("p",null,"表单提交时验证也可以用过装饰器模式来实现。通过我们表单校验的代码如下："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function submit(){\n    if(!validate()) return \n    // 验证通过...\n}\n")),Object(r.b)("p",null,"但是如果我们不想将表单提交的submit()方法和表单校验validate()方法混合在一起。可以使用下面的方法："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function submit() {\n    console.log('submit')\n}\n\nfunction validate(params) {\n    console.log('validate')\n    if (params) return\n}\n\nfunction before(fn, beforeFn) {\n    return function () {\n        if (beforeFn.apply(this, arguments) === false) return\n        return fn.apply(this, arguments)\n    }\n}\n\nsubmit = before(submit, validate)\nsubmit(false))\n")),Object(r.b)("p",null,"总结"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"装饰器模式最好使用函数来实现，在这个函数里直接对对象进行处理。"),Object(r.b)("li",{parentName:"ul"},"有时候我们不想让一个对象太复杂，这时可以使用装饰器模式动态来添加方法。"),Object(r.b)("li",{parentName:"ul"},"如果嵌套多个装饰器，函数作用域会很长，性能会有影响。")),Object(r.b)("p",null,"装饰器模式和代理模式"),Object(r.b)("p",null,"装饰器模式和代理模式都使用了另一个对象进行操作。它们的区别是设计目的。装饰器模式是增加功能，是一开始不能确定对象的全部功能，可以形成很长的装饰链。而代理模式是做一些拦截，提供访问权限，只有一级。"),Object(r.b)("p",null,"es7装饰器"),Object(r.b)("p",null,"es7已经有了装饰器，生产中使用需要安装插件",Object(r.b)("inlineCode",{parentName:"p"},"babel-plugin-transform-decorators-legacy"),"。"),Object(r.b)("p",null,"core-decorators"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/jayphelps/core-decorators"}),"core-decorators"))))}p.isMDXComponent=!0}}]);