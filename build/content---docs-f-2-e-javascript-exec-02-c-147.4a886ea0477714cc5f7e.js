(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{195:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return c}),t.d(n,"rightToc",function(){return b}),t.d(n,"default",function(){return p});t(0);var l=t(283);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}function a(e,n){if(null==e)return{};var t,l,r=function(e,n){if(null==e)return{};var t,l,r={},a=Object.keys(e);for(l=0;l<a.length;l++)t=a[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(l=0;l<a.length;l++)t=a[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c={title:"JavaScript 执行机制",sidebar_label:"执行机制"},b=[{value:"宏任务和微任务",id:"宏任务和微任务",children:[{value:"简介",id:"简介",children:[]},{value:"为什么有微任务",id:"为什么有微任务",children:[]},{value:"执行过程",id:"执行过程",children:[]}]},{value:"执行上下文",id:"执行上下文",children:[]},{value:"闭包",id:"闭包",children:[]},{value:"函数",id:"函数",children:[{value:"函数种类",id:"函数种类",children:[]},{value:"this",id:"this",children:[]},{value:"操作 this 的内置函数",id:"操作-this-的内置函数",children:[]},{value:"总结 this",id:"总结-this",children:[]}]},{value:"语句执行",id:"语句执行",children:[{value:"普通语句",id:"普通语句",children:[]},{value:"语句块",id:"语句块",children:[]},{value:"控制型语句",id:"控制型语句",children:[]},{value:"带标签语句",id:"带标签语句",children:[]}]},{value:"参考资料",id:"参考资料",children:[]}],i={rightToc:b},o="wrapper";function p(e){var n=e.components,t=a(e,["components"]);return Object(l.b)(o,r({},i,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"宏任务和微任务"},"宏任务和微任务"),Object(l.b)("h3",{id:"简介"},"简介"),Object(l.b)("p",null,"JavaScript 的执行过程是："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"宿主(浏览器或node)将 JS 代码交给 JS 引擎，让它执行。"),Object(l.b)("li",{parentName:"ol"},"JS 引擎执行时，遇到如 setTimeout 之类的浏览器 API，会通知浏览器执行定时任务。然后 JS 引擎继续执行代码。"),Object(l.b)("li",{parentName:"ol"},"浏览器定时到了之后，再通知 JS 引擎，JS 引擎开始执行定时器中的函数。"),Object(l.b)("li",{parentName:"ol"},"ES6 引入了 Promise 后，JS 引擎会自己发起任务，不需要再让浏览器安排。")),Object(l.b)("p",null,"宿主发起的任务叫做宏任务，JS 引擎自己发起的任务叫做微任务(microtask)。"),Object(l.b)("p",null,"其中宏任务和微任务分别有："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"宏任务 macro-task(task)：Event、setTimeout、setInterval、setImmediate(ie)、I/O、UI rendering、MessageChannel。"),Object(l.b)("li",{parentName:"ul"},"微任务 micro-task(jobs)：process.nextTick、Promise、MutationObserver、Object.observer(已废弃)。")),Object(l.b)("h3",{id:"为什么有微任务"},"为什么有微任务"),Object(l.b)("p",null,"其实宏任务对于我们开发就够了，为什么还要有微任务呢？"),Object(l.b)("p",null,"根据 HTML 标准，在每个宏任务运行完以后，UI 都会重新渲染，那么在微中就完成数据更新，因此当前宏任务结束就可以得到最新的 UI了。反之，如果新建一个宏任务来做数据更新的话，那么渲染会执行两次。查看",Object(l.b)("a",r({parentName:"p"},{href:"https://www.zhihu.com/question/55364497/answer/144215284"}),"更多"),"。"),Object(l.b)("p",null,"那么宏任务和微任务有哪些呢？"),Object(l.b)("h3",{id:"执行过程"},"执行过程"),Object(l.b)("p",null,"JS 引擎等待浏览器分配宏任务，在操作系统中，通常等待的行为都是一个事件循环。"),Object(l.b)("p",null,"底层的 C/C++ 代码简化如下："),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{}),"while(TRUE){\n    r = wait();\n    execute(r);\n}\n")),Object(l.b)("p",null,"整个循环就是反复等待-执行的过程。等待就是等宿主发起的宏任务。这里每次执行的过程，就是一个宏任务，可以这样理解：宏任务队列就是事件循环。"),Object(l.b)("p",null,"而微任务是在宏任务里面的，在宏任务中，JS 的 Promise 也会产生异步代码，JS 必须保证这些异步代码在一个宏任务中执行，所以每个宏任务中又包含一个微任务队列。如下图所示。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"/img/js/eventloop-1.jpg",alt:null}))),Object(l.b)("p",null,"接下来，来看一个例子理解:"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),'var r = new Promise(function(resolve, reject){\n    console.log("a");\n    resolve()\n});\nsetTimeout(()=>console.log("d"), 0)\nr.then(() => console.log("c"));\nconsole.log("b")\n')),Object(l.b)("p",null,"上面代码，执行流程如下："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"浏览器将代码交给 JS 引擎，执行任务。这是一个宏任务。var r = new Promise() 会立即执行(注意 Promise 的 then 才是异步的)，打印输出 a。"),Object(l.b)("li",{parentName:"ol"},"执行过程中，遇到 setTimeout，让浏览器去执行定时(即倒数秒)，定时到后，就是下一个宏任务。"),Object(l.b)("li",{parentName:"ol"},"执行到 then，这是一个 Promise 微任务。放到微任务队列里。"),Object(l.b)("li",{parentName:"ol"},'执行 console.log("b")，输出 b。'),Object(l.b)("li",{parentName:"ol"},"执行宏任务里的微任务，即第 3 步的任务，打印出 c。"),Object(l.b)("li",{parentName:"ol"},"执行下一个宏任务，即第 2 步的 setTimeout 任务，打印出 d。")),Object(l.b)("p",null,"最终结果为: a、b、c、d。画个图如下："),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"/img/js/eventloop-2.jpg",alt:null}))),Object(l.b)("h2",{id:"执行上下文"},"执行上下文"),Object(l.b)("p",null,"JS 标准把一段代码，执行所需的所有信息定义为执行上下文。它包括："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"lexical environment: 词法环境，当获取变量或者 this 值时使用。"),Object(l.b)("li",{parentName:"ul"},"variable environment: 变量环境，当声明变量时使用。"),Object(l.b)("li",{parentName:"ul"},"code evaluation state: 用户恢复代码执行位置。"),Object(l.b)("li",{parentName:"ul"},"Function: 执行任务是函数时使用，表示正在被执行的函数。"),Object(l.b)("li",{parentName:"ul"},"ScriptOrModule: 执行任务是脚本或模块时使用，表示正在执行的代码。"),Object(l.b)("li",{parentName:"ul"},"Realm: 使用的基础库和内置对象实例。"),Object(l.b)("li",{parentName:"ul"},"Generator: 仅生成器上下文有这个属性，表示当前生成器。")),Object(l.b)("h2",{id:"闭包"},"闭包"),Object(l.b)("p",null,"闭包就是处于执行环境中的函数。它包含两部分："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"环境部分",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"环境：函数的词法环境(执行上下文的一部分)"),Object(l.b)("li",{parentName:"ul"},"标识符列表：函数中用到的未声明的变量"))),Object(l.b)("li",{parentName:"ul"},"表达式部分: 函数体")),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{}),"function A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n")),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"面试题，循环中使用闭包解决 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," 定义函数的问题")),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n")),Object(l.b)("p",null,"上面代码中，setTimeout 的函数 timer 会在 for 循环执行完后再执行。这时 i 已经是 6 了。所以全部输出 6。"),Object(l.b)("p",null,"解决方法有：\n1. 使用 let (推荐)\n2. 使用闭包"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n    (function (i){\n        setTimeout(function timer() {\n            console.log(i)\n        }, i * 1000)\n    })(i);\n}\n")),Object(l.b)("ol",{start:3},Object(l.b)("li",{parentName:"ol"},"使用 setTimeout 的第三个参数，它会当作 timer 函数的参数传入。")),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n    setTimeout(function timer(i) {\n        console.log(i)\n    }, i * 1000, i)\n}\n")),Object(l.b)("h2",{id:"函数"},"函数"),Object(l.b)("h3",{id:"函数种类"},"函数种类"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"普通函数"),Object(l.b)("li",{parentName:"ul"},"箭头函数"),Object(l.b)("li",{parentName:"ul"},"方法，class 中定义的函数"),Object(l.b)("li",{parentName:"ul"},"生成器函数 function *"),Object(l.b)("li",{parentName:"ul"},"类，class 也是函数"),Object(l.b)("li",{parentName:"ul"},"异步函数：async + 普通函数/箭头函数/生成器函数")),Object(l.b)("h3",{id:"this"},"this"),Object(l.b)("p",null,"this 是 JavaScript 的一个关键字，它的使用方法类似一个变量。"),Object(l.b)("p",null,"一句话总结 this：调用函数时使用的引用，决定了函数执行时的 this 值。"),Object(l.b)("p",null,"JavaScript 用一个栈来管理执行上下文，这个栈的每一项又包含一个链表，指向上层的执行上下文。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"/img/js/exec-this.jpg",alt:null}))),Object(l.b)("p",null,"JavaScript 标准中规定了，函数有个私有属性",Object(l.b)("inlineCode",{parentName:"p"},"[[Environment]]"),"，用来保存定义时上下文。"),Object(l.b)("p",null,"当函数运行时，会创建一条新的执行环境记录，记录的外层词法环境(outer lexical environment)会被设置为函数的",Object(l.b)("inlineCode",{parentName:"p"},"[[Environment]]"),"，这个动作就是切换上下文。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = 1;\nfoo();\n\n在别处定义了 foo：\n\nvar b = 2;\nfunction foo(){\n    console.log(b); // 2\n    console.log(a); // error\n}\n")),Object(l.b)("p",null,"函数执行时能访问定义时的上下文，但是不能访问执行时上下文。"),Object(l.b)("p",null,"JavaScript 标准定义了",Object(l.b)("inlineCode",{parentName:"p"},"[[thisMode]]"),"私有属性，它有三个取值："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"lexical: 表示上下文中找 this，这对应箭头函数。"),Object(l.b)("li",{parentName:"ul"},"global: 表示当 this 为 undefined 时，取全局对象，这对应普通函数。"),Object(l.b)("li",{parentName:"ul"},"strict: 表示严格模式下，this 严格按照调用时传入的值，可能时 null 或 undefined。对应严格模式和 class。")),Object(l.b)("p",null,"函数创建新的执行上下文的词法环境记录时，会根据",Object(l.b)("inlineCode",{parentName:"p"},"[[thisMode]]"),"来标记新记录的",Object(l.b)("inlineCode",{parentName:"p"},"[[ThisBindingStatus]]"),"私有属性，代码执行遇到 this 时，会逐层检查当前词法环境记录中的",Object(l.b)("inlineCode",{parentName:"p"},"[[ThisBindingStatus]]"),"，当找到有 this 的环境记录时获取 this 的值。"),Object(l.b)("p",null,"箭头函数执行时，它的",Object(l.b)("inlineCode",{parentName:"p"},"[[thisMode]]"),"是lexical，",Object(l.b)("inlineCode",{parentName:"p"},"[[ThisBindingStatus]]"),"标记为lexical。遇到 this 时，就会到上下文中找 this。"),Object(l.b)("h3",{id:"操作-this-的内置函数"},"操作 this 的内置函数"),Object(l.b)("p",null,"call、apply 及 bind 可以用来修改 this 指向。它们用于箭头函数、class 也不会报错，只是无法修改 this，而只能传参。"),Object(l.b)("p",null,"下面来看看 call、apply 及 bind 函数内部实现。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),"Function.prototype.call = Function.prototype.call || function (context) {\n    if (typeof this !== 'function') {\n        throw new TypeError(`Error`)\n    }\n    // 如果 context 是基本类型，需要是对象才能挂载 .fn 属性\n    context = typeof context === 'object' ? context || window : Object.create(null)\n    // 下面最好用 Symbol，因为如果原对象可能有fn属性，这样会被覆盖掉\n    context.fn = this\n    var args = [...arguments].slice(1)\n    // 谁调用，this 就是谁\n    var result = context.fn(...args)\n    delete context.fn\n    return result\n}\n\nFunction.prototype.apply = Function.prototype.apply || function(context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  context = typeof context === 'object' ? context || window : Object.create(null)\n  context.fn = this\n  let result\n  // 处理参数和 call 有区别\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n  delete context.fn\n  return result\n}\n\nFunction.prototype.bind = Function.prototype.bind || function (context) {\n    if (typeof this !== 'function') {\n        throw new TypeError('Error')\n    }\n    const args = [...arguments].slice(1)\n    context = typeof context === 'object' ? context || window : Object.create(null)\n    context.fn = this\n    return function () {\n        if (new.target) {\n            return new context.fn(...args, ...arguments)\n        }\n        return context.fn(...args, ...arguments)\n    }\n}\n")),Object(l.b)("p",null,"要注意 myBind 返回一个函数，可以通过普通方式和 new 调用。"),Object(l.b)("p",null,"call 的性能要比 apply 好，具体可以看",Object(l.b)("a",r({parentName:"p"},{href:"https://github.com/noneven/__/issues/6"}),"call和apply的性能对比"),"。"),Object(l.b)("h3",{id:"总结-this"},"总结 this"),Object(l.b)("p",null,"this 指向总结："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"new 调用，指向新创建的对象。"),Object(l.b)("li",{parentName:"ol"},"call、apply、bind 绑定到指定对象。"),Object(l.b)("li",{parentName:"ol"},"上下文对象调用，绑定到上下文对象。"),Object(l.b)("li",{parentName:"ol"},"默认，严格模式下绑定到 undefined，否则绑定到全局对象。"),Object(l.b)("li",{parentName:"ol"},"箭头函数没有 this，会往上找。")),Object(l.b)("h2",{id:"语句执行"},"语句执行"),Object(l.b)("p",null,"JavaScript 语句时，涉及到 Completion Record 类型，它标示着语句执行的完成状态。"),Object(l.b)("p",null,"Completion Record 表示一个语句执行完之后的结果，它有三个字段："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"[[type]]"),": 表示完成的类型，有 break、continue、return、throw、normal 几种类型。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"[[value]]"),": 表示语句的返回值，如果没有，则是 empty。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"[[target]]"),": 表示语句的目标，通常是一个 JavaScript 标签。")),Object(l.b)("p",null,"语句的分类"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"/img/js/exec-statement.jpg",alt:null}))),Object(l.b)("h3",{id:"普通语句"},"普通语句"),Object(l.b)("p",null,"普通语句执行完成后，会得到",Object(l.b)("inlineCode",{parentName:"p"},"[[type]]: normal"),"的 Completion Record。JS 引擎会继续执行下一条语句。"),Object(l.b)("p",null,"这些语句中，只有表达式语句会产生",Object(l.b)("inlineCode",{parentName:"p"},"[[value]]"),"，Chrome控制台显示的就是 Completion Record 的",Object(l.b)("inlineCode",{parentName:"p"},"[[value]]"),"。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"/img/js/exec-completion-record.jpg",alt:null}))),Object(l.b)("p",null,"上面显示，声明语句的 Completion Record 的",Object(l.b)("inlineCode",{parentName:"p"},"[[value]]"),"为 undefined，而表达式语句有值。"),Object(l.b)("h3",{id:"语句块"},"语句块"),Object(l.b)("p",null,"如果 Completion Record 的",Object(l.b)("inlineCode",{parentName:"p"},"[[type]]"),"不是 normal，会打断语句块中后续语句执行。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{}),"{\n  console.log(1)\n  return \n  console.log(2)  // 不执行\n}\n")),Object(l.b)("h3",{id:"控制型语句"},"控制型语句"),Object(l.b)("p",null,"控制型语句分为："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"对内造成影响：if switch while/for try"),Object(l.b)("li",{parentName:"ul"},"对外造成影响：break continue return throw")),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"/img/js/exec-control.jpg",alt:null}))),Object(l.b)("p",null,"上面穿透后，会向上找消费者。"),Object(l.b)("p",null,"所以 try...catch...finally 语句。try 里的 return 完成后，还是会走 finally，而且 finally 里的 return 能覆盖 try 里的 return。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{className:"language-js"}),"try{\n  return 1\n}\ncatch(e){}\nfinally{\n  return 2   // 最终返回 2\n}\n")),Object(l.b)("h3",{id:"带标签语句"},"带标签语句"),Object(l.b)("p",null,"任何语句前面都可以加标签",Object(l.b)("inlineCode",{parentName:"p"},"xx:"),"。主要作用是跳出多层循环。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{}),'outer: while(true) {\n  inner: while(true) {\n      break outer;\n  }\n}\nconsole.log("finished")\n')),Object(l.b)("p",null,"break/continue 语句后面跟了关键字，会产生带 target 的 Completion Record。"),Object(l.b)("h2",{id:"参考资料"},"参考资料"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"重学前端")))}p.isMDXComponent=!0},283:function(e,n,t){"use strict";t.d(n,"a",function(){return b}),t.d(n,"b",function(){return u});var l=t(0),r=t.n(l),a=r.a.createContext({}),c=function(e){var n=r.a.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},b=function(e){var n=c(e.components);return r.a.createElement(a.Provider,{value:n},e.children)};var i="mdxType",o={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},p=function(e){var n=e.components,t=e.mdxType,l=e.originalType,a=e.parentName,b=function(e,n){var t={};for(var l in e)Object.prototype.hasOwnProperty.call(e,l)&&-1===n.indexOf(l)&&(t[l]=e[l]);return t}(e,["components","mdxType","originalType","parentName"]),i=c(n),p=t,u=i[a+"."+p]||i[p]||o[p]||l;return n?r.a.createElement(u,Object.assign({},b,{components:n})):r.a.createElement(u,b)};function u(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var a=t.length,c=new Array(a);c[0]=p;var b={};for(var o in n)hasOwnProperty.call(n,o)&&(b[o]=n[o]);b.originalType=e,b[i]="string"==typeof e?e:l,c[1]=b;for(var u=2;u<a;u++)c[u]=t[u];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);