(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{151:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return l}),a.d(n,"rightToc",function(){return i}),a.d(n,"default",function(){return u});a(0);var t=a(229);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function c(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},c=Object.keys(e);for(t=0;t<c.length;t++)a=c[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(t=0;t<c.length;t++)a=c[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l={title:"javascript 语法",sidebar_label:"语法"},i=[{value:"var、let 和 const",id:"var、let-和-const",children:[{value:"提升",id:"提升",children:[]},{value:"重复声明",id:"重复声明",children:[]},{value:"暂时性死区",id:"暂时性死区",children:[]},{value:"区别",id:"区别",children:[]}]}],o={rightToc:i},b="wrapper";function u(e){var n=e.components,a=c(e,["components"]);return Object(t.b)(b,r({},o,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"var、let-和-const"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#var、let-和-const"}),"#"),"var、let 和 const"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"提升"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#提升"}),"#"),"提升"),Object(t.b)("p",null,"提升是指使用 var 声明的变量、function 声明定义的函数会提升到作用域前面。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"a()\nfunction a(){}\n\nconsole.log(b)  // undefined\nvar b = 3\n")),Object(t.b)("p",null,"上面的代码，a 在",Object(t.b)("inlineCode",{parentName:"p"},"function a()"),"之前使用，b 在",Object(t.b)("inlineCode",{parentName:"p"},"var b"),"之前使用，并没有报错。这就是提升，实际相当于:"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = function(){}\na()\n\nvar b \nconsole.log(b)  // undefined\nb = 3\n")),Object(t.b)("p",null,"可以看到，函数 a 的声明和定义都提前了，var 声明的变量 b 的声明提前了，赋值并没有提前，所以输出 b 为 undefind。"),Object(t.b)("p",null,"提升存在的根本原因就是为了解决函数间互相调用的情况"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"function test1() {\n    test2()\n}\nfunction test2() {\n    test1()\n}\ntest1()\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"重复声明"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#重复声明"}),"#"),"重复声明"),Object(t.b)("p",null,"重复 var 声明同一个变量，只有第一次声明有效。后面的定义会覆盖前面的值。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"// --- example 1\nvar a = 1\nvar a = 3\n// 相当于\nvar a \na = 1\na = 3\n\n// --- example 2\nconsole.log(a) // ƒ a() {}\nvar a = 1\nfunction a() {}\n")),Object(t.b)("p",null,"上面 example 2 可以看到，函数的声明定义要优先于变量 var 的声明。因为 function a 后，var a 并没有生效。"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"暂时性死区"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#暂时性死区"}),"#"),"暂时性死区"),Object(t.b)("p",null,"var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"function test(){\n  console.log(a)\n  let a\n}\ntest()  // Uncaught ReferenceError: a is not defined\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"区别"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#区别"}),"#"),"区别"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部"),Object(t.b)("li",{parentName:"ul"},"var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用"),Object(t.b)("li",{parentName:"ul"},"var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会"),Object(t.b)("li",{parentName:"ul"},"let 和 const 作用基本一致，但是后者声明的变量不能再次赋值")))}u.isMDXComponent=!0},229:function(e,n,a){"use strict";a.d(n,"a",function(){return i}),a.d(n,"b",function(){return s});var t=a(0),r=a.n(t),c=r.a.createContext({}),l=function(e){var n=r.a.useContext(c),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},i=function(e){var n=l(e.components);return r.a.createElement(c.Provider,{value:n},e.children)};var o="mdxType",b={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=function(e){var n=e.components,a=e.mdxType,t=e.originalType,c=e.parentName,i=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),o=l(n),u=a,s=o[c+"."+u]||o[u]||b[u]||t;return n?r.a.createElement(s,Object.assign({},i,{components:n})):r.a.createElement(s,i)};function s(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var c=a.length,l=new Array(c);l[0]=u;var i={};for(var b in n)hasOwnProperty.call(n,b)&&(i[b]=n[b]);i.originalType=e,i[o]="string"==typeof e?e:t,l[1]=i;for(var s=2;s<c;s++)l[s]=a[s];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);