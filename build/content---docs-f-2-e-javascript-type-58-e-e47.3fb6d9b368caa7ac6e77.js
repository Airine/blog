(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{168:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return r}),t.d(n,"rightToc",function(){return c}),t.d(n,"default",function(){return o});t(0);var b=t(249);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var b in t)Object.prototype.hasOwnProperty.call(t,b)&&(e[b]=t[b])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,b,a=function(e,n){if(null==e)return{};var t,b,a={},l=Object.keys(e);for(b=0;b<l.length;b++)t=l[b],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(b=0;b<l.length;b++)t=l[b],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var r={id:"type",title:"javascript 数据类型",sidebar_label:"数据类型"},c=[{value:"简介",id:"简介",children:[]},{value:"Undefined、Null",id:"undefined、null",children:[]},{value:"Boolean",id:"boolean",children:[]},{value:"String",id:"string",children:[]},{value:"Number",id:"number",children:[{value:"浮点数的二进制表示",id:"浮点数的二进制表示",children:[]},{value:"补码和真值",id:"补码和真值",children:[]},{value:"IEEE 754 标准",id:"ieee-754-标准",children:[]},{value:"浮点运算",id:"浮点运算",children:[]},{value:"浮点精度问题的解决办法",id:"浮点精度问题的解决办法",children:[]},{value:"为什么0.1+0.2!=0.3",id:"为什么010203",children:[]},{value:"Number、parseInt、parseFloat",id:"number、parseint、parsefloat",children:[]}]},{value:"Symbol",id:"symbol",children:[]},{value:"Object",id:"object",children:[{value:"普通对象",id:"普通对象",children:[]},{value:"Set、Map、WeakSet 和 WeakMap",id:"set、map、weakset-和-weakmap",children:[]}]},{value:"类型判断",id:"类型判断",children:[{value:"typeof()",id:"typeof",children:[]},{value:"instanceof",id:"instanceof",children:[]},{value:"Object.prototype.toString()",id:"objectprototypetostring",children:[]}]},{value:"类型转换",id:"类型转换",children:[{value:"toBoolean",id:"toboolean",children:[]},{value:"StringToNumber",id:"stringtonumber",children:[]},{value:"NumberToString",id:"numbertostring",children:[]},{value:"运算符",id:"运算符",children:[]},{value:"==和===",id:"和",children:[]},{value:"装箱转换",id:"装箱转换",children:[]},{value:"拆箱转换",id:"拆箱转换",children:[]}]},{value:"函数",id:"函数",children:[]},{value:"参考资料",id:"参考资料",children:[]}],i={rightToc:c},p="wrapper";function o(e){var n=e.components,t=l(e,["components"]);return Object(b.b)(p,a({},i,t,{components:n,mdxType:"MDXLayout"}),Object(b.b)("h2",{id:"简介"},"简介"),Object(b.b)("p",null,"Javascript 语义规定了 7 种数据类型："),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"Undefined"),Object(b.b)("li",{parentName:"ul"},"Null"),Object(b.b)("li",{parentName:"ul"},"Boolean"),Object(b.b)("li",{parentName:"ul"},"String"),Object(b.b)("li",{parentName:"ul"},"Number"),Object(b.b)("li",{parentName:"ul"},"Symbol"),Object(b.b)("li",{parentName:"ul"},"Object")),Object(b.b)("p",null,"前6个也叫做原始(Primitive)类型或基本类型。"),Object(b.b)("h2",{id:"undefined、null"},"Undefined、Null"),Object(b.b)("p",null,"Undefined 表示未定义，在变量赋值之前，它是 Undefined 类型，值为 undefined。但是 javascript 中 undefined 是一个变量，而不是关键字。所以可能被修改。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"function a() {\n    var undefined = 12\n    console.log(undefined)  \n}\na()\n\nvar undefined = 12\nconsole.log(undefined) \n")),Object(b.b)("p",null,"上面的代码，在 Chrome/75.0.3770.80 下输出 ",Object(b.b)("inlineCode",{parentName:"p"},"12"),"、",Object(b.b)("inlineCode",{parentName:"p"},"undefined"),"。在 node v12.3.1 下输出",Object(b.b)("inlineCode",{parentName:"p"},"12"),"、",Object(b.b)("inlineCode",{parentName:"p"},"12"),"。可以看出，undefined 是有可能被修改的。所以可以使用",Object(b.b)("inlineCode",{parentName:"p"},"void 0"),"来代替 ",Object(b.b)("inlineCode",{parentName:"p"},"undefined"),"。"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"void"),"操作符会执行表达式，并返回 ",Object(b.b)("inlineCode",{parentName:"p"},"undefined"),"。它通常用来获取原始的 undefined，或阻止 a 链接的点击。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"void (2 == '2'); // void (2 == '2'), returns undefined\n\nvoid 2 == '2';   // (void 2) == '2', returns false\n\n<a href=\"javascript:void(0);\">\n  当用户点击一个以 javascript: URI 时，它会执行URI中的代码,\n  然后用返回的值替换页面内容，除非返回的值是undefined\n  如果去掉 void()，点击之后整个页面会被替换成一个字符 0\n</a>\n")),Object(b.b)("p",null,"Null 表示定义了但是为空，它只有一个值 null。可以放心使用 null，因为它是一个关键字。"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"typeof null"),"会返回",Object(b.b)("inlineCode",{parentName:"p"},"object"),"，但是它并非对象，而是 JS 设计时的一个 Bug，JS 最初使用的是 32 位系统，为了性能考虑，使用地位存储变量的类型信息，",Object(b.b)("inlineCode",{parentName:"p"},"000"),"开头表示对象，然而",Object(b.b)("inlineCode",{parentName:"p"},"null"),"表示为全零，所以它被错误判断为",Object(b.b)("inlineCode",{parentName:"p"},"object"),"。虽然现在内部类型判断已经改变了，但是这个 Bug 一直都在。"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"面试题：原始类型有哪几种？null 是对象嘛？")),Object(b.b)("h2",{id:"boolean"},"Boolean"),Object(b.b)("p",null,"Boolean 类型有两个值，true 和 false。在转换时只有下面 6 个值为 false，其余都为 true。"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"布尔值",Object(b.b)("inlineCode",{parentName:"li"},"false")),Object(b.b)("li",{parentName:"ul"},"空字符串",Object(b.b)("inlineCode",{parentName:"li"},"'' 或 \"\"")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"0(包括+0、-0)")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"NaN")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"undefined")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"null"))),Object(b.b)("h2",{id:"string"},"String"),Object(b.b)("p",null,"Javascript 字符串是以 UTF16 编码的，字符串的最大长度是 2^53 - 1，它并不是字符数，而是受字符串编码长度影响。Javascript 字符串把每个 UTF16 单元当作一个字符来处理，所以非 BMP 字符(Unicode 码点超出 U+0000 - U+FFFF区间,即超出 0-65536)会当作两个 UTF16 单元。"),Object(b.b)("p",null,"这样的设计是为了性能和实现起来更加简单。因为现实中很少用到 BMP 之外的字符。"),Object(b.b)("h2",{id:"number"},"Number"),Object(b.b)("p",null,"JavaScript中的Number类型有 18437736874454810627 (即2^64-2^53+3) 个值。JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是JavaScript为了表达几个额外的语言场景(比如不让除以0出错，而引入了无穷大的概念)，规定了几个例外情况:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"NaN"),"，占用了 9007199254740990，这原本是符合 IEEE 规则的数字。"),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"Infinity")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"-Infinity"))),Object(b.b)("p",null,"注意，除法时，除以-0，会得到-Infinity。区分+0和-0的方式就是检测 1/x 是 Infinity 还是 -Infinity。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = -0\na.toString()  // 0\n\n1/a   // -Infinity\n")),Object(b.b)("p",null,"根据双精度浮点数的定义，Number类型中有效的整数范围是-0x1fffffffffffff至0x1fffffffffffff，所以Number 无法精确表示此范围外的整数。"),Object(b.b)("h3",{id:"浮点数的二进制表示"},"浮点数的二进制表示"),Object(b.b)("p",null,"浮点数分为整数部分和小数部分，十进制数转二进制时，要对整数和小数部分分别转换后，再合并。"),Object(b.b)("ol",null,Object(b.b)("li",{parentName:"ol"},'十进制整数转二进制：采用"除2取余，逆序排列"法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。如',Object(b.b)("inlineCode",{parentName:"li"},"78D = 1001110(B)"),"，D表示十进制，B表示二进制。")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"78/2=39  ==== 余0   ^\n39/2=19  ==== 余1   |\n19/2=9   ==== 余1   |\n9/2=4    ==== 余1   | 向上逆序\n4/2=2    ==== 余0   |\n2/2=1    ==== 余0   |\n1/2=0    ==== 余1   |\n\n(78).toString(2) // 1001110\n")),Object(b.b)("ol",{start:2},Object(b.b)("li",{parentName:"ol"},'十进制小数转二进制：采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。')),Object(b.b)("p",null,"举例来说，",Object(b.b)("inlineCode",{parentName:"p"},"0.5 = (0.1)B"),"。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"0.5 * 2 = 1.0  取出整数部分 1   \n\n(0.5).toString(2)  // 0.1\n")),Object(b.b)("p",null,"上面代码中，乘积的小数部分为0，所以即为",Object(b.b)("inlineCode",{parentName:"p"},"0.1"),"。"),Object(b.b)("p",null,"再来看看",Object(b.b)("inlineCode",{parentName:"p"},"0.1 = (0.0001100110011001100110011001100110011001100110011001101)B"),"。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),'0.1 * 2 = 0.2  取出整数部分 0\n0.2 * 2 = 0.4  取出整数部分 0\n0.4 * 2 = 0.8  取出整数部分 0\n0.8 * 2 = 1.6  取出整数部分 1\n0.6 * 2 = 1.2  取出整数部分 1\n0.2 * 2 = 0.4  取出整数部分 0\n0.4 * 2 = 0.8  取出整数部分 0\n0.8 * 2 = 1.6  取出整数部分 0\n...循环\n\n(0.1).toString(2) // "0.0001100110011001100110011001100110011001100110011001101"\n')),Object(b.b)("p",null,"上面代码中，0.1 转二进制后，出现无限循环的情况。按照精度，进行了截取。"),Object(b.b)("p",null,"按照上面的理论。",Object(b.b)("inlineCode",{parentName:"p"},"78.1"),"就是整数部分和小数部分拼接起来。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),'78.1.toString(2)  // "1001110.000110011001100110011001100110011001100110011"\n')),Object(b.b)("h3",{id:"补码和真值"},"补码和真值"),Object(b.b)("h3",{id:"ieee-754-标准"},"IEEE 754 标准"),Object(b.b)("p",null,"IEEE二进制浮点数算术标准（IEEE 754）是一套浮点数运算标准，被很多CPU和浮点运算器所采用。它定义了表示浮点数的格式(包括负零-0)与反常量，一些特殊值(无穷Inf)与非数值(NaN)，以及这些数值的浮点数运算符。它也指明了数值舍入规则与例外情况。"),Object(b.b)("p",null,"根据IEEE 754标准，任意一个二进制浮点数都可以表示为以下形式："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"V = Math.pow(-1, S) * M * Math.pow(2, E)\n")),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"S")," 表示浮点数的正负，0表示正，1表示负。"),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"M")," 表示有效位(尾数)。 尾数部分M通常都是规格化表示的，即非0的尾数其第一位总是1，而这一位也称隐藏位，因为存储时候这一位是会被省略的。比如保存",Object(b.b)("inlineCode",{parentName:"li"},"1.0011"),"时，只保存了",Object(b.b)("inlineCode",{parentName:"li"},"0011"),"，等读取时，再把第一位1加上。"),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"E")," 表示阶码，用移码表示，阶码的真值都被加上一个常数(偏移量)。")),Object(b.b)("p",null,"IEEE 754规定了四种表示浮点数值的方式："),Object(b.b)("p",null,"1、单精度(32位)"),Object(b.b)("p",null,"最高1位是符号位，后面8位是指数E，剩下23位是有效数字。"),Object(b.b)("p",null,"2、双精度(64位)"),Object(b.b)("p",null,"最高1位是符号位，后面11位是指数E，剩下52位是有效数字。JavaScript 的数字类型 Number，就是使用 IEEE 754 双精度浮点格式。"),Object(b.b)("p",null,"结合上面关于浮点数二进制表示的内容，来看看 JavaScript 中，0.1 和 0.2 是如何存储的。"),Object(b.b)("p",null,"0.1 是",Object(b.b)("inlineCode",{parentName:"p"},"0.000110011(0011 无限循环)"),"。规格化后为",Object(b.b)("inlineCode",{parentName:"p"},"1.100110011(0011 无限循环) * 2^-4"),"，根据0舍1入的规则，最后的值为 "),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"// 有效位前面的1为隐藏位，1.后面还要保留52位\n(-1)^0 * 1.1001100110011001100110011001100110011001100110011010 * 2^-4\n")),Object(b.b)("p",null,"指数",Object(b.b)("inlineCode",{parentName:"p"},"E = -4 + 1023 = 1019"),"(即1111111011)，所以 JavaScript 中 0.1 的二进制存储格式为："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"S符号位，1位 -  E指数, 11位 -      M有效位, 52位                          \n0             01111111011     1001100110011001100110011001100110011001100110011010\n")),Object(b.b)("p",null,"同理，0.2 是",Object(b.b)("inlineCode",{parentName:"p"},"0.0011(0011 无限循环)"),"，规格化后是",Object(b.b)("inlineCode",{parentName:"p"},"1.1001(1001 无限循环) * 2^-3"),"，根据0舍1入的规则，最后的值为："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"-1^0 * 1.1001100110011001100110011001100110011001100110011010 * 2^-3\n")),Object(b.b)("p",null,"指数",Object(b.b)("inlineCode",{parentName:"p"},"E = -3 + 1023 = 1020"),"(即0111111100)，所以 JavaScript 中 0.2 的二进制存储格式为："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"S符号位，1位 -  E指数, 11位 -      M有效位, 52位                          \n0             01111111100     1001100110011001100110011001100110011001100110011010\n")),Object(b.b)("p",null,"3、延伸单精度(43位以上，很少用)"),Object(b.b)("p",null,"4、延伸双精度(79位以上，通常以80位实现)"),Object(b.b)("h3",{id:"浮点运算"},"浮点运算"),Object(b.b)("p",null,"通过上面的知识，知道了 0.1 和 0.2 在计算机中的存储。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"// 使用逗号和分号分隔 S,E;M\n0.1 = 0,01111111011;1001100110011001100110011001100110011001100110011010\n0.2 = 0,01111111100;1001100110011001100110011001100110011001100110011010\n")),Object(b.b)("p",null,"浮点数的加减运算，步骤如下："),Object(b.b)("ol",null,Object(b.b)("li",{parentName:"ol"},"对阶，是指将两个进行运算的浮点数的阶码对齐的操作。目的是为使两个浮点数的尾数能够进行加减运算。")),Object(b.b)("p",null,"对阶的具体操作是：首先求出两浮点数阶码的差，即",Object(b.b)("inlineCode",{parentName:"p"},"⊿E=Ex-Ey"),"。将小阶码加上",Object(b.b)("inlineCode",{parentName:"p"},"⊿E"),"，使之与大阶码相等，同时将小阶码对应的浮点数的尾数右移相应位数，以保证该浮点数的值不变。注意小阶对大阶，损失精度小。"),Object(b.b)("p",null,"按照规则，阶码的差计算如下："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"0.1 的阶码  01111111011   1019\n0.2 的阶码  01111111100   1020\n-----------------------------\n差                         -1\n")),Object(b.b)("p",null,"所以，要将 0.1 的尾数右移1位，尾数补的是1，是因为隐藏位的数值为1（默认是不存储的，只有读取的时候才加上）。即"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"0.1 = 0,01111111100;1100110011001100110011001100110011001100110011001101\n")),Object(b.b)("ol",{start:2},Object(b.b)("li",{parentName:"ol"},"尾数求和")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"0.1     =  0.1100110011001100110011001100110011001100110011001101 \n0.2     =  1.1001100110011001100110011001100110011001100110011010\n=================================================================\n0.1+0.2 = 10.0110011001100110011001100110011001100110011001100111\n")),Object(b.b)("ol",{start:3},Object(b.b)("li",{parentName:"ol"},"规格化，对步骤2的结果，需要右规(即尾数右移1位，阶码加1)。")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"0,01111111101;1.0011001100110011001100110011001100110011001100110011\n")),Object(b.b)("p",null,"右规操作，可能会导致低位丢失，引起误差，造成精度问题。所以就需要步骤4的舍入操作。"),Object(b.b)("ol",{start:4},Object(b.b)("li",{parentName:"ol"},"舍入(0舍1入)。")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"0,01111111101;1.0011001100110011001100110011001100110011001100110100\n")),Object(b.b)("ol",{start:5},Object(b.b)("li",{parentName:"ol"},"溢出判断")),Object(b.b)("p",null,"根据阶码判断浮点运算是否溢出，而阶码 01111111101 既不上溢，也不下溢。"),Object(b.b)("p",null,"到此，0.1 + 0.2 的运算就结束了，下面来看看计算的结果，转成十进制是多少。"),Object(b.b)("ol",{start:6},Object(b.b)("li",{parentName:"ol"},"首先将它非规格化，得到二进制 ")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"0.010011001100110011001100110011001100110011001100110100 \n")),Object(b.b)("ol",{start:7},Object(b.b)("li",{parentName:"ol"},"再转成十进制")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"1*2^-2 + 1*2^-5 + 1*2^-6 + ... + 1*2^52 = 0.30000000000000004440892098500626\n")),Object(b.b)("p",null,"现在就知道",Object(b.b)("inlineCode",{parentName:"p"},"0.1+0.2 = 0.30000000000000004"),"是怎么来的了。"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"计算机运算为何要使用补码？")),Object(b.b)("p",null,"可以简化计算机的运算步骤，且只用设加法器，如做减法时若能找到与负数等价的正数来代替该负数，就可以把减法操作用加法代替。而采用补码，就能达到这个效果。"),Object(b.b)("h3",{id:"浮点精度问题的解决办法"},"浮点精度问题的解决办法"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"调用round() 方法四舍五入或者toFixed() 方法保留指定的位数（对精度要求不高，可用这种方法） "),Object(b.b)("li",{parentName:"ul"},"将小数转为整数再做计算，即前文提到的那个简单的解决方案 "),Object(b.b)("li",{parentName:"ul"},"使用特殊的进制数据类型，如前文提到的bignumber（对精度要求很高，可借助这些相关的类库）")),Object(b.b)("h3",{id:"为什么010203"},"为什么0.1+0.2!=0.3"),Object(b.b)("p",null,"同样根据浮点数的定义，非整数的Number类型无法用 ==(===也不行) 来比较，这也正是为什么在JavaScript中，0.1+0.2!=0.3，正确的比较方法是:"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON   // true\n")),Object(b.b)("p",null,"检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。"),Object(b.b)("h3",{id:"number、parseint、parsefloat"},"Number、parseInt、parseFloat"),Object(b.b)("p",null,"Number() 可以将字符串转换成数字。如果参数无法被转换为数字，则返回 NaN。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),'// 转换日期\nnew Date("December 17, 1995 03:24:00").getTime() //819141840000\nnew Date("December 17, 1995 03:24:00").valueOf() //819141840000\nNumber(new Date("December 17, 1995 03:24:00"))  //819141840000\n\nNumber(\'.1\') // 0.1\nNumber(\'hello\') // NaN\n')),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"parseInt(string, radix)"),"用于将字符串以 radix 进制转为 10 进制，radix 介于 2-36 之间，未指定时默认为 10。如果参数不是字符串，将其转为字符串。它遇到非数值字符就终止。如果第一个字符就是非数值，则返回 NaN。"),Object(b.b)("p",null,"当 radix 为 undefined、0 或 未指定情况时，如果："),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"字符串以 0x 或 0X 开头，则 radix 为 16。"),Object(b.b)("li",{parentName:"ul"},"字符串以 0 开头，radix 为 8 或 10，具体看浏览器实现。"),Object(b.b)("li",{parentName:"ul"},"字符串以其它值开头，radix 为 10。")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),'parseInt(\'123\', 5) // 将\'123\'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38\n\n// 下面例子都返回 15\nparseInt("0xF", 16);\nparseInt("F", 16);\nparseInt("17", 8);\nparseInt(021, 8);\nparseInt("015", 10);   // parseInt(015, 10); 返回 15\nparseInt(15.99, 10);\nparseInt("15,123", 10);\nparseInt("FXX123", 16);\nparseInt("1111", 2);\nparseInt("15 * 3", 10);\nparseInt("15e2", 10);\nparseInt("15px", 10);\nparseInt("12", 13);\n\n// 下面例子都返回NaN\nparseInt("Hello", 8); // 根本就不是数值\nparseInt("546", 2);   // 除了“0、1”外，其它数字都不是有效二进制数字\n\n// 下面例子返回4\nparseInt(4.7, 10);\nparseInt(4.7 * 1e22, 10); // Very large number becomes 4\nparseInt(0.00000000000434, 10); // Very small number becomes 4\n')),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"parseFloat()")," 将它的字符串参数解析成为浮点数并返回.如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略."),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"parseFloat('e')   // NaN\nparseFloat('1e3') // 1000\n")),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"['1', '2', '3']",".map(parseInt) what & why ?")),Object(b.b)("p",null,"相当于下面的代码："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"['1','2','3'].map((item, i)=>{\n    return parseInt(item, i)\n})\n// item i -> 结果\n// '1' 0  -> 1\n// '2' 1  -> radix 为 2-36之间，NaN\n// '3' 2  -> 2进制没有3， NaN\n// 最终输出 [1, NaN, NaN]\n")),Object(b.b)("h2",{id:"symbol"},"Symbol"),Object(b.b)("p",null,"Symbol 是具有字符串类型的描述，它是唯一的，即使描述相同，也不相等。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var s = Symbol('hello')\n")),Object(b.b)("p",null,"可以使用 Symbol.iterator 来自定义 for...of 在对象上的行为。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var o = {\n    name: 'zs',\n    age: 32,\n    [Symbol.iterator]: function () {\n        let i = 0\n        return {\n            next: function () {\n                return {\n                    value: i++,\n                    done: i > 3\n                }\n            }\n        }\n    }\n}\n\nfor (let i of o) {\n    console.log(i)   // 0 1 2\n}\n")),Object(b.b)("h2",{id:"object"},"Object"),Object(b.b)("h3",{id:"普通对象"},"普通对象"),Object(b.b)("p",null,"对象是属性的集合，属性分为数据属性和访问器属性，二者都是key-value结构，key 可以是字符串或 Symbol 类型。"),Object(b.b)("p",null,"javascript 中的类，实际是运行时对象的一个私有属性，而 javascript 是无法自定义类型的。"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？")),Object(b.b)("p",null,"原始类型存储的是值，赋值时，会复制值。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = 1\nvar b = a\nb // 1\n")),Object(b.b)("p",null,"上面 a 赋值给 b 时，会将值 1 复制给 b。"),Object(b.b)("p",null,"对象类型存储的是指针，当存储对象时，计算机会在内存中新开辟一个空间来存放值，对象类型存储的是这个空间地址。赋值时，是复制的地址。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = []\nvar b = a\na.push(1)\nb  // [1]\n")),Object(b.b)("p",null,"上面代码中，a 实际是一个空间地址，将 a 赋值给 b 时，是将空间地址给 b。所以使用 push 改变空间值后，b 也会变化。"),Object(b.b)("p",null,"函数传参是对象时，实际会将地址传递给局部参数变量。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"function test(person) {\n  person.age = 26\n  person = {\n    name: 'yyy',\n    age: 30\n  }\n\n  return person\n}\nconst p1 = {\n  name: 'yck',\n  age: 25\n}\nconst p2 = test(p1)\nconsole.log(p1) // -> { name: 'yck', age: 26 }\nconsole.log(p2) // -> { name: 'yyy', age: 30 }\n")),Object(b.b)("p",null,"上面代码将 p1 传递给 test 时，person 就是 p1 执行的空间，"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"为什么给对象添加的方法能用在基本类型上？")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},".")," 运算符提供了装箱操作，会根据基础类型创建一个临时对象，使得我们可以在基本类型上调用对象的方法。。Number、String、Boolean 使用 new 时，会产生对象。当直接调用时，表示强制转换类型。Symbol 使用 new 会报错，但是它仍然 Symbol 对象的是构造器。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var o = {\n    name: 'zs',\n    age: 32,\n    [Symbol.iterator]: function () {\n        let i = 0\n        return {\n            next: function () {\n                return {\n                    value: i++,\n                    done: i > 3\n                }\n            }\n        }\n    }\n}\n\nfor (let i of o) {\n    console.log(i)   // 0 1 2\n}\n")),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？")),Object(b.b)("h3",{id:"set、map、weakset-和-weakmap"},"Set、Map、WeakSet 和 WeakMap"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Set 和 WeakSet")),Object(b.b)("p",null,"Set 数据结构类似于数组，但是它的成员是唯一的，没有重复值。属性和方法如下："),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"add(value)")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"delete(value)")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"has(value)")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"clear()")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"keys()")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"values()")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"entries()")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("inlineCode",{parentName:"li"},"forEach()"))),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{}),"")),Object(b.b)("h2",{id:"类型判断"},"类型判断"),Object(b.b)("h3",{id:"typeof"},"typeof()"),Object(b.b)("p",null,"javascript 类型是很有争议的，typeof 和运行时类型有些不一致。typeof 设计有缺陷，但是错过了修正它的时机。"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",a({parentName:"tr"},{align:null}),"示例"),Object(b.b)("th",a({parentName:"tr"},{align:null}),"typeof 结果"),Object(b.b)("th",a({parentName:"tr"},{align:null}),"运行时类型行为"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"null"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"object"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Null")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"{}"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"object"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Object")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"(function(){})"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"function"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Object")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"3"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"number"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Number")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"'ok'"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"string"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"String")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"true"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"boolean"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Boolean")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"void"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"undefined"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Undefined")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",a({parentName:"tr"},{align:null}),"Symbol('a')"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"symbol"),Object(b.b)("td",a({parentName:"tr"},{align:null}),"Symbol")))),Object(b.b)("h3",{id:"instanceof"},"instanceof"),Object(b.b)("p",null,"instanceof 可以判断某个对象是否是类的实例。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"[] instanceof Array\n{} instanceof Object\n")),Object(b.b)("p",null,"对于基本类型，它是无法正确判断的。当然可以用下面方法："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"class PrimitiveString{\n    static [Symbol.hasInstance](x){\n        return typeof x === 'string'\n    }\n}\n\n'hello' instanceof Primitivestring  // true\n")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"Symbol.hasInstance"),"可以让我们自定义 instanceof 的行为。所以上面",Object(b.b)("inlineCode",{parentName:"p"},"'hello' instanceof Primitivestring"),"结果返回 true。这也可以看出 instanceof 不是十分可靠。"),Object(b.b)("p",null,"另外，如果页面里嵌套了 iframe，将无法使用 instanceof 判断跨文档的对象，比如",Object(b.b)("inlineCode",{parentName:"p"},"父页面中的数组 instanceof iframe的Array"),"将返回 false，因为父页面的 window.Array 和 iframe 里的 window.Array 不是同一个。"),Object(b.b)("h3",{id:"objectprototypetostring"},"Object.prototype.toString()"),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"Object.prototype.toString.call()"),"可以准确的判断数据的类型，在下面装箱转换详细说。"),Object(b.b)("h2",{id:"类型转换"},"类型转换"),Object(b.b)("p",null,"不要使用 == 进行判断，因为它的规则太复杂，属于设计失误，很多实践都进制使用它。"),Object(b.b)("p",null,"JS 中类型转换只有三种情况，分别是："),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"转换为布尔值"),Object(b.b)("li",{parentName:"ul"},"转换为 Number"),Object(b.b)("li",{parentName:"ul"},"转换为 String ")),Object(b.b)("h3",{id:"toboolean"},"toBoolean"),Object(b.b)("p",null,"转布尔值很简单。除了下面这 6 个，其它都是 true。"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"false"),Object(b.b)("li",{parentName:"ul"},"'' 或 \"\""),Object(b.b)("li",{parentName:"ul"},"undefined"),Object(b.b)("li",{parentName:"ul"},"null"),Object(b.b)("li",{parentName:"ul"},"0(含+0、-0)"),Object(b.b)("li",{parentName:"ul"},"NaN")),Object(b.b)("h3",{id:"stringtonumber"},"StringToNumber"),Object(b.b)("p",null,"字符串转数字，存在一个语法结构，类型转换支持十进制、二进制、八进制、十六进制，如:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"30"),Object(b.b)("li",{parentName:"ul"},"0b111"),Object(b.b)("li",{parentName:"ul"},"0o13"),Object(b.b)("li",{parentName:"ul"},"0xFF")),Object(b.b)("p",null,"还支持正负号科学计数法。"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"1e3 (1000)"),Object(b.b)("li",{parentName:"ul"},"-1e-2 (-0.01)")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"parseInt()")," 在不传入第二个参数情况下，只支持16进制前缀",Object(b.b)("inlineCode",{parentName:"p"},"0x"),"，而且忽略非数字字符，不支持科学计数法。在一些浏览器上，还支持0开头的数作为8进制前缀，这是很多错误的来源。所以任何情况下，都建议传入第二个参数。parseFloat 会将原字符串作为十进制解析，不会引入任何其它进制。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"parseInt(0x11)  // 17\nparseInt('011')   // 11  \nparseInt(011)     // 9\n\nparseFloat('1e2')   // 100\nparseFloat('1ae2')  // 1\nparseFloat('0x11')  // 0\n")),Object(b.b)("p",null,"多数情况下，使用 ",Object(b.b)("inlineCode",{parentName:"p"},"Number")," 比 ",Object(b.b)("inlineCode",{parentName:"p"},"parseInt")," 和 ",Object(b.b)("inlineCode",{parentName:"p"},"parseFloat")," 更好。"),Object(b.b)("h3",{id:"numbertostring"},"NumberToString"),Object(b.b)("p",null,"在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"0x11.toString()  // 17\n")),Object(b.b)("p",null,"注：基本类型的隐式转换貌似是内部进行的。并没有调用 toString 或 String 方法。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var nf = Number.prototype.toString\nvar s = String \nString = function(...args){\n    console.log('called String')\n    return s(...args)\n}\nNumber.prototype.toString = function (...args) {\n    console.log('called number toString')\n    return nf.call(this, ...args)\n}\n2.1 + ''  // 无输出console\n")),Object(b.b)("h3",{id:"运算符"},"运算符"),Object(b.b)("p",null,"四则运算符会触发数据类型的转换。规律是:"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"运算中其中一方为字符串，那么就会把另一方也转换为字符串"),Object(b.b)("li",{parentName:"ul"},"如果一方不是字符串或者数字，那么会将它转换为数字或者字符串")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"1 + '1' // '11'\ntrue + true // 2\n4 + [1,2,3] // \"41,2,3\"\n\n'a' + + 'b' // -> \"aNaN\" 因为 +'b' 是 NaN\n\n+ '1' // 1\n+ new Date() // 1563891201093\n\n4 * '3' // 12\n4 * [] // 0\n4 * [1, 2] // NaN\n")),Object(b.b)("p",null,"比较运算符"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"如果是对象，就通过 toPrimitive 转换对象"),Object(b.b)("li",{parentName:"ul"},"如果是字符串，就通过 unicode 字符索引来比较")),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return -2\n  }\n}\na > -1 // true\n")),Object(b.b)("p",null,"上面代码，a 会首先通过 valueOf() 转换为原始类型，即数字 0，然后再和 -1 进行比较。"),Object(b.b)("h3",{id:"和"},"==和==="),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"面试题：== 和 === 的区别？")),Object(b.b)("p",null,Object(b.b)("inlineCode",{parentName:"p"},"=="),"如果类型相同，则比较大小；如果类型不同，则进行类型转换。具体过程很复杂，可以查看",Object(b.b)("a",a({parentName:"p"},{href:"https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1"}),"标准文档"),"。常用的转换规则如下："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"null == undefined  // true\n\n// string 转 number\nstring == number  \n\n// 布尔转number\nboolean == any\n\n// object 转基本类型\nobject == string || number || symbol\n")),Object(b.b)("p",null,"可以看到",Object(b.b)("inlineCode",{parentName:"p"},"=="),"的转换过程十分复杂，所以建议用",Object(b.b)("inlineCode",{parentName:"p"},"==="),"代替它。"),Object(b.b)("h3",{id:"装箱转换"},"装箱转换"),Object(b.b)("p",null,"基本类型存储的是值，是没有方法可以调用的。比如",Object(b.b)("inlineCode",{parentName:"p"},"null.toString()"),"会报错。但是为什么",Object(b.b)("inlineCode",{parentName:"p"},"(100).toString()"),"可以呢？这涉及到 JS 自带的装箱转换。"),Object(b.b)("p",null,"装箱转换，就是把基本类型转换为对应的对象。所以对于",Object(b.b)("inlineCode",{parentName:"p"},"(100).toString()"),"，实际上 JS 会将100进行装箱转换，变成对象",Object(b.b)("inlineCode",{parentName:"p"},"new Number(100)"),"。"),Object(b.b)("p",null,"每次装箱都会新建一个对象，所以给基本类型添加属性是无效的。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = 1\na.id = 'hello'\na.id  // undefined\n")),Object(b.b)("p",null,"Number、String、Boolean、Symbol 都有对应的类。"),Object(b.b)("p",null,"Symbol 的装箱操作，可以使用下面方法："),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var symbolObj = (function(){ return this }).call(Symbol('a'))\n\ntypeof symbolObj   // object\nsymbolObj instanceof Symbol // true\nsymbolObj.constructor    // Symbol\n")),Object(b.b)("p",null,"装箱机制会频繁产生临时对象，在一些性能高的场景下，应该避免对基本类型做装箱转换。"),Object(b.b)("p",null,"使用内置的 Object() 函数，也可以显示调用装箱能力。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var symbolObj = Object(Symbol('a'))\n\ntypeof symbolObj   // object\nsymbolObj instanceof Symbol // true\nsymbolObj.constructor    // Symbol\n\nObject.prototype.toString.call(symbolObj)  // [object Symbol]\n")),Object(b.b)("p",null,"Object.prototype.toString 可以准确识别对象对应的基本类型。比instance 更加准确。但是 call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型和对象类型。"),Object(b.b)("h3",{id:"拆箱转换"},"拆箱转换"),Object(b.b)("p",null,"拆箱转换，就是对象类型转成基本类型。它会调用内置的",Object(b.b)("inlineCode",{parentName:"p"},"[[ToPrimitive]]"),"方法。"),Object(b.b)("p",null,"对象到 String 和 Number 的转换都遵循",Object(b.b)("inlineCode",{parentName:"p"},"先拆箱，再转换"),"的规则，通过拆箱转换，将对象变为基本类型，再从基本类型转换为对应的 String 或 Number。"),Object(b.b)("p",null,"拆箱转换会尝试调用 valueOf 和 toString 来获取拆箱后的基本类型，如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会报错 TypeError。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = {\n    valueOf() {\n        console.log('valueOf')\n        return {}\n    },\n    toString() {\n        console.log('toString')\n        return {}\n    }\n}\n\n// 对象转Number\na * 2\n// valueOf\n// toString\n// TypeError: Cannot convert object to primitive value\n\n// 对象转String\nString(a)\n// toString\n// valueOf\n// TypeError\n")),Object(b.b)("p",null,"可以看到，转 Number 是先调用 valueOf()，再调用 toString()。转 String 是先调用 toString() 再调用 valueOf()。"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"规范指出，类型转换的内部实现是通过ToPrimitive ( input ","[ , PreferredType ]",' )方法进行转换的，这个方法 的作用就是将input转换成一个非对象类型。\n参数preferredType是可选的，它的作用是，指出了input被期待转成的类型。 如果不传preferredType进来，默认的是\'number\'。\n如果preferredType的值是"string"，那就先执行"toString", 后执行"valueOf"。否则，先执行"valueOf", 后 执行"toString"。\n由此可见，"toString", "valueOf"的执行顺序，取决于preferred的值。\n加法运算符的规则，ToPrimitive 没有传第二个参数，默认是 number')),Object(b.b)("p",null,"在 ES6 之后，可以重写",Object(b.b)("inlineCode",{parentName:"p"},"Symbol.toPrimitive"),"来覆盖原有的行为，不再调用 ",Object(b.b)("inlineCode",{parentName:"p"},"valueOf")," 或 ",Object(b.b)("inlineCode",{parentName:"p"},"toString"),"。"),Object(b.b)("pre",null,Object(b.b)("code",a({parentName:"pre"},{className:"language-js"}),"a[Symbol.toPrimitive] = function(){\n    console.log('@@toPrimitive Symbol')\n    return 2\n\n    // 如果 return {}， 会报错 TypeError\n}\n\nString(a)\n// @@toPrimitive Symbol\n// 2\n")),Object(b.b)("p",null,"上面代码中，",Object(b.b)("inlineCode",{parentName:"p"},"Symbol.toPrimitive"),"返回了一个基本类型，所以直接执行",Object(b.b)("inlineCode",{parentName:"p"},"String(2)"),"。如果返回一个对象，则会报错",Object(b.b)("inlineCode",{parentName:"p"},"TypeError: Cannot convert object to primitive value"),"。"),Object(b.b)("p",null,"除了这七种语言类型，还有一些语言的实现者更关心的规范类型。"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"List 和 Record: 用于描述函数传参过程。"),Object(b.b)("li",{parentName:"ul"},"Set: 主要用于解释字符集等。"),Object(b.b)("li",{parentName:"ul"},"Completion Record: 用于描述异常、跳出等语句执行过程。"),Object(b.b)("li",{parentName:"ul"},"Reference: 用于描述对象属性访问、delete等。"),Object(b.b)("li",{parentName:"ul"},"Property Descriptor: 用于描述对象的属性。"),Object(b.b)("li",{parentName:"ul"},"Lexical Environment 和 Environment Record: 用于描述变量和作用域。"),Object(b.b)("li",{parentName:"ul"},"Data Block: 用于描述二进制数据。")),Object(b.b)("p",null,"关于Number类型，如果想要进一步理解可以去参考IEEE 754中关于浮点数的表达规范，了解这64位中各\n个位数段表达的含义\n文中有几个叙述不清的地方:\n1. NaN和+Infinity的规定实际是IEEE 754标准规定的特殊值: (e为指数的位数，双精度中e=11)"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},"指数为2^e – 1且尾数的小数部分全0，这个数字是±∞。(符号位决定正负)"),Object(b.b)("li",{parentName:"ul"},"指数为2^e – 1且尾数的小数部分非全0，这个数字是NaN，比如单精度浮点数中按位表示:S111 1111 1 AXX XXXX XXXX XXXX XXXX XXXX，S为符号位值无所谓，A是小数位的最高位(整数位1省略)，其取值表 示了NaN的类型:X不能全为0，并被称为NaN的payload")),Object(b.b)("ol",{start:2},Object(b.b)("li",{parentName:"ol"},"NaN，占用了 9007199254740990，这个叙述不对\n留言里很多童鞋都提出了 9007199254740990 被占用是什么意思的疑问，实际是第一点描述的关于NaN 规定和参考双精度浮点数的表达方式，尾数共有53位，指数固定为2^e – 1并去掉±∞两个值，那么NaN其 实是 2^53-2 个特殊数字的合集(2^53-2 = 9007199254740990 );\n并不是 9007199254740990 被占用，而是 9007199254740990 个特殊值被占用来表示 NaN 扩展一下，我们就可以理解为什么NaN !== NaN了，它确实不是一个值，而是一群值呢0 0!")),Object(b.b)("h2",{id:"函数"},"函数"),Object(b.b)("h2",{id:"参考资料"},"参考资料"),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://coolcao.com/2016/10/12/js%E4%B8%AD0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/"}),"js中0-1-0-2为什么不等于0-3")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://dev.to/alldanielscott/how-to-compare-numbers-correctly-in-javascript-1l4i"}),"How to compare numbers correctly in JavaScript")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://xwjgo.github.io/2018/03/17/js%E4%B8%AD%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}),"js中精度问题以及解决方案")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://floating-point-gui.de/references/"}),"https://floating-point-gui.de/references/")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://www.cnblogs.com/snandy/p/4943138.html"}),"JavaScript数字精度丢失问题总结")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://segmentfault.com/a/1190000013632163#articleHeader14"}),"你对Number一无所知")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://www.cnblogs.com/icmzn/p/5060195.html"}),"程序员必知之浮点数运算原理详解")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://juejin.im/post/5cbd604be51d456e7f0ba59a"}),"谈 JavaScript 浮点数计算精度问题（如0.1+0.2!==0.3）")),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",a({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/30703042"}),"抓住数据的小尾巴 - JS浮点数陷阱及解法"))))}o.isMDXComponent=!0},249:function(e,n,t){"use strict";t.d(n,"a",function(){return c}),t.d(n,"b",function(){return u});var b=t(0),a=t.n(b),l=a.a.createContext({}),r=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=r(e.components);return a.a.createElement(l.Provider,{value:n},e.children)};var i="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},o=function(e){var n=e.components,t=e.mdxType,b=e.originalType,l=e.parentName,c=function(e,n){var t={};for(var b in e)Object.prototype.hasOwnProperty.call(e,b)&&-1===n.indexOf(b)&&(t[b]=e[b]);return t}(e,["components","mdxType","originalType","parentName"]),i=r(n),o=t,u=i[l+"."+o]||i[o]||p[o]||b;return n?a.a.createElement(u,Object.assign({},c,{components:n})):a.a.createElement(u,c)};function u(e,n){var t=arguments,b=n&&n.mdxType;if("string"==typeof e||b){var l=t.length,r=new Array(l);r[0]=o;var c={};for(var p in n)hasOwnProperty.call(n,p)&&(c[p]=n[p]);c.originalType=e,c[i]="string"==typeof e?e:b,r[1]=c;for(var u=2;u<l;u++)r[u]=t[u];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,t)}o.displayName="MDXCreateElement"}}]);