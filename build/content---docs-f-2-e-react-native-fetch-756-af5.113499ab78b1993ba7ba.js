(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{194:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return s}),t.d(n,"rightToc",function(){return i}),t.d(n,"default",function(){return l});t(0);var r=t(251);function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function a(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s={title:"react-native fetch封装与问题",date:new Date("2017-11-04T07:08:14.000Z"),toc:!0},i=[{value:"fetch时带上cookie",id:"fetch时带上cookie",children:[]},{value:"网络请求问题",id:"网络请求问题",children:[]},{value:"使用axios封装http.js",id:"使用axios封装httpjs",children:[]},{value:"使用fetch封装http.js",id:"使用fetch封装httpjs",children:[]}],p={rightToc:i},c="wrapper";function l(e){var n=e.components,t=a(e,["components"]);return Object(r.b)(c,o({},p,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"fetch时带上cookie"},"fetch时带上cookie"),Object(r.b)("p",null,"现在有个需求，就是每次发数据请求的时候都需要带上cookie。但是我通过fetch请求的时候发现cookie并没有被带上。"),Object(r.b)("p",null,"在网上找了半天，原来是因为fetch请求需要配置一个credentials参数。具体如下："),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{}),"fetch('1.json', {\n    method: 'GET',\n    credentials: 'same-origin'\n}).then()\n")),Object(r.b)("p",null,"通过上面的修改，android端可以了，开心中..."),Object(r.b)("p",null,"接着我打开 xcode的 ios模拟器，发现又出问题了，提示 fetch 网络请求失败 network request failed。继续查找是什么原因。"),Object(r.b)("p",null,"最后发现原来，ios现在已经改成默认是发https请求了，这样会更加安全。但是我想发http啊，咋办呢？"),Object(r.b)("p",null,"解决办法是在xcode 里打开项目中的 Info.plist 然后添加几个配置。"),Object(r.b)("p",null,"1、右键新增App Transport Security Settings 设置成 Dictionary。（如果有了就不新增了）"),Object(r.b)("p",null,"2、在App Transport Security Settings的下面新增一个 Allow Arbitrary Loads 设置成Boolean，值改成Yes。"),Object(r.b)("p",null,"通过上面的修改，重启一个模拟器，就可以发请求了。"),Object(r.b)("p",null,"今天使用React Native 发送请求的时候，发现使用"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"fetch('https://mywebsite.com/endpoint/', {\n    method: 'POST',\n        headers: {\n    },\n    body: JSON.stringify({\n        firstParam: 'yourValue',\n        secondParam: 'yourOtherValue',\n    })\n})\n")),Object(r.b)("p",null,"默认发送",Object(r.b)("inlineCode",{parentName:"p"},"’Content-Type’: ‘application/json’"),"的请求，但是现在想发送Form表单,该怎么写呢？ 这里找到了答案："),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{}),"let formData = new FormData();\nformData.append('image', {uri: image.uri, type: 'image/jpg', name: 'image.jpg'});\nformData.append('description', String(data.description));\n\nlet options = {};\noptions.headers['Content-Type'] = 'multipart/form-data; boundary=6ff46e0b6b5148d984f148b6542e5a5d';\noptions.body = formData;\nreturn fetch(uri, options).then((response) => {\n   ....\n});\n")),Object(r.b)("p",null,"只要把body从Json换成FromData就可以了，解决完问题然后下班的感觉真好。"),Object(r.b)("h2",{id:"网络请求问题"},"网络请求问题"),Object(r.b)("p",null,"坑爹，开启了下面的配置。会发送请求一直是："),Object(r.b)("p",null,Object(r.b)("img",o({parentName:"p"},{src:"./imgs/fetch-error1.png",alt:null})),"\n",Object(r.b)("img",o({parentName:"p"},{src:"./imgs/fetch-error2.png",alt:null}))),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"GLOBAL.XMLHttpRequest = GLOBAL.originalXMLHttpRequest || GLOBAL.XMLHttpRequest\nglobal.FormData = global.originalFormData\n")),Object(r.b)("p",null,"下面是我封装ajax的方法，最初我是用fetch封装的，后来该用axio了。"),Object(r.b)("h2",{id:"使用axios封装httpjs"},"使用axios封装http.js"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import {\n    Alert, NetInfo,\n} from 'react-native'\nimport qs from 'qs'\nimport DeviceInfo from 'react-native-device-info'\nimport blUtil from 'bl-util'\nimport {Toast} from 'antd-mobile-rn'\nimport RNBToast from '../api/Toast'\nimport {authApi} from \"api\"\nimport axios from 'axios'\nimport Cookie from \"react-native-cookie\";\n\n// 自定义请求头\nconst headers = {\n    'User-Agent': DeviceInfo.getUserAgent(),\n    'Custom-Device': qs.stringify({\n        device_id: blUtil.md5(DeviceInfo.getUniqueID()),    // uuid\n        device_name: DeviceInfo.getBrand(),     // 手机品牌\n        device_type: 'app',\n        device_version: DeviceInfo.getModel(),  // 手机型号\n        system_version: DeviceInfo.getSystemVersion(),\n        system_name: DeviceInfo.getSystemName(),\n        // serialNumber: DeviceInfo.getSerialNumber(),\n        // bundleId: md5(DeviceInfo.getBundleId()),\n        is_emulator: DeviceInfo.isEmulator(), // 是否是模拟器\n        network: global.NetWork,   // 来源是entry.js\n        ip: DeviceInfo.getIPAddress(),\n        app_version: DeviceInfo.getVersion(),\n    })\n}\n\nconst http_factory = (method) => {\n    return async (url, params, isLoading = false, delay = 0) => {\n        if (isLoading) {\n            Toast.loading()\n        }\n\n        url = url.indexOf('http') > -1 ? url : (APP_CONFIG.base_service + url)\n\n        // 图片上传\n        if (method === 'UPLOAD') {\n            headers['Content-Type'] = 'multipart/form-data;'\n            method = 'POST'\n            // 上传的图片数据\n            let formData = new FormData()\n            let file = {uri: params.uri, name: 'image.png', type: 'multipart/form-data'}\n            formData.append('file', file)\n            params = formData\n        }\n\n        const send_request = () => {\n            return new Promise((resolve, reject) => {\n                axios({\n                    method,\n                    url,\n                    headers,\n                    params,   // get参数\n                    data: params // post参数\n                }).then((response) => {\n                    resolve(response.data)\n                }).catch((error) => {\n                    reject(error)\n                    store.dispatch({\n                        type: \"NETWORK_ERROR\",\n                        cache: {\n                            url,\n                            requestOptions,\n                            resolve\n                        }\n                    })\n                })\n\n            })\n        }\n\n        try {\n            const res = await send_request()\n            console.log('axios url:' + url, params, res)\n\n            if (params && params._tag == 'pass') {\n                return res\n            }\n\n            Toast.hide();\n\n            if (res && res.error) {\n                if (res.error.msg && !res.error.action) {\n                    RNBToast.info(res.error.msg)\n                }\n                // 正常\n                if (res.error.code == 0 || res.error.action) {\n                    return res\n                }\n            }\n\n            // 异常\n            return false\n        }\n        catch (e) {\n            console.log(`http error${url}: ${e}`)\n            setTimeout(() => {\n                Toast.hide();\n            }, delay);\n            store.dispatch({\n                type: \"NETWORK_ERROR\",\n                cache: {\n                    url,\n                    requestOptions\n                }\n            })\n        }\n    }\n}\n\nexport const http_get = http_factory('GET')\nexport const http_post = http_factory('POST')\nexport const http_upload = http_factory('UPLOAD')\n")),Object(r.b)("h2",{id:"使用fetch封装httpjs"},"使用fetch封装http.js"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import {\n    Alert\n} from 'react-native'\nimport qs from 'qs'\nimport {Toast} from 'antd-mobile-rn'\n\nconst http_factory = (method) => {\n    return async (url, params) => {\n        console.log('发送url', url)\n        url = url.indexOf('http') > -1 ? url : (SERVICE_BASE + url)\n        const requestOptions = {\n            method,\n            credentials: \"include\"\n            // headers: {Accept: 'application/json'}\n        }\n\n        if (method === 'GET') {\n            const query = qs.stringify(params)\n            if (query) {\n                url += '?' + query\n            }\n        }\n\n        // 调试专用，上线注释\n        if (APP_CONFIG.debug) {\n            // url = url + (/\\?/.test(url) ? '&' : '?') + 'debug=1&debug_uid=10833'\n        }\n\n        if (method == 'POST') {\n            requestOptions.body = qs.stringify(params)\n            requestOptions.headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n        }\n        // 图片上传\n        if (method === 'UPLOAD') {\n            requestOptions.headers = {\n                'Content-Type': 'multipart/form-data;'\n\n            }\n            requestOptions.method = 'POST'\n            requestOptions.body = params.body\n        }\n\n        const send_request = () => {\n\n            return new Promise((resolve, reject) => {\n\n                fetch(url, requestOptions)\n                    .then(response => {\n                        resolve(response)\n                    }, response => {\n                        reject(response)\n                    })\n                    .catch(error => {\n\n                        store.dispatch({\n                            type: \"NETWORK_ERROR\",\n                            cache: {\n                                url,\n                                requestOptions,\n                                resolve\n                            }\n                        })\n                    })\n            })\n        }\n\n        try {\n            const http_result = await send_request()\n            const text = await http_result.text()\n            let json = JSON.parse(text)\n\n            console.log(json)\n            if (json) {\n                if (json.error) {\n                    Toast.info(json.error.msg)\n                }\n                return json\n            } else {\n                return new Promise(() => {\n                })\n            }\n        }\n        catch (e) {\n            console.log('http error', url, JSON.stringify(e))\n\n            store.dispatch({\n                type: \"NETWORK_ERROR\",\n                cache: {\n                    url,\n                    requestOptions\n                }\n            })\n        }\n    }\n}\n\nexport const http_get = http_factory('GET')\nexport const http_post = http_factory('POST')\nexport const http_upload = http_factory('UPLOAD')\n")))}l.isMDXComponent=!0},251:function(e,n,t){"use strict";t.d(n,"a",function(){return i}),t.d(n,"b",function(){return u});var r=t(0),o=t.n(r),a=o.a.createContext({}),s=function(e){var n=o.a.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},i=function(e){var n=s(e.components);return o.a.createElement(a.Provider,{value:n},e.children)};var p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},l=function(e){var n=e.components,t=e.mdxType,r=e.originalType,a=e.parentName,i=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),p=s(n),l=t,u=p[a+"."+l]||p[l]||c[l]||r;return n?o.a.createElement(u,Object.assign({},i,{components:n})):o.a.createElement(u,i)};function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=l;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var u=2;u<a;u++)s[u]=t[u];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,t)}l.displayName="MDXCreateElement"}}]);