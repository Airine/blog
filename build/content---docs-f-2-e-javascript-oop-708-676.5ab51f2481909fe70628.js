(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{159:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return r}),t.d(n,"rightToc",function(){return l}),t.d(n,"default",function(){return p});t(0);var a=t(229);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function o(e,n){if(null==e)return{};var t,a,c=function(e,n){if(null==e)return{};var t,a,c={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(c[t]=e[t]);return c}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(c[t]=e[t])}return c}var r={title:"javascript 面向对象",sidebar_label:"面向对象"},l=[{value:"构造函数",id:"构造函数",children:[{value:"什么是构造函数",id:"什么是构造函数",children:[]},{value:"constructor",id:"constructor",children:[]},{value:"Symbol是构造函数吗",id:"symbol是构造函数吗",children:[]},{value:"new",id:"new",children:[]},{value:"instanceof",id:"instanceof",children:[]}]},{value:"继承",id:"继承",children:[{value:"组合继承",id:"组合继承",children:[]},{value:"寄生组合继承",id:"寄生组合继承",children:[]},{value:"Class 继承",id:"class-继承",children:[]}]},{value:"关于 this",id:"关于-this",children:[{value:"this 解析",id:"this-解析",children:[]}]},{value:"闭包",id:"闭包",children:[]},{value:"深浅拷贝",id:"深浅拷贝",children:[{value:"浅拷贝",id:"浅拷贝",children:[]},{value:"深拷贝",id:"深拷贝",children:[]}]},{value:"原型和原型链",id:"原型和原型链",children:[{value:"原型",id:"原型",children:[]},{value:"原型链",id:"原型链",children:[]},{value:"Function、Object鸡蛋问题",id:"function、object鸡蛋问题",children:[]}]},{value:"map、filter、reduce",id:"map、filter、reduce",children:[]},{value:"实现call、apply 和 bind",id:"实现call、apply-和-bind",children:[]},{value:"面试题",id:"面试题",children:[]}],b={rightToc:l},i="wrapper";function p(e){var n=e.components,t=o(e,["components"]);return Object(a.b)(i,c({},b,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"构造函数"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#构造函数"}),"#"),"构造函数"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"什么是构造函数"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#什么是构造函数"}),"#"),"什么是构造函数"),Object(a.b)("p",null,"构造函数本身就是一个函数，为了规范，一般首字母大写。普通函数和构造函数的不同在于调用方式，如果是",Object(a.b)("inlineCode",{parentName:"p"},"fn()"),"这样调用，则是普通函数。如果通过",Object(a.b)("inlineCode",{parentName:"p"},"new"),"关键字调用，就是构造函数。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function Person(name){\n    this.name = name\n}\n\nPerson()  // 普通函数\nlet p = new Person()  // 构造函数\n")),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"constructor"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#constructor"}),"#"),"constructor"),Object(a.b)("p",null,"对于实例，都有一个 constructor 属性指向其构造函数(实际在其原型上)。"),Object(a.b)("p",null,"constructor 属性是可修改的，但是对基本类型来说是只读的，因为装箱操作。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"// -------引用类型--------\nfunction A(){}\nfunction B(){}\nlet b = new B()\nb.constructor // B\n\nb.constructor = A \nb.constructor // A\n\n// -------基本类型--------\nvar one = 1\none.constructor  // ƒ Number() { [native code] }\none.constructor = A\none.constructor  // ƒ Number() { [native code] }\n\nnull.constructor  // TypeError: Cannot read property 'constructor' of null\nundefined.constructor  // TypeError: Cannot read property 'constructor' of undefined\n")),Object(a.b)("p",null,"可以看到，对于引用类型，constructor 属性是可以修改的。对于基本类型，是只读的，而且",Object(a.b)("inlineCode",{parentName:"p"},"null"),"和",Object(a.b)("inlineCode",{parentName:"p"},"undefined"),"是不能调 constructor 属性的。"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"symbol是构造函数吗"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#symbol是构造函数吗"}),"#"),"Symbol是构造函数吗"),Object(a.b)("p",null,"要注意的是",Object(a.b)("inlineCode",{parentName:"p"},"Symbol"),"。",Object(a.b)("inlineCode",{parentName:"p"},"Symbol"),"是基本数据类型，但是作为构造函数，它不能",Object(a.b)("inlineCode",{parentName:"p"},"new"),"调用，在 chrome 下，",Object(a.b)("inlineCode",{parentName:"p"},"new Symbol"),"会报错。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"new Symbol(); // Symbol is not a constructor\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Symbol('hi')"),"是基本类型，但是可以获取 constructor 属性值。实际就是",Object(a.b)("inlineCode",{parentName:"p"},"Symbol.prototype.constructor"),"，它返回的就是",Object(a.b)("inlineCode",{parentName:"p"},"Symbol"),"函数，"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"var s = Symbol('hi')\n\ns  // Symbol(hi)\ns.constructor  // ƒ Symbol() { [native code] }\n\nSymbol.prototype.constructor === Symbol  // true\n")),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"new"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#new"}),"#"),"new"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？")),Object(a.b)("p",null,"调用 new 时，执行的步骤如下："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"以构造函数的 prototype 属性为原型，创建新对象。"),Object(a.b)("li",{parentName:"ol"},"将 this 和参数传递给构造器执行。"),Object(a.b)("li",{parentName:"ol"},"如果构造器返回的是对象，则返回。否则返回第一步创建的对象。")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function myNew(constor, ...args) {\n    let o = Object.create(null)\n    // o.__proto__ = constor.prototype\n    Object.setPrototypeOf(o, constor.prototype)\n    let res = constor.call(o, ...args)\n    return res instanceof Object ? res : o\n}\n")),Object(a.b)("p",null,"要注意的是，",Object(a.b)("inlineCode",{parentName:"p"},"__proto__"),"属性是非标准属性，建议用",Object(a.b)("inlineCode",{parentName:"p"},"Object.setPrototypeOf()"),"代替。"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"instanceof"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#instanceof"}),"#"),"instanceof"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：instanceof 的原理是什么？")),Object(a.b)("p",null,"instanceof 内部机制是判断对象的原型链中是否能找到某个类的",Object(a.b)("inlineCode",{parentName:"p"},"prototype"),"。"),Object(a.b)("p",null,"下面实现一下 instanceof。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function myInstanceof(left, right){\n    let prototype = right.prototype\n    left = left.__proto__\n    while(true){\n        if(left === null || left === undefined){\n            return false\n        } \n        if(prototype === left){\n            return true\n        }\n        left = left.__proto__\n    }\n}\n")),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"继承"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#继承"}),"#"),"继承"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"组合继承"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#组合继承"}),"#"),"组合继承"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function Parent(name, age){\n    this.name = name\n    this.age = age\n}\nParent.prototype.getName = function(){\n    console.log(this.name, this.age)\n}\nfunction Child(name, age){\n    Parent.call(this, name, age)\n}\nChild.prototype = new Parent()\n\nconst child = new Child('zs', 12)\nchild.getName()  // 'zs'\nchild instanceof Parent  // true\nchild.constructor  // [Function: Parent]\n")),Object(a.b)("p",null,"组合继承主要是：\n1. 使用",Object(a.b)("inlineCode",{parentName:"p"},"Parent.call()"),"拷贝属性。\n2. 使用",Object(a.b)("inlineCode",{parentName:"p"},"Child.prototype = new Parent()"),"来设置原型。"),Object(a.b)("p",null,"组合继承的好处是，子类的属性是自己的，不会与父类属性共享，但是可以复用父类的函数。缺点是",Object(a.b)("inlineCode",{parentName:"p"},"Child.prototype"),"上还是存在不需要的属性(new Parent创建对象时导致的)，这会造成内存上的浪费。另外 child.constructor 指向 Parent，应该指向 Child。所以需要修改一下。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Child.prototype.constructor = Child\n")),Object(a.b)("p",null,Object(a.b)("img",c({parentName:"p"},{src:"/img/oop/3.png",alt:null}))),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"寄生组合继承"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#寄生组合继承"}),"#"),"寄生组合继承"),Object(a.b)("p",null,"这种方式对上面组合继承进行了优化。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function Parent(name, age){\n    this.name = name\n    this.age = age\n}\nParent.prototype.getName = function(){\n    console.log(this.name, this.age)\n}\nfunction Child(name, age){\n    Parent.call(this, name, age)\n}\nChild.prototype = Object.create(Parent.prototype, {\n    constructor: {\n        value: Child,\n        enumerable: false,\n        writable: true,\n        configrable: true\n    }\n})\n\nconst child = new Child('zs', 12)\nchild.getName()  // 'zs'\nchild instanceof Parent  // true\n")),Object(a.b)("p",null,Object(a.b)("img",c({parentName:"p"},{src:"/img/oop/4.png",alt:null}))),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"class-继承"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#class-继承"}),"#"),"Class 继承"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"class Parent {\n  constructor(name, age) {\n    this.name = name\n  }\n  getName() {\n    console.log(this.name, this.age)\n  }\n}\nclass Child extends Parent {\n  constructor(name, age) {\n    super(name, age)  // 这一句可以看作 Parent.call(this, name, age)\n    this.name = name \n    this.age = age\n  }\n}\nlet child = new Child('zs', 12)\nchild.getName() // 'zs', 12\nchild instanceof Parent // true\n")),Object(a.b)("p",null,Object(a.b)("img",c({parentName:"p"},{src:"/img/oop/5.png",alt:null}))),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"关于-this"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#关于-this"}),"#"),"关于 this"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"this-解析"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#this-解析"}),"#"),"this 解析"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"涉及面试题：如何正确判断 this？箭头函数的 this 是什么？")),Object(a.b)("p",null,"this 的本质是函数执行时的上下文环境。代码中 this 其实很简单，谁调用它，this 就指向谁。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n")),Object(a.b)("p",null,"上面代码，",Object(a.b)("inlineCode",{parentName:"p"},"foo()")," 执行时，没有指定调用对象，调用对象就是全局 global 对象。所以在浏览器中，this 就指向 window。",Object(a.b)("inlineCode",{parentName:"p"},"obj.foo()"),"是通过 obj 调用，所以 this 指向 obj。最后，",Object(a.b)("inlineCode",{parentName:"p"},"new foo()"),"时，this 就是 new 创建的对象 c。"),Object(a.b)("p",null,"要注意，箭头函数是没有 this 的，它也不能通过 bind 绑定 this。箭头函数中的 this 实际会查找上级作用域链。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function a() {\n    return () => {\n      console.log(this)\n    }\n}\na()()\n")),Object(a.b)("p",null,"上面代码中，箭头函数是没有 this 的，所以 this 是函数 a 的，指向 window。"),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"闭包"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#闭包"}),"#"),"闭包"),Object(a.b)("p",null,"闭包是函数和声明该函数的词法环境的组合。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"function A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题，循环中使用闭包解决 ",Object(a.b)("inlineCode",{parentName:"p"},"var")," 定义函数的问题")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n")),Object(a.b)("p",null,"上面代码中，setTimeout 的函数 timer 会在 for 循环执行完后再执行。这时 i 已经是 6 了。所以全部输出 6。"),Object(a.b)("p",null,"解决方法有：\n1. 使用 let (推荐)\n2. 使用闭包"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n    (function (i){\n        setTimeout(function timer() {\n            console.log(i)\n        }, i * 1000)\n    })(i);\n}\n")),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"使用 setTimeout 的第三个参数，它会当作 timer 函数的参数传入。")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n    setTimeout(function timer(i) {\n        console.log(i)\n    }, i * 1000, i)\n}\n")),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"深浅拷贝"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#深浅拷贝"}),"#"),"深浅拷贝"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？")),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"浅拷贝"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#浅拷贝"}),"#"),"浅拷贝"),Object(a.b)("p",null,"浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。"),Object(a.b)("p",null,"1、 ",Object(a.b)("inlineCode",{parentName:"p"},"Object.assign"),"就是浅拷贝。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"let a = {\n  age: 1\n}\nlet b = Object.assign({}, a)\na.age = 2\nconsole.log(b.age) // 1\n")),Object(a.b)("p",null,"2、 ",Object(a.b)("inlineCode",{parentName:"p"},"..."),"也可以实现浅拷贝。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"let a = {\n  age: 1,\n  jobs: {\n    first: 'FE'\n  }\n}\nlet b = { ...a }\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // native\n")),Object(a.b)("p",null,"3、 自定义函数"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function copy(obj){\n    var n = {}\n    for(let i in obj){\n        n[i] = obj[i]\n    }\n    return n\n}\n")),Object(a.b)("p",null,"浅拷贝只解决了第一层的问题，如果深层还有对象，则会共享地址。所以在项目中，我一般使用深拷贝。"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"深拷贝"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#深拷贝"}),"#"),"深拷贝"),Object(a.b)("p",null,"深拷贝就是复制一个与原对象完全不相关的新对象。通常的实现方法有："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"JSON.parse(JSON.stringify(obj))"))),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"var a = {x: 1, y: {z: 3}}\nvar b = JSON.parse(JSON.stringify(a))\na.y.z = 4\nb.y.z // 3\n")),Object(a.b)("p",null,"但是这个方法有一些问题："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"如果属性值为 undefined 或 symbol，则会被忽略"),Object(a.b)("li",{parentName:"ul"},"不能序列化函数"),Object(a.b)("li",{parentName:"ul"},"不能解决循环引用的对象")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"let a = {\n  age: undefined,\n  sex: Symbol('male'),\n  jobs: function() {},\n  name: 'zs'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"zs\"}\n{name: \"zs\"}\n")),Object(a.b)("p",null,"不过对于一般业务代码，这个方法完全够用了。"),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},"使用",Object(a.b)("inlineCode",{parentName:"li"},"MessageChannel"))),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function structuralClone(obj) {\n    return new Promise(resolve => {\n      const { port1, port2 } = new MessageChannel()\n      port2.onmessage = ev => resolve(ev.data)\n      port1.postMessage(obj)\n    })\n  }\n  \n  var obj = {\n    a: 1,\n    b: {\n      c: 2\n    }\n  }\n  \n  obj.b.d = obj.b\n  \n  // 注意该方法是异步的\n  // 可以处理 undefined 和循环引用对象\n  const test = async () => {\n    const clone = await structuralClone(obj)\n    console.log(clone)\n  }\n  test()\n")),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"自己实现一个简单的深拷贝")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function deepClone(obj) {\n  function isObject(o) {\n    return (typeof o === 'object' || typeof o === 'function') && o !== null\n  }\n\n  if (!isObject(obj)) {\n    throw new Error('非对象')\n  }\n\n  let isArray = Array.isArray(obj)\n  let newObj = isArray ? [...obj] : { ...obj }\n  Reflect.ownKeys(newObj).forEach(key => {\n    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n  })\n\n  return newObj\n}\n\nlet obj = {\n  a: [1, 2, 3],\n  b: {\n    c: 2,\n    d: 3\n  }\n}\nlet newObj = deepClone(obj)\nnewObj.b.c = 1\nconsole.log(obj.b.c) // 2\n")),Object(a.b)("p",null,"原型链如何处理、DOM 如何处理"),Object(a.b)("ol",{start:4},Object(a.b)("li",{parentName:"ol"},"lodash 的深拷贝")),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"原型和原型链"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#原型和原型链"}),"#"),"原型和原型链"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"原型"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#原型"}),"#"),"原型"),Object(a.b)("p",null,"常见的面向对象都是通过类实现的，但 JavaScript 是通过原型来实现的。每个对象都以一个原型对象作为模版，可以继承属性和方法。"),Object(a.b)("p",null,Object(a.b)("img",c({parentName:"p"},{src:"/img/oop/2.webp",alt:null}))),Object(a.b)("p",null,"通过上图可以看出："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Foo 构造函数有一个",Object(a.b)("inlineCode",{parentName:"li"},"prototype"),"属性指向其原型 Foo.prototype，原型有一个",Object(a.b)("inlineCode",{parentName:"li"},"constructor"),"属性指向 Foo。"),Object(a.b)("li",{parentName:"ol"},"Foo 构造的实例 new Foo() 的",Object(a.b)("inlineCode",{parentName:"li"},"__proto__"),"属性指向 Foo 的原型。"),Object(a.b)("li",{parentName:"ol"},"所有对象都是 Object 类的实例。所有函数都是 Function 类的实例。"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"Object.prototype.__proto__"),"为 null。"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"Function.prototype.__proto__"),"为 Object.prototype。"),Object(a.b)("li",{parentName:"ol"})),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"`函数.__proto__.constructor == Function`\nFunction instanceof Object\n\n`对象.__proto__.constructor == Object`\nObject instanceof Function\n")),Object(a.b)("p",null,"注：",Object(a.b)("inlineCode",{parentName:"p"},"__proto__"),"在 ES6 才归为标准属性，它是一个访问器属性(即getter和setter)，可以通过它访问到内部属性",Object(a.b)("inlineCode",{parentName:"p"},"[[prototype]]"),"。不过建议使用",Object(a.b)("inlineCode",{parentName:"p"},"Object.getPrototypeOf()"),"。因为",Object(a.b)("inlineCode",{parentName:"p"},"__proto__"),"可能有兼容问题和性能问题。"),Object(a.b)("p",null,"原型相关的方法有："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"// 获取\nObject.getPrototypeOf()\nReflect.getPrototypeOf()\n\n// 设置\nObject.setPrototypeOf()\nReflect.setPrototypeOf()\n\n// 创建\nObject.create()\n")),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"原型链"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#原型链"}),"#"),"原型链"),Object(a.b)("p",null,"每个对象拥有一个原型对象，通过",Object(a.b)("inlineCode",{parentName:"p"},"__proto__"),"指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"function A(){}\nlet a = new A()\n\na.__proto__ === A.prototype // true\na.__proto__.__proto__ === Object.prototype  // true\na.__proto__.__proto_.__proto__  // null\n\na.name  // undefined\n")),Object(a.b)("p",null,"要注意的是，null 并非原型对象。上面代码显示，",Object(a.b)("inlineCode",{parentName:"p"},"a.name"),"找到最终的原型对象",Object(a.b)("inlineCode",{parentName:"p"},"a.__proto__.__proto__"),"(非null)上，发现没有 name 属性，即返回",Object(a.b)("inlineCode",{parentName:"p"},"undefined"),"。"),Object(a.b)("h3",null,Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"function、object鸡蛋问题"})),Object(a.b)("a",c({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#function、object鸡蛋问题"}),"#"),"Function、Object鸡蛋问题"),Object(a.b)("p",null,"函数都是 Function 创建的，对象都是 Object 创建的。Function、Object 既是对象，也是函数，它们之间有如下关系："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Object instanceof Function  // true\nFunction instanceof Object  // true\nObject instanceof Object    // true\nFunction instanceof Function  // true\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Object.prototype")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Object.prototype"),"是对象的最顶层原型对象。根据 ECMAScript 上",Object(a.b)("a",c({parentName:"p"},{href:"http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4"}),"关于Object.prototype的定义"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"Object.prototype.[[Prototype]] = null\nObject.prototype.[[Class]] = Object\nObject.prototype.[[Extensible]] = true\n")),Object(a.b)("p",null,"如果",Object(a.b)("inlineCode",{parentName:"p"},"Object.prototype"),"是通过 Object 函数创建的，其",Object(a.b)("inlineCode",{parentName:"p"},"[[Prototype]]"),"属性应该是",Object(a.b)("inlineCode",{parentName:"p"},"Object.prototype"),"。所以它并不是 Object 函数创建的。实际上，",Object(a.b)("inlineCode",{parentName:"p"},"Object.prototype"),"是浏览器底层根据 ECMAScript 规范创建的对象。"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Object.prototype"),"是原型链的顶端(不考虑 null)。所有对象都继承了它的 toString 等属性和方法。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Function.prototype")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Function.prototype"),"是函数实例的最顶层原型对象。根据 ECMAScript 上",Object(a.b)("a",c({parentName:"p"},{href:"http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4"}),"关于Function.prototype的定义"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Function.prototype.[[Class]] = Function   // typeof Function.prototype == 'function'\nFunction.prototype.[[Prototype]] = Object.prototype\nFunction.prototype.valueOf 实际是继承自 Object.prototype.valueOf\n\n\nFunction.prototype\n// ƒ () { [native code] }\n\nFunction.prototype.prototype\n// undefined\n\nlet fun = Function.prototype.bind()\n// ƒ () { [native code] }\n\nfun.prototype\n// undefined\n")),Object(a.b)("p",null,"根据上面内容可以发现，并不是所有的函数都有 prototype 属性，函数",Object(a.b)("inlineCode",{parentName:"p"},"Function.prototype"),"就没有 prototype 属性。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Object()")),Object(a.b)("p",null,"Object 构造函数的",Object(a.b)("inlineCode",{parentName:"p"},"[[Prototype]]"),"属性值是",Object(a.b)("inlineCode",{parentName:"p"},"Function.prototype"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Object.__proto__ === Function.prototype  // true\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Function()")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Function.[[Class]] = Function\nFunction.[[Prototype]] = Function.prototype\n")),Object(a.b)("p",null,"上面代码可以看出，Function 构造函数本身是一个函数类型对象。它的原型指向",Object(a.b)("inlineCode",{parentName:"p"},"Function.prototype"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"typeof Function === 'function'  // true\nFunction.__proto__ === Function.prototype // true\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：Function 对象是不是 Function 函数的实例？")),Object(a.b)("p",null,"虽然在 JavaScript 层面上来看，Function 对象确实是 Function 函数的实例。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Function instanceof Function  // true\nFunction.constructor === Function  // true\n")),Object(a.b)("p",null,"但是 Function 是一个内置对象，是在C/C++层面处理(具体需要看 V8 源码)，我们写一个函数",Object(a.b)("inlineCode",{parentName:"p"},"function f(){}"),"时，并没有调用 Function 构造器。所以个人认为它不是 Function 的实例。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"let f = Function\nFunction = function (...args) {\n    console.log('调用了Function')  // 没有输出\n    return f(...args)\n}\nfunction a() {\n    console.log(1)\n}\na()  // 1\n")),Object(a.b)("p",null,"上面代码可以看出，写",Object(a.b)("inlineCode",{parentName:"p"},"function a()"),"并没有调用 Function 构造函数。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"内置类型构建过程")),Object(a.b)("p",null,"浏览器自带的 Javascript 内置对象是在 C/C++ 层面实现的，其初始化过程如下："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"用 C/C++ 构造内部数据结构创建一个 OP 即 (Object.prototype) 以及初始化其内部属性但不包括行为。"),Object(a.b)("li",{parentName:"ol"},"用 C/C++ 构造内部数据结构创建一个 FP 即 (Function.prototype) 以及初始化其内部属性但不包括行为。"),Object(a.b)("li",{parentName:"ol"},"将 FP 的 [","[Prototype]","] 指向 OP。"),Object(a.b)("li",{parentName:"ol"},"用 C/C++ 构造内部数据结构创建各种内置引用类型。"),Object(a.b)("li",{parentName:"ol"},"将各内置引用类型的[","[Prototype]","]指向 FP。"),Object(a.b)("li",{parentName:"ol"},"将 Function 的 prototype 指向 FP。"),Object(a.b)("li",{parentName:"ol"},"将 Object 的 prototype 指向 OP。"),Object(a.b)("li",{parentName:"ol"},"用 Function 实例化出 OP，FP，以及 Object 的行为并挂载。"),Object(a.b)("li",{parentName:"ol"},"用 Object 实例化出除 Object 以及 Function 的其他内置引用类型的 prototype 属性对象。"),Object(a.b)("li",{parentName:"ol"},"用 Function 实例化出除Object 以及 Function 的其他内置引用类型的 prototype 属性对象的行为并挂载。"),Object(a.b)("li",{parentName:"ol"},"实例化内置对象 Math 以及 Grobal")),Object(a.b)("p",null,"至此，所有内置类型构建完成。"),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"map、filter、reduce"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#map、filter、reduce"}),"#"),"map、filter、reduce"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"map"),"和",Object(a.b)("inlineCode",{parentName:"p"},"filter"),"返回一个新数组"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"reduce"),"可以挨个处理数组的元素，最终返回一个值。"),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"实现call、apply-和-bind"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#实现call、apply-和-bind"}),"#"),"实现call、apply 和 bind"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：call、apply 及 bind 函数内部实现是怎么样的？")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-js"}),"Function.prototype.myCall = function (context) {\n    if (typeof this !== 'function') {\n        throw new TypeError(`Error`)\n    }\n    // 如果 context 是基本类型，需要是对象才能挂载 .fn 属性\n    context = typeof context === 'object' ? context || window : Object.create(null)\n    // 下面最好用 Symbol，因为如果原对象可能有fn属性，这样会被覆盖掉\n    context.fn = this\n    var args = [...arguments].slice(1)\n    // 谁调用，this 就是谁\n    var result = context.fn(...args)\n    delete context.fn\n    return result\n}\n\nFunction.prototype.myApply = function(context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  context = typeof context === 'object' ? context || window : Object.create(null)\n  context.fn = this\n  let result\n  // 处理参数和 call 有区别\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n  delete context.fn\n  return result\n}\n\nFunction.prototype.myBind = function (context) {\n    if (typeof this !== 'function') {\n        throw new TypeError('Error')\n    }\n    const args = [...arguments].slice(1)\n    context = typeof context === 'object' ? context || window : Object.create(null)\n    context.fn = this\n    return function () {\n        if (new.target) {\n            return new context.fn(...args, ...arguments)\n        }\n        return context.fn(...args, ...arguments)\n    }\n}\n")),Object(a.b)("p",null,"要注意 myBind 返回一个函数，可以通过普通方式和 new 调用。"),Object(a.b)("h2",null,Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"面试题"})),Object(a.b)("a",c({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#面试题"}),"#"),"面试题"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"bind、call、apply的区别?"),Object(a.b)("li",{parentName:"ol"},"介绍下原型链（解决的是继承问题吗）?"),Object(a.b)("li",{parentName:"ol"},"深拷贝和浅拷贝?lodash深拷贝实现原理？"),Object(a.b)("li",{parentName:"ol"},"JS继承方案?平常是怎么做继承?"),Object(a.b)("li",{parentName:"ol"},"介绍this是什么，this的各种情况?"),Object(a.b)("li",{parentName:"ol"},"怎么实现this对象的深拷贝?"),Object(a.b)("li",{parentName:"ol"},"介绍原型？原型链？使用原型最大的好处?"),Object(a.b)("li",{parentName:"ol"},"栈和堆具体怎么存储?"),Object(a.b)("li",{parentName:"ol"},"栈和堆的区别?"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"prototype"),"和",Object(a.b)("inlineCode",{parentName:"li"},"__proto__"),"区别?"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"constructor"),"是什么?"),Object(a.b)("li",{parentName:"ol"},"new 是怎么实现的?")))}p.isMDXComponent=!0},229:function(e,n,t){"use strict";t.d(n,"a",function(){return l}),t.d(n,"b",function(){return s});var a=t(0),c=t.n(a),o=c.a.createContext({}),r=function(e){var n=c.a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},l=function(e){var n=r(e.components);return c.a.createElement(o.Provider,{value:n},e.children)};var b="mdxType",i={inlineCode:"code",wrapper:function(e){var n=e.children;return c.a.createElement(c.a.Fragment,{},n)}},p=function(e){var n=e.components,t=e.mdxType,a=e.originalType,o=e.parentName,l=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),b=r(n),p=t,s=b[o+"."+p]||b[p]||i[p]||a;return n?c.a.createElement(s,Object.assign({},l,{components:n})):c.a.createElement(s,l)};function s(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=p;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[b]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<o;s++)r[s]=t[s];return c.a.createElement.apply(null,r)}return c.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);