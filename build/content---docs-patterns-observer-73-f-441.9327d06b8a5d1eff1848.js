(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{118:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return c}),t.d(n,"rightToc",function(){return b}),t.d(n,"default",function(){return s});t(0);var r=t(251);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c={title:"javascript 发布订阅模式",sidebar_label:"发布订阅模式"},b=[{value:"观察者模式",id:"观察者模式",children:[]},{value:"发布订阅模式",id:"发布订阅模式",children:[{value:"简介",id:"简介",children:[]},{value:"实现",id:"实现",children:[]}]},{value:"观察者模式",id:"观察者模式-1",children:[]}],i={rightToc:b},o="wrapper";function s(e){var n=e.components,t=l(e,["components"]);return Object(r.b)(o,a({},i,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h3",{id:"观察者模式"},"观察者模式"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"http://www.cnblogs.com/lovesong/p/5272752.html"}),"设计模式（三）：观察者模式与发布/订阅模式区别")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://www.zhihu.com/question/23486749"}),"观察者模式和发布订阅模式有什么不同？"))),Object(r.b)("p",null,"有些人经常将发布订阅模式和观察者模式弄混淆，实际它们是有区别的，下面来详细介绍。"),Object(r.b)("h2",{id:"发布订阅模式"},"发布订阅模式"),Object(r.b)("h3",{id:"简介"},"简介"),Object(r.b)("p",null,"发布订阅模式是一种消息范式，消息发布者和订阅者是解耦无关的，它们之间通过消息中心来管理。消息可以分为多个类别，不关注订阅者。订阅者可以订阅一个或多个类别感兴趣的消息，也不关心发布者。(它实际是去除了发布者和订阅者，只关注消息的发布和订阅)。"),Object(r.b)("h3",{id:"实现"},"实现"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function Event() {\n    this.callbacks = []\n}\n\nEvent.prototype.on = function (fn) {\n    this.callbacks.push(fn)\n}\n\nEvent.prototype.emit = function () {\n    var _this = this\n    var _args = arguments\n    this.callbacks.forEach(function (callback) {\n        callback.apply(_this, _args)\n    })\n}\n\nvar e = new Event()\ne.on(function (a) {\n    console.log(1, a)\n})\ne.on(function (a, b) {\n    console.log(2, a, b)\n})\ne.emit('hi', 'xx')\n")),Object(r.b)("h2",{id:"观察者模式-1"},"观察者模式"),Object(r.b)("p",null,"观察者模式是软件设计模式的一种，是一个目标对象管理所有依于它的观察者对象，并且在它本身的状态改变时主动发出通知。目标被观察者观察，目标变化时观察者执行某些操作。它们是紧耦合的。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"被观察者Subject实例的方法")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"attach(observer)"),": 让观察者绑定被观察者"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"notifyAllObserver()"),": 状态变化时，通知观察者(即调用观察者的update()方法)")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"观察者Observer实例的方法")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"update()"),": 目标变化时，观察者执行的操作")),Object(r.b)("p",null,"注意被观察者和观察者时紧耦合的"),Object(r.b)("p",null,"实现"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// 目标\nclass Subject {\n    constructor() {\n        this.state = 0\n        this.observers = []\n    }\n\n    getState() {\n        return this.state\n    }\n\n    setState(state) {\n        this.state = state\n        this.notifyAllObserver()\n    }\n\n    notifyAllObserver() {\n        this.observers.forEach(observe => {\n            observe.update()\n        })\n    }\n\n    attach(observer) {\n        this.observers.push(observer)\n    }\n}\n\n// 观察者\nclass Observer {\n    constructor(name, subject) {\n        this.name = name\n        this.subject = subject\n        this.subject.attach(this)  // 目标绑定观察者\n    }\n\n    update() {\n        console.log(`my name is ${this.name},subject state is ${this.subject.getState()}`)\n    }\n}\n\nconst s = new Subject()\nconst o1 = new Observer('o1', s)\nconst o2 = new Observer('o2', s)\n\ns.setState(1)\ns.setState(2)\n")),Object(r.b)("p",null,"当目标变化时，即调用",Object(r.b)("inlineCode",{parentName:"p"},"s.setState()"),"时，观察者会收到消息。"),Object(r.b)("p",null," 发布订阅模式和观察者模式的区别"),Object(r.b)("p",null,"发布订阅模式是最常用的一种观察者模式的实现。观察者模式是耦合的，它强调目标和观察者，当目标变化通知观察者。但是大多数场景中我们并不关心目标和观察者，而是只关心目标的变化。所以发布订阅模式只通过消息中心来调度，它去除了发布者和订阅者(解耦)，只管消息的订阅和发布。"),Object(r.b)("p",null,"优缺点也很明显，紧密耦合的方式简单直接，扩展性差，而且要求两端同时存在。松散耦合不直接产生依赖，更容易扩展，想在哪里用就在哪里用。"),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"./imgs/observer.png",alt:null}))),Object(r.b)("p",null,"应用场景"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"网页事件绑定：点击按钮的时候触发绑定的事件"),Object(r.b)("li",{parentName:"ul"},"Promise")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"result.then(()=>{\n    // then这里是绑定，等到promise pending状态变化时触发\n}).then()\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"jQuery callbacks")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"var callbacks = $.Callbacks()\ncallbacks.add(function(info){console.log(info)})  // fire\ncallbacks.fire('fire')\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"自定义事件")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const EventEmitter = require('events').EventEmitter\nconst emitter = new EventEmitter()\nemitter.on('end', function(){\n    console.log('hi')\n})\nemitter.emit('end')\n\n// 2\nclass Person extends EventEmitter{\n\n}\nlet p = new Person()\np.on('talk', ()=>{})\np.emit('talk')\n\n// 3、坏处是可能不是一行一行的读\nvar fs = require('fs')\nvar readStream = fs.createReadStream('./1.txt')\nvar length = 0\nreadStream.on('data', function(chunk){\n    length += chunk.toString().length\n})\nreadStream.on('end',function(){\n    console.log(length)\n})\n\n// 4、一行行的读，利用readline\nvar readline = require('readline')\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"nodejs中：处理 http 请求，多进程通讯"),Object(r.b)("li",{parentName:"ul"},"vue 和 react 组件生命周期触发"),Object(r.b)("li",{parentName:"ul"},"vue watch")))}s.isMDXComponent=!0},251:function(e,n,t){"use strict";t.d(n,"a",function(){return b}),t.d(n,"b",function(){return u});var r=t(0),a=t.n(r),l=a.a.createContext({}),c=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},b=function(e){var n=c(e.components);return a.a.createElement(l.Provider,{value:n},e.children)};var i="mdxType",o={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},s=function(e){var n=e.components,t=e.mdxType,r=e.originalType,l=e.parentName,b=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),i=c(n),s=t,u=i[l+"."+s]||i[s]||o[s]||r;return n?a.a.createElement(u,Object.assign({},b,{components:n})):a.a.createElement(u,b)};function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,c=new Array(l);c[0]=s;var b={};for(var o in n)hasOwnProperty.call(n,o)&&(b[o]=n[o]);b.originalType=e,b[i]="string"==typeof e?e:r,c[1]=b;for(var u=2;u<l;u++)c[u]=t[u];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,t)}s.displayName="MDXCreateElement"}}]);