(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{158:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return c}),t.d(n,"rightToc",function(){return b}),t.d(n,"default",function(){return p});t(0);var a=t(249);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c={title:"javascript 语法",sidebar_label:"语法"},b=[{value:"var、let 和 const",id:"var、let-和-const",children:[{value:"提升",id:"提升",children:[]},{value:"重复声明",id:"重复声明",children:[]},{value:"暂时性死区",id:"暂时性死区",children:[]},{value:"区别",id:"区别",children:[]}]},{value:"结尾写分号",id:"结尾写分号",children:[{value:"自动插入分号规则",id:"自动插入分号规则",children:[]},{value:"no LineTerminator here 规则",id:"no-lineterminator-here-规则",children:[]},{value:"不写分号注意情况",id:"不写分号注意情况",children:[]}]},{value:"参考资料",id:"参考资料",children:[]}],i={rightToc:b},o="wrapper";function p(e){var n=e.components,t=l(e,["components"]);return Object(a.b)(o,r({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"var、let-和-const"},"var、let 和 const"),Object(a.b)("h3",{id:"提升"},"提升"),Object(a.b)("p",null,"提升是指使用 var 声明的变量、function 声明定义的函数会提升到作用域前面。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"a()\nfunction a(){}\n\nconsole.log(b)  // undefined\nvar b = 3\n")),Object(a.b)("p",null,"上面的代码，a 在",Object(a.b)("inlineCode",{parentName:"p"},"function a()"),"之前使用，b 在",Object(a.b)("inlineCode",{parentName:"p"},"var b"),"之前使用，并没有报错。这就是提升，实际相当于:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = function(){}\na()\n\nvar b \nconsole.log(b)  // undefined\nb = 3\n")),Object(a.b)("p",null,"可以看到，函数 a 的声明和定义都提前了，var 声明的变量 b 的声明提前了，赋值并没有提前，所以输出 b 为 undefind。"),Object(a.b)("p",null,"提升存在的根本原因就是为了解决函数间互相调用的情况"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function test1() {\n    test2()\n}\nfunction test2() {\n    test1()\n}\ntest1()\n")),Object(a.b)("h3",{id:"重复声明"},"重复声明"),Object(a.b)("p",null,"重复 var 声明同一个变量，只有第一次声明有效。后面的定义会覆盖前面的值。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"// --- example 1\nvar a = 1\nvar a = 3\n// 相当于\nvar a \na = 1\na = 3\n\n// --- example 2\nconsole.log(a) // ƒ a() {}\nvar a = 1\nfunction a() {}\n")),Object(a.b)("p",null,"上面 example 2 可以看到，函数的声明定义要优先于变量 var 的声明。因为 function a 后，var a 并没有生效。"),Object(a.b)("h3",{id:"暂时性死区"},"暂时性死区"),Object(a.b)("p",null,"var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function test(){\n  console.log(a)\n  let a\n}\ntest()  // Uncaught ReferenceError: a is not defined\n")),Object(a.b)("h3",{id:"区别"},"区别"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部"),Object(a.b)("li",{parentName:"ul"},"var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用"),Object(a.b)("li",{parentName:"ul"},"var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会"),Object(a.b)("li",{parentName:"ul"},"let 和 const 作用基本一致，但是后者声明的变量不能再次赋值")),Object(a.b)("h2",{id:"结尾写分号"},"结尾写分号"),Object(a.b)("p",null,"最初，行尾使用分号是为了降低编译器的负担。但是今天编译器效率已经足够高，行尾使用分号反而成为了一种语法噪音。"),Object(a.b)("h3",{id:"自动插入分号规则"},"自动插入分号规则"),Object(a.b)("p",null,"自动插入分号的规则有 3 条，如下："),Object(a.b)("p",null,"1、有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"let a = 1\nlet b = 2\n")),Object(a.b)("p",null,"2、有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。"),Object(a.b)("p",null,"根据 JavaScript 标准，表达式和",Object(a.b)("inlineCode",{parentName:"p"},"++"),"之间不能有换行符。如下",Object(a.b)("inlineCode",{parentName:"p"},"[no LineTerminator here]"),"。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{}),"UpdateExpression[Yield, Await]:\n    LeftHandSideExpression[?Yield, ?Await]\n    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++\n    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]--\n    ++UnaryExpression[?Yield, ?Await]\n    --UnaryExpression[?Yield, ?Await]\n")),Object(a.b)("p",null,"再看下面代码："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{}),"var a = 1, b = 1, c = 1;\na\n++\nb\n++\nc\n")),Object(a.b)("p",null,"根据第 1 条规则，a 后面可以跟 ++，但是根据第 2 条规则，a 与 ++ 之间不能有换行，所以 a 后面会自动插入分号，而 b、c 会变成 2。"),Object(a.b)("p",null,"return 也有","[no LineTerminator here]"," 规则的要求，而带换行符的注释也会被认为有换行符。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function f(){\n    return/*\n        This is a return value.\n    */1;\n}\nf();\n")),Object(a.b)("p",null,"上面代码会返回 undefined。"),Object(a.b)("p",null,"3、源代码结束处，不能形成完整的脚本或模块结构，那么就自动插入分号。"),Object(a.b)("h3",{id:"no-lineterminator-here-规则"},"no LineTerminator here 规则"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"no LineTerminator here"),"规则表示，在规定的结构中不能有换行符，否则会自动插入分号，如上面的例子。"),Object(a.b)("p",null,"规则如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"带标签的 continue 语句，不能在 continue 后插入换行。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"outer:for(var j = 0; j < 10; j++)\n    for(var i = 0; i < j; i++)\n        continue /*no LineTerminator here*/ outter\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"带标签的 break 语句，不能在 break 后插入换行。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"outer:for(var j = 0; j < 10; j++)\n    for(var i = 0; i < j; i++)\n        break /*no LineTerminator here*/ outter\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"return 后面不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"后自增，后自减运算符前不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"throw 和 Exception 之间不能插入换行。会报错",Object(a.b)("inlineCode",{parentName:"li"},"Uncaught SyntaxError: Illegal newline after throw"),"。"),Object(a.b)("li",{parentName:"ul"},"async 关键字后面不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"箭头函数箭头前，不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"yield 之后，不能插入换行。")),Object(a.b)("h3",{id:"不写分号注意情况"},"不写分号注意情况"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"no LineTerminator here"),"规则实际是为了保证自动插入分号符合预期，但是最初 JavaScript 设计遗漏了一些情况。所以需要注意它们。"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"以括号开头的语句。会解析成函数调用。所以下面代码会报错。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"(function(a){\n    console.log(a);\n})()/* 这里没有被自动插入分号 */\n(function(a){\n    console.log(a);\n})()\n")),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},"以数组开头的语句。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = [[]]/* 这里没有被自动插入分号 */\n[3, 2, 1, 0].forEach(e => console.log(e))\n")),Object(a.b)("p",null,"上面代码被理解成了下标运输符和逗号表达式。这里不会报错，对代码调试是噩梦。"),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"以正则开头的语句。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'var x = 1, g = {test:()=>0}, b = 1/* 这里没有被自动插入分号 */\n/(a)/g.test("abc")\nconsole.log(RegExp.$1)\n')),Object(a.b)("p",null,"上面正则的",Object(a.b)("inlineCode",{parentName:"p"},"/"),"被理解成了除号。"),Object(a.b)("ol",{start:4},Object(a.b)("li",{parentName:"ol"},"以 Template 开头的语句。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'var f = function(){\n  return "";\n}\nvar g = f/* 这里没有被自动插入分号 */\n`Template`.match(/(a)/);\nconsole.log(RegExp.$1)\n')),Object(a.b)("p",null,"我们知道 fn","`","Template","`"," 是会执行函数的。上面代码被解析成了函数执行。"),Object(a.b)("p",null,"在实际项目中，如果不写分号，那么最好使用 eslint。"),Object(a.b)("h2",{id:"参考资料"},"参考资料"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://time.geekbang.org/column/article/87179"}),"重学前端"))))}p.isMDXComponent=!0},249:function(e,n,t){"use strict";t.d(n,"a",function(){return b}),t.d(n,"b",function(){return u});var a=t(0),r=t.n(a),l=r.a.createContext({}),c=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},b=function(e){var n=c(e.components);return r.a.createElement(l.Provider,{value:n},e.children)};var i="mdxType",o={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},p=function(e){var n=e.components,t=e.mdxType,a=e.originalType,l=e.parentName,b=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),i=c(n),p=t,u=i[l+"."+p]||i[p]||o[p]||a;return n?r.a.createElement(u,Object.assign({},b,{components:n})):r.a.createElement(u,b)};function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,c=new Array(l);c[0]=p;var b={};for(var o in n)hasOwnProperty.call(n,o)&&(b[o]=n[o]);b.originalType=e,b[i]="string"==typeof e?e:a,c[1]=b;for(var u=2;u<l;u++)c[u]=t[u];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);