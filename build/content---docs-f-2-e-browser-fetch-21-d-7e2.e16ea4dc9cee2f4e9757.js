(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{145:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",function(){return b}),a.d(t,"rightToc",function(){return c}),a.d(t,"default",function(){return o});a(0);var n=a(229);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}function r(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var b={title:"网络请求",sidebar_label:"网络请求"},c=[{value:"网络基础知识",id:"网络基础知识",children:[{value:"UDP",id:"udp",children:[]},{value:"TCP",id:"tcp",children:[]},{value:"HTTP",id:"http",children:[]},{value:"HTTPS",id:"https",children:[]},{value:"HTTP/2 及 HTTP/3",id:"http2-及-http3",children:[]}]},{value:"跨域解决方案",id:"跨域解决方案",children:[]},{value:"面试题",id:"面试题",children:[]}],i={rightToc:c},p="wrapper";function o(e){var t=e.components,a=r(e,["components"]);return Object(n.b)(p,l({},i,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("h2",null,Object(n.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"网络基础知识"})),Object(n.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#网络基础知识"}),"#"),"网络基础知识"),Object(n.b)("h3",null,Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"udp"})),Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#udp"}),"#"),"UDP"),Object(n.b)("p",null,"UDP 协议是面向无连接的，也就是说不需要在发送正式数据前创建连接。不保证有序、完整，没有控制流量的算法，相比 TCP 更加轻便。"),Object(n.b)("p",null,"特点：面向无连接，不可靠性，高效"),Object(n.b)("p",null,"UDP 只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了。"),Object(n.b)("li",{parentName:"ul"},"在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。")),Object(n.b)("p",null,"一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。"),Object(n.b)("p",null,"虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。"),Object(n.b)("p",null,"因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。"),Object(n.b)("p",null,"UDP 头部包含了以下几个数据"),Object(n.b)("p",null,"两个十六位的端口号，分别为源端口（可选字段）和目标端口\n整个数据报文的长度\n整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误"),Object(n.b)("p",null,"直播\n想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？"),Object(n.b)("p",null,"TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。"),Object(n.b)("p",null,"但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 TCP 在这种情况下无用武之地，只会降低用户体验。"),Object(n.b)("p",null,"王者荣耀\n虽然我具体不知道王者荣耀底层使用了什么协议，但是对于这类实时性要求很高的游戏来说，UDP 是跑不了的。"),Object(n.b)("p",null,"为什么这样说呢？首先对于王者荣耀来说，用户体量是相当大的，如果使用 TCP 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 TCP 连接数量是有限制的。"),Object(n.b)("p",null,"再者，因为 TCP 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。"),Object(n.b)("p",null,"UDP 相比 TCP 简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，只会把想发的数据报文一股脑的丢给对端\n虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为"),Object(n.b)("p",null,"UDP：相当于发信息，不需要对方同意就可以发，也不知道对方看了短信没有。\nTCP：相当于打电话，需要对方同意了接听电话，可靠，知道对方接了电话"),Object(n.b)("p",null,"UDP(User Datagram Protocol)"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"无连接"),Object(n.b)("li",{parentName:"ul"},"支持一对一、一对多、多对一、多对多交互通信"),Object(n.b)("li",{parentName:"ul"},"对应用层报文直接打包"),Object(n.b)("li",{parentName:"ul"},"尽最大努力交付，不可靠，不实用流量控制和拥塞控制"),Object(n.b)("li",{parentName:"ul"},"首部开销小，8字节")),Object(n.b)("p",null,"TCP "),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"面向连接"),Object(n.b)("li",{parentName:"ul"},"每条TCP连接只能有两个断点EP，只能一对一通信"),Object(n.b)("li",{parentName:"ul"},"面向字节流，将报文拆成字节流"),Object(n.b)("li",{parentName:"ul"},"可靠传输，使用流量控制和拥塞控制"),Object(n.b)("li",{parentName:"ul"},"首部最小20字节，最大60字节")),Object(n.b)("h3",null,Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"tcp"})),Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#tcp"}),"#"),"TCP"),Object(n.b)("h3",null,Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"http"})),Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#http"}),"#"),"HTTP"),Object(n.b)("h3",null,Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"https"})),Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#https"}),"#"),"HTTPS"),Object(n.b)("h3",null,Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"http2-及-http3"})),Object(n.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#http2-及-http3"}),"#"),"HTTP/2 及 HTTP/3"),Object(n.b)("h2",null,Object(n.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"跨域解决方案"})),Object(n.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#跨域解决方案"}),"#"),"跨域解决方案"),Object(n.b)("h2",null,Object(n.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"面试题"})),Object(n.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#面试题"}),"#"),"面试题"),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"对跨域的了解?"),Object(n.b)("li",{parentName:"ol"},"跨域怎么解决，有没有使用过Apache等方案?"),Object(n.b)("li",{parentName:"ol"},"常见Http请求头?"),Object(n.b)("li",{parentName:"ol"},"文件上传如何做断点续传?"),Object(n.b)("li",{parentName:"ol"},"表单可以跨域吗?"),Object(n.b)("li",{parentName:"ol"},"介绍http2.0"),Object(n.b)("li",{parentName:"ol"},"通过什么做到并发请求?"),Object(n.b)("li",{parentName:"ol"},"http1.1时如何复用tcp连接?"),Object(n.b)("li",{parentName:"ol"},"介绍service worker?"),Object(n.b)("li",{parentName:"ol"},"Http报文的请求会有几个部分?"),Object(n.b)("li",{parentName:"ol"},"tcp3次握手?"),Object(n.b)("li",{parentName:"ol"},"http缓存控制?"),Object(n.b)("li",{parentName:"ol"},"tcp属于哪一层?（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）"),Object(n.b)("li",{parentName:"ol"},"前后端通信使用什么方案?"),Object(n.b)("li",{parentName:"ol"},"RESTful常用的Method?"),Object(n.b)("li",{parentName:"ol"},"介绍下跨域?"),Object(n.b)("li",{parentName:"ol"},"如何解决跨域问题?"),Object(n.b)("li",{parentName:"ol"},"ajax如何处理跨域?"),Object(n.b)("li",{parentName:"ol"},"CORS如何设置?"),Object(n.b)("li",{parentName:"ol"},"jsonp为什么不支持post方法?"),Object(n.b)("li",{parentName:"ol"},"介绍同源策略?"),Object(n.b)("li",{parentName:"ol"},"Access-Control-Allow-Origin在服务端哪里配置?"),Object(n.b)("li",{parentName:"ol"},"Ajax发生跨域要设置什么（前端）?"),Object(n.b)("li",{parentName:"ol"},"加上CORS之后从发起到请求正式成功的过程?"),Object(n.b)("li",{parentName:"ol"},"异步请求，低版本fetch如何低版本适配?"),Object(n.b)("li",{parentName:"ol"},"get和post有什么区别?"),Object(n.b)("li",{parentName:"ol"},"jsonp方案需要服务端怎么配合?"),Object(n.b)("li",{parentName:"ol"},"formData和原生的ajax有什么区别?"),Object(n.b)("li",{parentName:"ol"},"介绍下表单提交，和formData有什么关系?"),Object(n.b)("li",{parentName:"ol"},"服务端怎么做统一的状态处理?"),Object(n.b)("li",{parentName:"ol"},"UDP 与 TCP 的区别是什么？")))}o.isMDXComponent=!0},229:function(e,t,a){"use strict";a.d(t,"a",function(){return c}),a.d(t,"b",function(){return h});var n=a(0),l=a.n(n),r=l.a.createContext({}),b=function(e){var t=l.a.useContext(r),a=t;return e&&(a="function"==typeof e?e(t):Object.assign({},t,e)),a},c=function(e){var t=b(e.components);return l.a.createElement(r.Provider,{value:t},e.children)};var i="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},o=function(e){var t=e.components,a=e.mdxType,n=e.originalType,r=e.parentName,c=function(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===t.indexOf(n)&&(a[n]=e[n]);return a}(e,["components","mdxType","originalType","parentName"]),i=b(t),o=a,h=i[r+"."+o]||i[o]||p[o]||n;return t?l.a.createElement(h,Object.assign({},c,{components:t})):l.a.createElement(h,c)};function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,b=new Array(r);b[0]=o;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[i]="string"==typeof e?e:n,b[1]=c;for(var h=2;h<r;h++)b[h]=a[h];return l.a.createElement.apply(null,b)}return l.a.createElement.apply(null,a)}o.displayName="MDXCreateElement"}}]);