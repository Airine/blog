(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{147:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return c}),t.d(n,"rightToc",function(){return o}),t.d(n,"default",function(){return s});t(0);var a=t(217);function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var c={id:"oop",title:"javascript 面向对象",sidebar_label:"面向对象"},o=[{value:"new",id:"new",children:[]},{value:"instanceof",id:"instanceof",children:[]},{value:"继承",id:"继承",children:[{value:"组合继承",id:"组合继承",children:[]},{value:"寄生组合继承",id:"寄生组合继承",children:[]},{value:"Class 继承",id:"class-继承",children:[]}]},{value:"关于 this",id:"关于-this",children:[{value:"this 解析",id:"this-解析",children:[]}]},{value:"闭包",id:"闭包",children:[]},{value:"深浅拷贝",id:"深浅拷贝",children:[{value:"浅拷贝",id:"浅拷贝",children:[]},{value:"深拷贝",id:"深拷贝",children:[]}]},{value:"原型",id:"原型",children:[]},{value:"map、filter、reduce",id:"map、filter、reduce",children:[]},{value:"实现call、apply 和 bind",id:"实现call、apply-和-bind",children:[]}],b={rightToc:o},i="wrapper";function s(e){var n=e.components,t=r(e,["components"]);return Object(a.b)(i,l({},b,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"new"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#new"}),"#"),"new"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？")),Object(a.b)("p",null,"调用 new 时，执行的步骤如下："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"以构造函数的 prototype 属性为原型，创建新对象。"),Object(a.b)("li",{parentName:"ol"},"将 this 和参数传递给构造器执行。"),Object(a.b)("li",{parentName:"ol"},"如果构造器返回的是对象，则返回。否则返回第一步创建的对象。")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function myNew(constor, ...args) {\n    let o = Object.create(null)\n    o.__proto__ = constor.prototype\n    let res = constor.call(o, ...args)\n    return res instanceof Object ? res : o\n}\n")),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"instanceof"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#instanceof"}),"#"),"instanceof"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：instanceof 的原理是什么？")),Object(a.b)("p",null,"instanceof 内部机制是判断对象的原型链中是否能找到某个类的",Object(a.b)("inlineCode",{parentName:"p"},"prototype"),"。"),Object(a.b)("p",null,"下面实现一下 instanceof。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function myInstanceof(left, right){\n    let prototype = right.prototype\n    left = left.__proto__\n    while(true){\n        if(left === null || left === undefined){\n            return false\n        } \n        if(prototype === left){\n            return true\n        }\n        left = left.__proto__\n    }\n}\n")),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"继承"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#继承"}),"#"),"继承"),Object(a.b)("h3",null,Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"组合继承"})),Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#组合继承"}),"#"),"组合继承"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function Parent(name, age){\n    this.name = name\n    this.age = age\n}\nParent.prototype.getName = function(){\n    console.log(this.name, this.age)\n}\nfunction Child(name, age){\n    Parent.call(this, name, age)\n}\nChild.prototype = new Parent()\n\nconst child = new Child('zs', 12)\nchild.getName()  // 'zs'\nchild instanceof Parent  // true\nchild.constructor  // [Function: Parent]\n")),Object(a.b)("p",null,"组合继承主要是：\n1. 使用",Object(a.b)("inlineCode",{parentName:"p"},"Parent.call()"),"拷贝属性。\n2. 使用",Object(a.b)("inlineCode",{parentName:"p"},"Child.prototype = new Parent()"),"来设置原型。"),Object(a.b)("p",null,"组合继承的好处是，子类的属性是自己的，不会与父类属性共享，但是可以复用父类的函数。缺点是",Object(a.b)("inlineCode",{parentName:"p"},"Child.prototype"),"上还是存在不需要的属性(new Parent创建对象时导致的)，这会造成内存上的浪费。另外 child.constructor 指向 Parent，应该指向 Child。所以需要修改一下。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"Child.prototype.constructor = Child\n")),Object(a.b)("p",null,Object(a.b)("img",l({parentName:"p"},{src:"/static/img/oop/3.png",alt:null}))),Object(a.b)("h3",null,Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"寄生组合继承"})),Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#寄生组合继承"}),"#"),"寄生组合继承"),Object(a.b)("p",null,"这种方式对上面组合继承进行了优化。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function Parent(name, age){\n    this.name = name\n    this.age = age\n}\nParent.prototype.getName = function(){\n    console.log(this.name, this.age)\n}\nfunction Child(name, age){\n    Parent.call(this, name, age)\n}\nChild.prototype = Object.create(Parent.prototype, {\n    constructor: {\n        value: Child,\n        enumerable: false,\n        writable: true,\n        configrable: true\n    }\n})\n\nconst child = new Child('zs', 12)\nchild.getName()  // 'zs'\nchild instanceof Parent  // true\n")),Object(a.b)("p",null,Object(a.b)("img",l({parentName:"p"},{src:"/static/img/oop/4.png",alt:null}))),Object(a.b)("h3",null,Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"class-继承"})),Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#class-继承"}),"#"),"Class 继承"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"class Parent {\n  constructor(name, age) {\n    this.name = name\n  }\n  getName() {\n    console.log(this.name, this.age)\n  }\n}\nclass Child extends Parent {\n  constructor(name, age) {\n    super(name, age)  // 这一句可以看作 Parent.call(this, name, age)\n    this.name = name \n    this.age = age\n  }\n}\nlet child = new Child('zs', 12)\nchild.getName() // 'zs', 12\nchild instanceof Parent // true\n")),Object(a.b)("p",null,Object(a.b)("img",l({parentName:"p"},{src:"/static/img/oop/5.png",alt:null}))),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"关于-this"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#关于-this"}),"#"),"关于 this"),Object(a.b)("h3",null,Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"this-解析"})),Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#this-解析"}),"#"),"this 解析"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"涉及面试题：如何正确判断 this？箭头函数的 this 是什么？")),Object(a.b)("p",null,"this 的本质是函数执行时的上下文环境。代码中 this 其实很简单，谁调用它，this 就指向谁。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n")),Object(a.b)("p",null,"上面代码，",Object(a.b)("inlineCode",{parentName:"p"},"foo()")," 执行时，没有指定调用对象，调用对象就是全局 global 对象。所以在浏览器中，this 就指向 window。",Object(a.b)("inlineCode",{parentName:"p"},"obj.foo()"),"是通过 obj 调用，所以 this 指向 obj。最后，",Object(a.b)("inlineCode",{parentName:"p"},"new foo()"),"时，this 就是 new 创建的对象 c。"),Object(a.b)("p",null,"要注意，箭头函数是没有 this 的，它也不能通过 bind 绑定 this。箭头函数中的 this 实际会查找上级作用域链。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function a() {\n    return () => {\n      console.log(this)\n    }\n}\na()()\n")),Object(a.b)("p",null,"上面代码中，箭头函数是没有 this 的，所以 this 是函数 a 的，指向 window。"),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"闭包"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#闭包"}),"#"),"闭包"),Object(a.b)("p",null,"闭包是函数和声明该函数的词法环境的组合。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{}),"function A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题，循环中使用闭包解决 ",Object(a.b)("inlineCode",{parentName:"p"},"var")," 定义函数的问题")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n")),Object(a.b)("p",null,"上面代码中，setTimeout 的函数 timer 会在 for 循环执行完后再执行。这时 i 已经是 6 了。所以全部输出 6。"),Object(a.b)("p",null,"解决方法有：\n1. 使用 let (推荐)\n2. 使用闭包"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n    (function (i){\n        setTimeout(function timer() {\n            console.log(i)\n        }, i * 1000)\n    })(i);\n}\n")),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"使用 setTimeout 的第三个参数，它会当作 timer 函数的参数传入。")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"for (var i = 1; i <= 5; i++) {\n    setTimeout(function timer(i) {\n        console.log(i)\n    }, i * 1000, i)\n}\n")),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"深浅拷贝"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#深浅拷贝"}),"#"),"深浅拷贝"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？")),Object(a.b)("h3",null,Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"浅拷贝"})),Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#浅拷贝"}),"#"),"浅拷贝"),Object(a.b)("p",null,"浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。"),Object(a.b)("p",null,"1、 ",Object(a.b)("inlineCode",{parentName:"p"},"Object.assign"),"就是浅拷贝。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"let a = {\n  age: 1\n}\nlet b = Object.assign({}, a)\na.age = 2\nconsole.log(b.age) // 1\n")),Object(a.b)("p",null,"2、 ",Object(a.b)("inlineCode",{parentName:"p"},"..."),"也可以实现浅拷贝。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"let a = {\n  age: 1,\n  jobs: {\n    first: 'FE'\n  }\n}\nlet b = { ...a }\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // native\n")),Object(a.b)("p",null,"3、 自定义函数"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function copy(obj){\n    var n = {}\n    for(let i in obj){\n        n[i] = obj[i]\n    }\n    return n\n}\n")),Object(a.b)("p",null,"浅拷贝只解决了第一层的问题，如果深层还有对象，则会共享地址。所以在项目中，我一般使用深拷贝。"),Object(a.b)("h3",null,Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"深拷贝"})),Object(a.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#深拷贝"}),"#"),"深拷贝"),Object(a.b)("p",null,"深拷贝就是复制一个与原对象完全不相关的新对象。通常的实现方法有："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"JSON.parse(JSON.stringify(obj))"))),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"var a = {x: 1, y: {z: 3}}\nvar b = JSON.parse(JSON.stringify(a))\na.y.z = 4\nb.y.z // 3\n")),Object(a.b)("p",null,"但是这个方法有一些问题："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"如果属性值为 undefined 或 symbol，则会被忽略"),Object(a.b)("li",{parentName:"ul"},"不能序列化函数"),Object(a.b)("li",{parentName:"ul"},"不能解决循环引用的对象")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"let a = {\n  age: undefined,\n  sex: Symbol('male'),\n  jobs: function() {},\n  name: 'zs'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"zs\"}\n{name: \"zs\"}\n")),Object(a.b)("p",null,"不过对于一般业务代码，这个方法完全够用了。"),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},"使用",Object(a.b)("inlineCode",{parentName:"li"},"MessageChannel"))),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function structuralClone(obj) {\n    return new Promise(resolve => {\n      const { port1, port2 } = new MessageChannel()\n      port2.onmessage = ev => resolve(ev.data)\n      port1.postMessage(obj)\n    })\n  }\n  \n  var obj = {\n    a: 1,\n    b: {\n      c: 2\n    }\n  }\n  \n  obj.b.d = obj.b\n  \n  // 注意该方法是异步的\n  // 可以处理 undefined 和循环引用对象\n  const test = async () => {\n    const clone = await structuralClone(obj)\n    console.log(clone)\n  }\n  test()\n")),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"自己实现一个简单的深拷贝")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function deepClone(obj) {\n  function isObject(o) {\n    return (typeof o === 'object' || typeof o === 'function') && o !== null\n  }\n\n  if (!isObject(obj)) {\n    throw new Error('非对象')\n  }\n\n  let isArray = Array.isArray(obj)\n  let newObj = isArray ? [...obj] : { ...obj }\n  Reflect.ownKeys(newObj).forEach(key => {\n    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n  })\n\n  return newObj\n}\n\nlet obj = {\n  a: [1, 2, 3],\n  b: {\n    c: 2,\n    d: 3\n  }\n}\nlet newObj = deepClone(obj)\nnewObj.b.c = 1\nconsole.log(obj.b.c) // 2\n")),Object(a.b)("p",null," 原型链如何处理、DOM 如何处理"),Object(a.b)("ol",{start:4},Object(a.b)("li",{parentName:"ol"},"lodash 的深拷贝")),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"原型"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#原型"}),"#"),"原型"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：如何理解原型？如何理解原型链？")),Object(a.b)("p",null,"原型是实现面向对象的一种方式。可以通过原型将对象关联起来。"),Object(a.b)("p",null,Object(a.b)("img",l({parentName:"p"},{src:"/static/img/oop/2.webp",alt:null}))),Object(a.b)("p",null,"通过上图可以看出："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Foo 构造函数有一个",Object(a.b)("inlineCode",{parentName:"li"},"prototype"),"属性指向其原型 Foo.prototype，原型有一个",Object(a.b)("inlineCode",{parentName:"li"},"constructor"),"属性指向 Foo。"),Object(a.b)("li",{parentName:"ol"},"Foo 构造的实例 new Foo() 的",Object(a.b)("inlineCode",{parentName:"li"},"__proto__"),"属性指向 Foo 的原型。"),Object(a.b)("li",{parentName:"ol"},"所有对象都是 Object 类的实例。所有函数都是 Function 类的实例。"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"Object.prototype.__proto__"),"为 null。"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"Function.prototype.__proto__")," 为 Object.prototype。")),Object(a.b)("p",null,"注：",Object(a.b)("inlineCode",{parentName:"p"},"__proto__"),"不是标准属性，这只是浏览器在早期为了让我们访问到内部属性",Object(a.b)("inlineCode",{parentName:"p"},"[[prototype]]"),"来实现的一个东西。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"`函数.__proto__.constructor == Function`\nFunction instanceof Object\n\n`对象.__proto__.constructor == Object`\nObject instanceof Function\n")),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"map、filter、reduce"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#map、filter、reduce"}),"#"),"map、filter、reduce"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"map"),"和",Object(a.b)("inlineCode",{parentName:"p"},"filter"),"返回一个新数组"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"reduce"),"可以挨个处理数组的元素，最终返回一个值。"),Object(a.b)("h2",null,Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"实现call、apply-和-bind"})),Object(a.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#实现call、apply-和-bind"}),"#"),"实现call、apply 和 bind"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"面试题：call、apply 及 bind 函数内部实现是怎么样的？")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"Function.prototype.myCall = function (context) {\n    if (typeof this !== 'function') {\n        throw new TypeError(`Error`)\n    }\n    // 如果 context 是基本类型，需要是对象才能挂载 .fn 属性\n    context = typeof context === 'object' ? context || window : Object.create(null)\n    // 下面最好用 Symbol，因为如果原对象可能有fn属性，这样会被覆盖掉\n    context.fn = this\n    var args = [...arguments].slice(1)\n    // 谁调用，this 就是谁\n    var result = context.fn(...args)\n    delete context.fn\n    return result\n}\n\nFunction.prototype.myApply = function(context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  context = typeof context === 'object' ? context || window : Object.create(null)\n  context.fn = this\n  let result\n  // 处理参数和 call 有区别\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n  delete context.fn\n  return result\n}\n\nFunction.prototype.myBind = function (context) {\n    if (typeof this !== 'function') {\n        throw new TypeError('Error')\n    }\n    const args = [...arguments].slice(1)\n    context = typeof context === 'object' ? context || window : Object.create(null)\n    context.fn = this\n    return function () {\n        if (new.target) {\n            return new context.fn(...args, ...arguments)\n        }\n        return context.fn(...args, ...arguments)\n    }\n}\n")),Object(a.b)("p",null,"要注意 myBind 返回一个函数，可以通过普通方式和 new 调用。"))}s.isMDXComponent=!0},217:function(e,n,t){"use strict";t.d(n,"a",function(){return o}),t.d(n,"b",function(){return p});var a=t(0),l=t.n(a),r=l.a.createContext({}),c=function(e){var n=l.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=c(e.components);return l.a.createElement(r.Provider,{value:n},e.children)},b="mdxType",i={inlineCode:"code",wrapper:function(e){return l.a.createElement(l.a.Fragment,{},e.children)}},s=function(e){var n=e.components,t=e.mdxType,a=e.originalType,r=e.parentName,o=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),b=c(n);return l.a.createElement(b[r+"."+t]||b[t]||i[t]||a,n?Object.assign({},o,{components:n}):o)};function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,c=new Array(r);c[0]=s;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o[b]="string"==typeof e?e:a,c[1]=o;for(var p=2;p<r;p++)c[p]=t[p];return l.a.createElement.apply(null,c)}return l.a.createElement.apply(null,t)}s.displayName="MDXCreateElement"}}]);