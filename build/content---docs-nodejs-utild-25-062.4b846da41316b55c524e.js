(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{245:function(e,t,n){"use strict";n.d(t,"a",function(){return c}),n.d(t,"b",function(){return u});var a=n(0),l=n.n(a),b=l.a.createContext({}),r=function(e){var t=l.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},c=function(e){var t=r(e.components);return l.a.createElement(b.Provider,{value:t},e.children)};var i="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},o=function(e){var t=e.components,n=e.mdxType,a=e.originalType,b=e.parentName,c=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),i=r(t),o=n,u=i[b+"."+o]||i[o]||p[o]||a;return t?l.a.createElement(u,Object.assign({},c,{components:t})):l.a.createElement(u,c)};function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var b=n.length,r=new Array(b);r[0]=o;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[i]="string"==typeof e?e:a,r[1]=c;for(var u=2;u<b;u++)r[u]=n[u];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,n)}o.displayName="MDXCreateElement"},78:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return r}),n.d(t,"rightToc",function(){return c}),n.d(t,"default",function(){return o});n(0);var a=n(245);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function b(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},b=Object.keys(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var r={title:"NodeJS Util",sidebar_label:"Util"},c=[{value:"Util",id:"util",children:[{value:"URL",id:"url",children:[]},{value:"Query String",id:"query-string",children:[]},{value:"util",id:"util-1",children:[]},{value:"正则表达式",id:"正则表达式",children:[]},{value:"常用模块",id:"常用模块",children:[]}]},{value:"网络",id:"网络",children:[]},{value:"模块",id:"模块",children:[]},{value:"IO",id:"io",children:[{value:"Buffer",id:"buffer",children:[]},{value:"String Decoder",id:"string-decoder",children:[]},{value:"Stream",id:"stream",children:[]},{value:"Console",id:"console",children:[]},{value:"File System",id:"file-system",children:[]},{value:"Readline",id:"readline",children:[]},{value:"REPL",id:"repl",children:[]},{value:"参考资料",id:"参考资料",children:[]}]},{value:"错误处理",id:"错误处理",children:[{value:"V8",id:"v8",children:[]},{value:"内存快照",id:"内存快照",children:[]}]},{value:"OS",id:"os",children:[{value:"TTY",id:"tty",children:[]},{value:"什么是 TTY ?",id:"什么是-tty-",children:[]},{value:"OS模块",id:"os模块",children:[]},{value:"os 常量",id:"os-常量",children:[]}]},{value:"Path",id:"path",children:[{value:"不同平台，路径的区别?",id:"不同平台，路径的区别",children:[]},{value:"path对象的解析？",id:"path对象的解析？",children:[]},{value:"path.extname(path)",id:"pathextnamepath",children:[]},{value:"命令行参数",id:"命令行参数",children:[]},{value:"环境变量",id:"环境变量",children:[]},{value:"负载",id:"负载",children:[]},{value:"CheckList",id:"checklist",children:[]},{value:"物理资源",id:"物理资源",children:[]}]}],i={rightToc:c},p="wrapper";function o(e){var t=e.components,n=b(e,["components"]);return Object(a.b)(p,l({},i,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"util"},"Util"),Object(a.b)("p",null,"util这部分主要涉及的内容如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"URL"),Object(a.b)("li",{parentName:"ul"},"Query String"),Object(a.b)("li",{parentName:"ul"},"util模块"),Object(a.b)("li",{parentName:"ul"},"正则表达式"),Object(a.b)("li",{parentName:"ul"},"node常用模块")),Object(a.b)("h3",{id:"url"},"URL"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"说说url组成部分，要求一个不漏的说出来？")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),'┌─────────────────────────────────────────────────────────────────────────────┐\n│                                    href                                     │\n├──────────┬┬───────────┬─────────────────┬───────────────────────────┬───────┤\n│ protocol ││   auth    │      host       │           path            │ hash  │\n│          ││           ├──────────┬──────┼──────────┬────────────────┤       │\n│          ││           │ hostname │ port │ pathname │     search     │       │\n│          ││           │          │      │          ├─┬──────────────┤       │\n│          ││           │          │      │          │ │    query     │       │\n"  http:   // user:pass @ host.com : 8080   /p/a/t/h  ?  query=string   #hash "\n│          ││           │          │      │          │ │              │       │\n└──────────┴┴───────────┴──────────┴──────┴──────────┴─┴──────────────┴───────┘\n')),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},"关于url转义字符，为什么需要转义。")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"Array(range).fill(0)\n  .map((_, i) => String.fromCharCode(i))\n  .map(encodeURI)\n")),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"url模块常用的方法。")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"const url = require('url')\nconst str = `http://username:password@localhost:3000/pathname?query=1#hash`\nconsole.log(url.parse(str, true))\n\n/*\nUrl {\n  protocol: 'http:',\n  slashes: true,\n  auth: 'username:password',\n  host: 'localhost:3000',\n  port: '3000',\n  hostname: 'localhost',\n  hash: '#hash',\n  search: '?query=1',\n  query: [Object: null prototype] { query: '1' },\n  pathname: '/pathname',\n  path: '/pathname?query=1',\n  href: 'http://username:password@localhost:3000/pathname?query=1#hash'\n}\n*/\n")),Object(a.b)("p",null,"decodeURI"),Object(a.b)("h3",{id:"query-string"},"Query String"),Object(a.b)("p",null,"query string是URL的一部分，就是url?后面",Object(a.b)("inlineCode",{parentName:"p"},"name=zs&age=12"),"这样一串字符。node里内置了querystring模块用来解析它，还有第三方模块qs可以解析它。"),Object(a.b)("p",null,"querystring的常用方法："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},".parse(str[, sep[, eq[, options]]])"),": 将query string解析为json对象。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},".unescape(str)"),": "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},".stringify(obj[, sep[, eq[, options]]])"),": 将json对象转成query string。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},".escape(str)"))),Object(a.b)("p",null,"自己试一试每个方法。querystring模块对深度结构的对象还不支持。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"const querystring = require('querystring')\nconst qs = require('qs')\n\nlet obj = {a : { b : 1 } }\nquerystring.stringify(obj) // 'a='\nqs.stringify(obj)         // a%5Bb%5D=1  即 a[b]=1\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"HTTP 如何通过 GET 方法 (URL) 传递 let arr = ","[1,2,3,4]"," 给服务器?")),Object(a.b)("p",null,"这个很简单，我们向后端提交表单的时候，多个字段需要是",Object(a.b)("inlineCode",{parentName:"p"},'name="name[]"'),"这种形式。所以只需要",Object(a.b)("inlineCode",{parentName:"p"},"https://your.host/api/?arr[0]=1&arr[1]=2&arr[2]=3&arr[3]=4"),"即可。"),Object(a.b)("h3",{id:"util-1"},"util"),Object(a.b)("p",null,"util模块是node的内置模块，提供了一些工具方法。这里很多方法都要会用且会实现原理。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"util.inherits()"))),Object(a.b)("h3",{id:"正则表达式"},"正则表达式"),Object(a.b)("p",null,"这个不多说了，见："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"/f2e/regexp-1"}),"精通正则表达式之理论与实战")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"/f2e/regexp-2"}),"精通正则表达式之正则引擎原理"))),Object(a.b)("h3",{id:"常用模块"},"常用模块"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://github.com/sindresorhus/awesome-nodejs"}),"Awesome Node.js")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://www.npmjs.com/browse/depended"}),"Most depended-upon packages"))),Object(a.b)("p",null,"上面的这些常用库首先要知道每个库的用途，然后在平时要用到的时候多用一用。"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"写段代码获取某个文件夹下所有的文件名？")),Object(a.b)("h2",{id:"网络"},"网络"),Object(a.b)("h2",{id:"模块"},"模块"),Object(a.b)("p",null,"模块涉及到的知识有："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"模块机制"),Object(a.b)("li",{parentName:"ul"},"热更新"),Object(a.b)("li",{parentName:"ul"},"上下文"),Object(a.b)("li",{parentName:"ul"},"包管理")),Object(a.b)("h2",{id:"io"},"IO"),Object(a.b)("p",null,"IO涉及到的知识："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Buffer"),Object(a.b)("li",{parentName:"ul"},"String Decoder"),Object(a.b)("li",{parentName:"ul"},"Stream"),Object(a.b)("li",{parentName:"ul"},"Console"),Object(a.b)("li",{parentName:"ul"},"File System "),Object(a.b)("li",{parentName:"ul"},"Readline"),Object(a.b)("li",{parentName:"ul"},"REPL")),Object(a.b)("h3",{id:"buffer"},"Buffer"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"linux 里的 buffer 是写缓存，数据存储时，先保存到磁盘缓冲区，然后再写入到永久空间。cache 读缓存，数据从磁盘读出后，暂留在缓冲区，预备程序接下来的使用。")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Buffer 一般用于处理什么数据? 其长度能否动态变化? ")),Object(a.b)("p",null,"Buffer 是 Node.js 中用来处理二进制数据的类，其中与 IO 相关的操作(网络/文件等)均基于 Buffer。Buffer类的实例非常类似从 0-255 之间整数数组(其它整数会通过&255强制转到此范围)，但其大小是固定不变的，且其内存在 V8 堆栈外分配原始内存空间。Buffer 的大小在创建时确定，且无法更改。"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"为什么 new Buffer() 从6.x开始废弃？")),Object(a.b)("p",null,"参数类型不同会返回不同类型的 Buffer 对象，所以如果开发者没有正确校验参数或没有正确初始化 Buffer 对象的内容时，就会不经意向代码中引入安全性或可靠性问题。"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"接口"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"用途"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Buffer.from()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"根据已有数据生成一个 Buffer 对象")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Buffer.alloc()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"创建一个初始化后的 Buffer 对象")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Buffer.allocUnsafe()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"创建一个未初始化的 Buffer 对象")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Buffer.concat(list","[, totalLength]",")"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"合并 Buffer 对象")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"buf.copy(target[, targetStart[, sourceStart","[, sourceEnd]","]])"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"拷贝buffer")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"buf.slice()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"浅拷贝，即引用")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"buf.forEach()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"遍历")))),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"实现concat、copy、split方法")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"Buffer.concat = function(bufferList,len=bufferList.reduce((a,b)=>a+b.length,0)){\n    let buffer = Buffer.alloc(len);\n    let offset = 0;\n    bufferList.forEach(buf=>{\n        buf.copy(buffer,offset);\n        offset += buf.length;\n    })\n    return buffer;\n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"TypedArray")),Object(a.b)("p",null,"Node.js 的 Buffer 在 ES6 增加了 TypedArray 类型后，修改了原来的 Buffer 实现，选择基于 TypedArray 中 Uint8Array 来实现，从而提高性能。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"var arr = new Uint16Array(2)\narr[0] = 5000\narr[1] = 4000\nconsole.log(arr) // Uint16Array [ 5000, 4000 ]\n\n//  拷贝buffer\nconst buf1 = Buffer.from(arr)\nconsole.log(buf1)  // <Buffer 88 a0> \n// 88 -> 8*16+8 -> 136 = 5000&255\n// a0 -> 10*16 -> 160 = 4000&255\nconsole.log(arr.buffer)  // ArrayBuffer { [Uint8Contents]: <88 13 a0 0f>, byteLength: 4 }\n\n// 与buffer共享内存\nconst buf2 = Buffer.from(arr.buffer)\nconsole.log(buf2)  // <Buffer 88 13 a0 0f>\n// 1 * 16 + 3 = 19 -> 154  \n\n// 是引用，可以改变\narr[1] = 6000\nconsole.log(buf1);\n// 输出: <Buffer 88 a0>\nconsole.log(buf2);\n// 输出: <Buffer 88 13 70 17>\n")),Object(a.b)("h3",{id:"string-decoder"},"String Decoder"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"string_decoder"),"模块用于将 Buffer 对象解码成字符串，是对 ",Object(a.b)("inlineCode",{parentName:"p"},".toString()")," 的补充。支持 utf8 和 utf16 解码。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"write()"),": 这个方法会将 Buffer 写到缓存，并取出缓存中完整的部分字节。剩余不完整的留在缓存中。下次如果 write 传入剩余的字节，它就会返回。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"end()"),": 将缓存中的剩余字节一次性解码成字符串返回。")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"const {\n    StringDecoder\n} = require('string_decoder')\nconst decoder = new StringDecoder('utf8')\n\nconsole.log(Buffer.from('你好啊')) // <Buffer e4 bd a0 e5 a5 bd e5 95 8a>\n\n// 1) 首先 write 四个字节，前三个字节组成 `你`，剩下 `好` 的一部分字节 0xe5\nconst str1 = decoder.write(Buffer.from([0xe4, 0xbd, 0xa0, 0xe5]))\nconsole.log(str1) // 你\n\n// 2) 再次传入 `好` 的剩余字节\nconst str2 = decoder.write(Buffer.from([0xa5, 0xbd]))\nconsole.log(str2) // 好\n\n// 3) 调用 end() 时如果传入的字节不完整\nconst str3 = decoder.end(Buffer.from([0xe5]))\nconsole.log(str3) // �   \nconsole.log(Buffer.from(str3)) // <Buffer ef bf bd>\n")),Object(a.b)("h3",{id:"stream"},"Stream"),Object(a.b)("p",null,"Stream 流一般用于大文件任务，只需要用很小的内存就能完成大文件的拷贝。流的类型："),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"类"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"使用场景"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"重写方法"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Readable"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"只读"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"_read")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Writeable"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"只写"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"_write")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Duplex"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"读写"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"_read, _write")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"Transform"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"操作被写入数据，然后读出结果"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"_transform, _flush")))),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"对象模式")),Object(a.b)("p",null,"通过 Node API 创建的流，只能操作字符串或 buffer。但流的实现可以基于其它 js 类型(除了 null，它在流中有特殊含义，表示流的结束)。这样的流就处于",Object(a.b)("inlineCode",{parentName:"p"},"对象模式(objectMode)"),"中。在创建流对象的时候，可以通过提供",Object(a.b)("inlineCode",{parentName:"p"},"objectMode"),"参数来生成对象模式的流。试图将现有流转为对象模式是不安全的。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"缓冲区")),Object(a.b)("p",null,"读取的数据放入缓冲区，等待写入。Readable、Writeable 流都会将数据存入内部缓冲区，缓冲区可以分别通过 ",Object(a.b)("inlineCode",{parentName:"p"},"writeable._writeableState.getBuffer()"),"和",Object(a.b)("inlineCode",{parentName:"p"},"readable._readableState.buffer"),"来访问。缓冲区大小由构造 stream 时的 hignWaterMark 标识指定可缓存多少字节，对于",Object(a.b)("inlineCode",{parentName:"p"},"objectMode"),"的 stream，该标志表示可容纳的对象个数。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"可读流"),"\n",Object(a.b)("strong",{parentName:"p"},"可写流"),"\n",Object(a.b)("strong",{parentName:"p"},"Duplex 和 Transform"),"\n",Object(a.b)("strong",{parentName:"p"},"pipe")),Object(a.b)("h3",{id:"console"},"Console"),Object(a.b)("h3",{id:"file-system"},"File System"),Object(a.b)("p",null,"“一切皆是文件”是 Unix/Linux 的基本哲学之一, 不仅普通的文件、目录、字符设备、块设备、套接字等在 Unix/Linux 中都是以文件被对待, 也就是说这些资源的操作对象均为 fd (文件描述符), 都可以通过同一套 system call 来读写. 在 linux 中你可以通过 ulimit 来对 fd 资源进行一定程度的管理限制."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"编码")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"UTF8, GBK, es6 中对编码的支持, 如何计算一个汉字的长度?")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"stdio")),Object(a.b)("p",null,"stdio (standard input output) 标准的输入输出流, 即输入流 (stdin), 输出流 (stdout), 错误流 (stderr) 三者. 在 Node.js 中分别对应 ",Object(a.b)("inlineCode",{parentName:"p"},"process.stdin")," (Readable), ",Object(a.b)("inlineCode",{parentName:"p"},"process.stdout")," (Writable) 以及 ",Object(a.b)("inlineCode",{parentName:"p"},"process.stderr")," (Writable) 三个 stream."),Object(a.b)("p",null,"其中的 stream 则是指 stdout (输出流). 实际上在 shell 上运行一个应用程序的时候, shell 做的第一个操作是 fork 当前 shell 的进程 (所以, 如果你通过 ps 去查看你从 shell 上启动的进程, 其父进程 pid 就是当前 shell 的 pid), 在这个过程中也把 shell 的 stdio 继承给了你当前的应用进程, 所以你在当前进程里面将数据写入到 stdout, 也就是写入到了 shell 的 stdout, 即在当前 shell 上显示了."),Object(a.b)("p",null,"输入也是同理, 当前进程继承了 shell 的 stdin, 所以当你从 stdin 中读取数据时, 其实就获取到你在 shell 上输入的数据"),Object(a.b)("p",null,"当你使用 ssh 在远程服务器上运行一个命令的时候, 在服务器上的命令输出虽然也是写入到服务器上 shell 的 stdout, 但是这个远程的 shell 是从 sshd 服务上 fork 出来的, 其 stdout 是继承自 sshd 的一个 fd, 这个 fd 其实是个 socket, 所以最终其实是写入到了一个 socket 中, 通过这个 socket 传输你本地的计算机上的 shell 的 stdout."),Object(a.b)("p",null,"如果你理解了上述情况, 那么你也就能理解为什么守护进程需要关闭 stdio, 如果切到后台的守护进程没有关闭 stdio 的话, 那么你在用 shell 操作的过程中, 屏幕上会莫名其妙的多出来一些输出. "),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{}),"for (; i < getdtablesize(); ++i) {\n   close(i);  // 关闭打开的 fd\n}\n")),Object(a.b)("p",null,"Linux/unix 的 fd 都被设计为整型数字, 从 0 开始. 你可以尝试运行如下代码查看."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"console.log(process.stdin.fd); // 0\nconsole.log(process.stdout.fd); // 1\nconsole.log(process.stderr.fd); // 2\n")),Object(a.b)("p",null,"在上一节中的 在 IPC 通道建立之前, 父进程与子进程是怎么通信的? 如果没有通信, 那 IPC 是怎么建立的? 中使用环境变量传递 fd 的方法, 这么看起来就很直白了, 因为传递 fd 其实是直接传递了一个整型数字."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"如何同步的获取用户的输入?")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"/*\n * http://stackoverflow.com/questions/3430939/node-js-readsync-from-stdin\n * @mklement0\n */\nvar fs = require('fs');\n\nvar BUFSIZE = 256;\nvar buf = new Buffer(BUFSIZE);\nvar bytesRead;\n\nmodule.exports = function() {\n  var fd = ('win32' === process.platform) ? process.stdin.fd : fs.openSync('/dev/stdin', 'rs');\n  bytesRead = 0;\n\n  try {\n    bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);\n  } catch (e) {\n    if (e.code === 'EAGAIN') { // 'resource temporarily unavailable'\n      // Happens on OS X 10.8.3 (not Windows 7!), if there's no\n      // stdin input - typically when invoking a script without any\n      // input (for interactive stdin input).\n      // If you were to just continue, you'd create a tight loop.\n      console.error('ERROR: interactive stdin input not supported.');\n      process.exit(1);\n    } else if (e.code === 'EOF') {\n      // Happens on Windows 7, but not OS X 10.8.3:\n      // simply signals the end of *piped* stdin input.\n      return '';\n    }\n    throw e; // unexpected exception\n  }\n\n  if (bytesRead === 0) {\n    // No more stdin input available.\n    // OS X 10.8.3: regardless of input method, this is how the end \n    //   of input is signaled.\n    // Windows 7: this is how the end of input is signaled for\n    //   *interactive* stdin input.\n    return '';\n  }\n  // Process the chunk read.\n\n  var content = buf.toString(null, 0, bytesRead - 1);\n\n  return content;\n};\n")),Object(a.b)("h3",{id:"readline"},"Readline"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"readline")," 模块提供了一个用于从 Readable 的 stream(如 process.stdin)中一次读取一行的接口。常用的场景有日志分析、自动完成、命令行工具问答。"),Object(a.b)("p",null,"学习",Object(a.b)("a",l({parentName:"p"},{href:"https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/readline.md"}),"readline资料"),"后，自己再实现一遍："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"实现命令行输入字母，自动转大写输出。"),Object(a.b)("li",{parentName:"ol"},"日志读取"),Object(a.b)("li",{parentName:"ol"},"代码提示"),Object(a.b)("li",{parentName:"ol"},"实现npmt init")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Readline 是如何实现的? (有思路即可) ")),Object(a.b)("p",null,"realine 在读取 TTY 的数据时, 是通过 ",Object(a.b)("inlineCode",{parentName:"p"},"input.on('keypress', onkeypress)")," 时发现用户按下了回车键来判断是新的 line 的, 而读取一般的 stream 时, 则是通过缓存数据然后用正则 .test 来判断是否为 new line 的."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"什么叫 IO, 什么又叫 IO 密集型业务?\nStream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是?\nStream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递?\n什么是文件描述符? 输入流/输出流/错误流是什么?\nconsole.log 是同步还是异步? 如何实现一个 console.log?\n如何同步的获取用户的输入? ")),Object(a.b)("h3",{id:"repl"},"REPL"),Object(a.b)("p",null,"Read-Eval-Print-Loop (REPL)"),Object(a.b)("h3",{id:"参考资料"},"参考资料"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://github.com/chyingp/nodejs-learning-guide"}),"Nodejs基础：巧用string_decoder将buffer转成string"))),Object(a.b)("h2",{id:"错误处理"},"错误处理"),Object(a.b)("p",null,"错误处理/调试部分主要涉及的内容如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Errors(异常)"),Object(a.b)("li",{parentName:"ul"},"Domain(域)"),Object(a.b)("li",{parentName:"ul"},"Debugger(调试器)"),Object(a.b)("li",{parentName:"ul"},"C/C++ 插件"),Object(a.b)("li",{parentName:"ul"},"V8"),Object(a.b)("li",{parentName:"ul"},"内存快照"),Object(a.b)("li",{parentName:"ul"},"CPU profiling(CPU剖析)")),Object(a.b)("h3",{id:"v8"},"V8"),Object(a.b)("p",null,"暂时看不懂，跳过"),Object(a.b)("h3",{id:"内存快照"},"内存快照"),Object(a.b)("h2",{id:"os"},"OS"),Object(a.b)("p",null,"OS 这部分主要涉及的内容如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"TTY"),Object(a.b)("li",{parentName:"ul"},"OS"),Object(a.b)("li",{parentName:"ul"},"命令行参数"),Object(a.b)("li",{parentName:"ul"},"负载"),Object(a.b)("li",{parentName:"ul"},"CheckList"),Object(a.b)("li",{parentName:"ul"},"指标")),Object(a.b)("h3",{id:"tty"},"TTY"),Object(a.b)("h3",{id:"什么是-tty-"},"什么是 TTY ?"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"tty"),"原意是 teletype 打字机，",Object(a.b)("inlineCode",{parentName:"p"},"pty"),"则是 pseudo-teletype 伪打字机，在 unix 中，",Object(a.b)("inlineCode",{parentName:"p"},"/dev/tty*"),"指任何表现像打字机的设备，例如终端。"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"如何查看一个进程是通过 TTY 启动的？")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"w")," 命令可以查看当前登陆的用户情况，每登陆一个窗口就有一个 TTY。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"ps -x"),"命令查看进程信息中也有 TTY 的信息。",Object(a.b)("inlineCode",{parentName:"li"},"?")," 表示没有依赖 TTY 的进程，即守护进程。")),Object(a.b)("p",null,"可以通过",Object(a.b)("inlineCode",{parentName:"p"},"stdio.isTTY"),"判断当前进程是否处于 TTY 环境。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{}),'node -p -e "Boolean(process.stdout.isTTY)" | cat\n')),Object(a.b)("h3",{id:"os模块"},"OS模块"),Object(a.b)("p",null,"通过 os 模块可以获取当前操作系统的一些基础信息。"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"属性"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"描述"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.EOL"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回当前系统的",Object(a.b)("inlineCode",{parentName:"td"},"end of line"))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.arch"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回当前系统CPU架构，如",Object(a.b)("inlineCode",{parentName:"td"},"x86"),"或",Object(a.b)("inlineCode",{parentName:"td"},"x64"))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.constants"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回系统常量")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.cpus()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回每个核的信息")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.endianness()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回 CPU 字节序，如果大端字节序返回 ",Object(a.b)("inlineCode",{parentName:"td"},"BE"),"，小端字节序则 ",Object(a.b)("inlineCode",{parentName:"td"},"LE"))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.freemen()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回系统空闲内存大小，单位是字节")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.homedir()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回当前用户的根目录")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.hostname()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回当前系统的主机名")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.loadavg()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回负载信息")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.networkInterfaces"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回网卡信息(类似 ",Object(a.b)("inlineCode",{parentName:"td"},"ifconfig"),")")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.platform()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回编译时指定的平台信息，如",Object(a.b)("inlineCode",{parentName:"td"},"win32"),"，",Object(a.b)("inlineCode",{parentName:"td"},"linux"),"，同",Object(a.b)("inlineCode",{parentName:"td"},"process.platform()"))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.release()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"操作系统的分发版本号")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.tmpdir()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"系统默认的临时文件夹")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.totalmem()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回总内存大小")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.type()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"根据",Object(a.b)("inlineCode",{parentName:"td"},"[uname](https://en.wikipedia.org/wiki/Uname#Examples)"),"返回系统的名称")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.uptime()"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回系统的运行时间，单位是秒")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"os.userInfo(","[options]",")"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"返回当前用户信息")))),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"不同操作系统的换行符(EOL)有什么区别？")),Object(a.b)("p",null,"end of line(EOL) 同 newline，line ending，以及line break。\n通常由 line feed(LF, ",Object(a.b)("inlineCode",{parentName:"p"},"\\n"),") 和 carriage return (CR，",Object(a.b)("inlineCode",{parentName:"p"},"\\r"),")组成。windows 用的",Object(a.b)("inlineCode",{parentName:"p"},"\\r\\n"),"，mac os9之前用的",Object(a.b)("inlineCode",{parentName:"p"},"\\r"),"，mac os X 及 linux用的\\n`。"),Object(a.b)("h3",{id:"os-常量"},"os 常量"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"信号常量"),Object(a.b)("li",{parentName:"ul"},"POSIX 错误常量(POSIX Error Constants): 如 EACCES，EADDRINUSE 等。"),Object(a.b)("li",{parentName:"ul"},"Windows 错误常量(Windows Specific Error Constants)，如 WSAEACCESS，WSAEBADF 等。"),Object(a.b)("li",{parentName:"ul"},"libuv 常量(libuv Constants)，仅 UV_UDP_REUSEADDR。")),Object(a.b)("h2",{id:"path"},"Path"),Object(a.b)("h3",{id:"不同平台，路径的区别"},"不同平台，路径的区别?"),Object(a.b)("p",null,"每个平台路径形式不同，path 模块的方法就是对应平台的方法，如 mac 平台下。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"const path = require('path');\nconsole.log(path.basename === path.posix.basename); // true\n")),Object(a.b)("h3",{id:"path对象的解析？"},"path对象的解析？"),Object(a.b)("p",null,"on POSIX:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),'path.parse(\'/home/user/dir/file.txt\')\n// Returns:\n// {\n//    root : "/",\n//    dir : "/home/user/dir",\n//    base : "file.txt",\n//    ext : ".txt",\n//    name : "file"\n// }\n')),Object(a.b)("p",null,"on Windows:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),'path.parse(\'C:\\\\path\\\\dir\\\\file.txt\')\n// Returns:\n// {\n//    root : "C:\\\\",\n//    dir : "C:\\\\path\\\\dir",\n//    base : "file.txt",\n//    ext : ".txt",\n//    name : "file"\n// }\n')),Object(a.b)("h3",{id:"pathextnamepath"},"path.extname(path)"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"case"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"return"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"path.extname('index.html')"),Object(a.b)("td",l({parentName:"tr"},{align:null}),".html")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"path.extname('index.coffee.md')"),Object(a.b)("td",l({parentName:"tr"},{align:null}),".md")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"path.extname('index.')"),Object(a.b)("td",l({parentName:"tr"},{align:null}),".")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"path.extname('index')"),Object(a.b)("td",l({parentName:"tr"},{align:null}))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"path.extname('.index')"),Object(a.b)("td",l({parentName:"tr"},{align:null}))))),Object(a.b)("h3",{id:"命令行参数"},"命令行参数"),Object(a.b)("p",null,"命令行参数(Command Line Options)，即对 CLI 使用上的一些文档。关于 CLI 主要有 4 种使用方式。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"node ","[options][v8 options]"," ",'[script.js | -e "script"][arguments]'," "),Object(a.b)("li",{parentName:"ul"},"node debug ",'[script.js | -e "script" | :]'," ..."),Object(a.b)("li",{parentName:"ul"},"node --v8-options"),Object(a.b)("li",{parentName:"ul"},"无参数直接启动 REPL (Read Eval Print Loop:交互式解释器)环境")),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"参数"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"简介"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"-v,--version"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"查看当前 node 版本")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"-h --help"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"查看帮助文档")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),'-e,--eval "script"'),Object(a.b)("td",l({parentName:"tr"},{align:null}),"将参数字符串当作代码执行")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),'-p,--print "script"'),Object(a.b)("td",l({parentName:"tr"},{align:null}),"打印 -e 的返回值，",Object(a.b)("inlineCode",{parentName:"td"},"node -pe '1+1'"))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"-c,--check"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"检查语法不执行")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"-i,--interactive"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"即使 stdin 不是终端也打开 REPL 模式")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"-r,--require module"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"在启动前预先 require 指定模块")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--no-deprecation"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"关闭废弃模块警告")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--trace-deprecation"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"打印废弃模块的堆栈跟踪信息")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--throw-deprecation"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"执行废弃模块时抛出错误")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--no-warnings"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"无视报警(包括废弃模块)")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--trace-sync-io"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"只要检测到异步 I/O 处于 Event Loop 的开头就打印堆栈信息")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--zero-fill-buffers"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"自动初始化(zero-fill) Buffer 和 SlowBuffer")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--preserve-symlinks"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"在解析和缓存模块时指示模块加载程序保存符号链接")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--track-heap-objects"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"为堆快照跟踪对象的分配情况")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--prof-process"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"使用 v8 选项 ",Object(a.b)("inlineCode",{parentName:"td"},"--prof")," 生成 Profilling 报告")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--v8-options"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"显示 v8 命令行选项")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--tls-cipher-list=list"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"指明替代的默认 TLS 加密器列表")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--enable-fips"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"在启动时开启 FIPS-compliant crypto")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--force-fips"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"在启动时强制实施 FIPS-compliant")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--openssl-config=file"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"启动时加载 OpenSSL 配置文件")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"--icu-data-dir=file"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"指定 ICU 数据加载路径")))),Object(a.b)("h3",{id:"环境变量"},"环境变量"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"环境变量"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"简介"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_DEBUG=module[,...]")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"指定要打印调试信息的核心模块列表")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_PATH=path[:...]")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"指定搜索目录模块路径的前缀列表")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_DISABLE_COLORS=1")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"关闭 REPL 的颜色显示")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_ICU_DATA=file")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"ICU(Intl Object)的数据路径")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_REPL_HISTORY=file")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"持久化存储 REPL 历史文件的路径")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_TTY_UNSAFE_ASYNC=1")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"设置为1时，将同步操作 stdio (如console.log变成同步)")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_EXTRA_CA_CERTS=file")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"指定 CA (如 VeriSync) 的额外证书路径")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"NODE_NO_WARNINGS=1")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"设置为1时，不会提示警告")))),Object(a.b)("h3",{id:"负载"},"负载"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"什么是负载？怎么查看？不同值的负载表示什么？")),Object(a.b)("p",null,"负载是衡量服务器运行状态的一个重要概念，通过负载情况，可以知道服务器目前是清闲，良好，繁忙还是即将 crash。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"系统负载（System Load）是系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度（进程等待队列的长度）。"),Object(a.b)("li",{parentName:"ul"},"平均负载（Load Average）是一段时间内系统的平均负载，这个一段时间一般取1分钟、5分钟、15分钟。")),Object(a.b)("p",null,"命令行可以通过 ",Object(a.b)("inlineCode",{parentName:"p"},"uptime"),", ",Object(a.b)("inlineCode",{parentName:"p"},"top"),"命令，node.js 中可以通过 ",Object(a.b)("inlineCode",{parentName:"p"},"os.loadavg()")," 来获取当前系统的平均负载情况。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{}),"> os.loadavg()\n[ 3.13134765625, 3.01953125, 3.04296875 ]\n")),Object(a.b)("p",null,"分别是最近1分钟、5分钟、15分钟系统 CPU 的平均负载，当 CPU 的一个核工作饱和的时候负载为 1，有几个核 CPU 的饱和负载就是几。我的电脑是 8 核，所以一分钟平均 Load 约等于 3.13134765625/8=0.39。"),Object(a.b)("p",null,"在 nodejs 中查看单个进程的 CPU 负载可以使用 ",Object(a.b)("a",l({parentName:"p"},{href:"https://github.com/soyuka/pidusage"}),"pidusage")," 模块。"),Object(a.b)("p",null,"单核 CPU，不同的 Load 值："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Load < 0.7时：系统很闲，要考虑多部署一些服务"),Object(a.b)("li",{parentName:"ul"},"0.7 < Load < 1时：系统状态不错"),Object(a.b)("li",{parentName:"ul"},"Load == 1时：系统马上要处理不多来了，赶紧找一下原因修复"),Object(a.b)("li",{parentName:"ul"},"Load > 5时：系统已经非常繁忙了")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"如何知道我的系统有多少核心?")),Object(a.b)("p",null,"除了 CPU 负载, 对于服务端 (偏维护) 还需要了解网络负载, 磁盘负载等。"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"CPU 负载和 CPU 使用率的区别？低利用率意味着没有负载吗？")),Object(a.b)("p",null,"它们是从不同角度来描述 CPU 使用情况的。负载是从进程数上描述的，使用率是从时间上来描述的。比如银行工作人员，负载是很多客户排队，使用率是处理客户的有效时间(工作人员的等待时间不算在内如打印身份证等不算在内)/总时间。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"http://www.blogjava.net/cenwenchu/archive/2008/06/30/211712.html"}),"理解Load Average做好压力测试"))),Object(a.b)("p",null,"资料："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://www.w3cschool.cn/architectroad/architectroad-loadaverage.html"}),"一分钟理解负载LoadAverage")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages"}),"Understanding Linux CPU Load"))),Object(a.b)("h3",{id:"checklist"},"CheckList"),Object(a.b)("p",null,"USE 方法用来完整评估的服务器的状态。即对系统中的每种资源都检查使用率(usage)、饱和度(saturation)和错误(errors)。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"资源：所有物理服务器功能组件(CPU、磁盘、总线...)")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"利用率：资源忙于工作的平均时间，用一段时间内的百分比描述")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"饱和度(负载)：资源具有无法服务的额外工作的程度，如 loadavg 用队列长度来描述。")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"错误：错误的数量")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("a",l({parentName:"p"},{href:"http://www.brendangregg.com/USEmethod/use-linux.html"}),"USE 方法")))),Object(a.b)("h3",{id:"物理资源"},"物理资源"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"部件"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"类型"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"衡量"))),Object(a.b)("tbody",{parentName:"table"})),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"ulimit 是用来干什么的?")),Object(a.b)("p",null,"ulimit 命令用于管理用户对资源的使用情况。"))}o.isMDXComponent=!0}}]);