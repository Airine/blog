(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{171:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return b}),n.d(t,"rightToc",function(){return c}),n.d(t,"default",function(){return o});n(0);var a=n(301);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var b={id:"v8",title:"V8 引擎原理"},c=[{value:"内存泄露",id:"内存泄露",children:[]},{value:"垃圾回收机制",id:"垃圾回收机制",children:[{value:"标记清除算法",id:"标记清除算法",children:[]},{value:"引用计数（不常用）",id:"引用计数（不常用）",children:[]}]},{value:"面试题",id:"面试题",children:[]},{value:"参考资料",id:"参考资料",children:[]}],i={rightToc:c},p="wrapper";function o(e){var t=e.components,n=r(e,["components"]);return Object(a.b)(p,l({},i,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:""}),Object(a.b)("p",null,"js 是一种弱类型、动态语言。所谓弱类型是指支持隐式转换，不支持的叫做强类型。"),Object(a.b)("p",null,"变量使用前需要确认变量类型的叫做静态语言，执行过程中需要检查类型的叫做动态语言。"),Object(a.b)("p",null,"也就是说 js 执行过程中变量类型会隐式转换。\n弱类型表示不需要告诉 js 变量是什么类型的，它运行时会自己计算出来。\n动态表示可以给变量赋不同类型的值。"),Object(a.b)("h2",{id:"内存泄露"},"内存泄露"),Object(a.b)("p",null,"内存泄露(Memory Leak)是指程序中动态分配的内存没有释放，造成系统内存浪费，导致程序运行变慢，甚至系统崩溃等严重后果。"),Object(a.b)("p",null,"有些语言(如 C 语言)，需要程序员手动释放和管理内存。这很麻烦，所以大多数语言提供了自动内存管理，这叫",Object(a.b)("inlineCode",{parentName:"p"},"垃圾回收机制(garbage collector，GC)"),"。"),Object(a.b)("p",null,"ESP 指针切换时，上层执行栈就变为不可用了，后面的执行栈上下文会直接覆盖之前的。\nv8将堆分为新生代和老生代，新生代存存活时间短的对象，新生代只有是1-8M，老生代存生存周期长的数据。"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"标记活动对象和非活动对象"),Object(a.b)("li",{parentName:"ol"},"回收非活动对象的空间"),Object(a.b)("li",{parentName:"ol"},"内存整理")),Object(a.b)("p",null,"副垃圾回收期: 负责新生代"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Scavenge 算法\n- 将新生区分为 对象区域和空闲区域\n- 对象区域写满后，会进行垃圾回收，标记后，将活动对象复制到空闲区域，然后反转。复制的时候可以一个个排列，所以后面没有内存碎片。 对象晋升策略。对于两次垃圾回收还存活的对象，会移动到老生区中。\n主垃圾回收期：负责老生代"),Object(a.b)("li",{parentName:"ul"},"标记清除算法",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"遍历执行栈，从根元素出发，标记可到达元素，就是活动元素，没有到达的就是垃圾数据"),Object(a.b)("li",{parentName:"ul"},"清理垃圾数据占用的内存，标记整理算法，会同时整理排列。但是占用时间长"),Object(a.b)("li",{parentName:"ul"},"全停顿，垃圾回收时，js 脚本是暂停状态。"),Object(a.b)("li",{parentName:"ul"},"增量标记算法：将一个完整的垃圾回收任务分成很多小任务，和 js 脚本穿插执行。")))),Object(a.b)("h2",{id:"垃圾回收机制"},"垃圾回收机制"),Object(a.b)("p",null,"JavaScript 引擎有一个后台进程，叫垃圾回收器，它监视所有对象，并删除不可访问的对象。"),Object(a.b)("h3",{id:"标记清除算法"},"标记清除算法"),Object(a.b)("p",null,"标记清除算法的步骤是："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"垃圾回收器获取根并标记它们。"),Object(a.b)("li",{parentName:"ol"},"根据根，访问并标记所有来自它们的引用。"),Object(a.b)("li",{parentName:"ol"},"然后访问标记的对象并标记它们的引用。以此类推。"),Object(a.b)("li",{parentName:"ol"},"将未标记的对象删除。")),Object(a.b)("h3",{id:"引用计数（不常用）"},"引用计数（不常用）"),Object(a.b)("p",null,"引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。"),Object(a.b)("p",null,"如果一个值不需要了，但是引用次数不为0，垃圾回收机制无法回收这块内存，从而导致内存泄露。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"var a = {}\n")),Object(a.b)("p",null,"上面代码中，",Object(a.b)("inlineCode",{parentName:"p"},"{}"),"会占用一块内存，a 引用了它，所以引用次数为 1，尽管后面的代码没有用到 a，但是它不会被回收，依然会占用内存。"),Object(a.b)("p",null,"通过删除引用，可以让垃圾回收机制回收这块内存。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"a = null\n")),Object(a.b)("p",null,"上面代码，通过设置",Object(a.b)("inlineCode",{parentName:"p"},"a = null"),"，接触了 a 对 {} 的引用，内存就可以被垃圾回收器回收。所以有时候，垃圾回收器并不会很好的工作，为了避免内存泄露，我们需要人工干预。"),Object(a.b)("p",null,"IE9 之前存储循环引用的问题。它的 DOM 和 BOM 对象是以 COM 对象形式实现的，它的垃圾回收机制采用引用计数策略。因此，即使 IE 的 JavaScript 引擎使用标记清除策略实现，但是 JavaScript 访问 COM 对象是基于引用计数的。所以只要 IE 中涉及 COM 对象，就会有循环引用的问题。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),'var element = document.getElementById("some_element");\nvar myObject = new Object();\nmyObject.element = element;\nelement.someObject = myObject;\n')),Object(a.b)("p",null,"上面例子，DOM 元素(element)和 JavaScript 对象(myObject)形成循环引用，即使 element 从页面移除，它也不会被回收。所以应该在不需要时，手动消除循环引用。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{}),"myObject.element = null;\nelement.someObject = null;\n")),Object(a.b)("p",null,"IE9 已经将 DOM 和 BOM 转成了 JavaScript 对象，这就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。"),Object(a.b)("h2",{id:"面试题"},"面试题"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"垃圾回收时栈和堆的区别?"),Object(a.b)("li",{parentName:"ul"},"JS里垃圾回收机制是什么，常用的是哪种，怎么处理的?")),Object(a.b)("h2",{id:"参考资料"},"参考资料"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://github.com/qq449245884/xiaozhi/issues/36"}),"前端面试：谈谈 JS 垃圾回收机制")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html"}),"JavaScript 内存泄露教程")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://github.com/kaola-fed/blog/issues/230"}),"kaola-fed/blog V8垃圾回收机制")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://juejin.im/post/5d1b69b051882579d428d458"}),"Node.js内存管理和V8垃圾回收机制")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://v8.dev/blog/concurrent-marking"}),"Concurrent marking in V8")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",l({parentName:"li"},{href:"https://github.com/zqjflash/nodejs-memory"}),"nodejs-memory V8的垃圾回收机制与内存限制"))))}o.isMDXComponent=!0},301:function(e,t,n){"use strict";n.d(t,"a",function(){return c}),n.d(t,"b",function(){return u});var a=n(0),l=n.n(a),r=l.a.createContext({}),b=function(e){var t=l.a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},c=function(e){var t=b(e.components);return l.a.createElement(r.Provider,{value:t},e.children)};var i="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},o=function(e){var t=e.components,n=e.mdxType,a=e.originalType,r=e.parentName,c=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),i=b(t),o=n,u=i[r+"."+o]||i[o]||p[o]||a;return t?l.a.createElement(u,Object.assign({},c,{components:t})):l.a.createElement(u,c)};function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,b=new Array(r);b[0]=o;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[i]="string"==typeof e?e:a,b[1]=c;for(var u=2;u<r;u++)b[u]=n[u];return l.a.createElement.apply(null,b)}return l.a.createElement.apply(null,n)}o.displayName="MDXCreateElement"}}]);