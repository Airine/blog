(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{139:function(e,a,n){"use strict";n.r(a),n.d(a,"frontMatter",function(){return c}),n.d(a,"rightToc",function(){return b}),n.d(a,"default",function(){return o});n(0);var t=n(229);function r(){return(r=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}function l(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c={id:"v8",title:"V8 引擎原理"},b=[{value:"内存泄露",id:"内存泄露",children:[]},{value:"垃圾回收机制",id:"垃圾回收机制",children:[{value:"标记清除算法",id:"标记清除算法",children:[]},{value:"引用计数（不常用）",id:"引用计数（不常用）",children:[]}]},{value:"面试题",id:"面试题",children:[]},{value:"参考资料",id:"参考资料",children:[]}],i={rightToc:b},p="wrapper";function o(e){var a=e.components,n=l(e,["components"]);return Object(t.b)(p,r({},i,n,{components:a,mdxType:"MDXLayout"}),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"内存泄露"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#内存泄露"}),"#"),"内存泄露"),Object(t.b)("p",null,"内存泄露(Memory Leak)是指程序中动态分配的内存没有释放，造成系统内存浪费，导致程序运行变慢，甚至系统崩溃等严重后果。"),Object(t.b)("p",null,"有些语言(如 C 语言)，需要程序员手动释放和管理内存。这很麻烦，所以大多数语言提供了自动内存管理，这叫",Object(t.b)("inlineCode",{parentName:"p"},"垃圾回收机制(garbage collector，GC)"),"。"),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"垃圾回收机制"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#垃圾回收机制"}),"#"),"垃圾回收机制"),Object(t.b)("p",null,"JavaScript 引擎有一个后台进程，叫垃圾回收器，它监视所有对象，并删除不可访问的对象。"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"标记清除算法"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#标记清除算法"}),"#"),"标记清除算法"),Object(t.b)("p",null,"标记清除算法的步骤是："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"垃圾回收器获取根并标记它们。"),Object(t.b)("li",{parentName:"ol"},"根据根，访问并标记所有来自它们的引用。"),Object(t.b)("li",{parentName:"ol"},"然后访问标记的对象并标记它们的引用。以此类推。"),Object(t.b)("li",{parentName:"ol"},"将未标记的对象删除。")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"引用计数（不常用）"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#引用计数（不常用）"}),"#"),"引用计数（不常用）"),Object(t.b)("p",null,"引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。"),Object(t.b)("p",null,"如果一个值不需要了，但是引用次数不为0，垃圾回收机制无法回收这块内存，从而导致内存泄露。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = {}\n")),Object(t.b)("p",null,"上面代码中，",Object(t.b)("inlineCode",{parentName:"p"},"{}"),"会占用一块内存，a 引用了它，所以引用次数为 1，尽管后面的代码没有用到 a，但是它不会被回收，依然会占用内存。"),Object(t.b)("p",null,"通过删除引用，可以让垃圾回收机制回收这块内存。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"a = null\n")),Object(t.b)("p",null,"上面代码，通过设置",Object(t.b)("inlineCode",{parentName:"p"},"a = null"),"，接触了 a 对 {} 的引用，内存就可以被垃圾回收器回收。所以有时候，垃圾回收器并不会很好的工作，为了避免内存泄露，我们需要人工干预。"),Object(t.b)("p",null,"IE9 之前存储循环引用的问题。它的 DOM 和 BOM 对象是以 COM 对象形式实现的，它的垃圾回收机制采用引用计数策略。因此，即使 IE 的 JavaScript 引擎使用标记清除策略实现，但是 JavaScript 访问 COM 对象是基于引用计数的。所以只要 IE 中涉及 COM 对象，就会有循环引用的问题。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),'var element = document.getElementById("some_element");\nvar myObject = new Object();\nmyObject.element = element;\nelement.someObject = myObject;\n')),Object(t.b)("p",null,"上面例子，DOM 元素(element)和 JavaScript 对象(myObject)形成循环引用，即使 element 从页面移除，它也不会被回收。所以应该在不需要时，手动消除循环引用。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{}),"myObject.element = null;\nelement.someObject = null;\n")),Object(t.b)("p",null,"IE9 已经将 DOM 和 BOM 转成了 JavaScript 对象，这就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。"),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"面试题"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#面试题"}),"#"),"面试题"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"垃圾回收时栈和堆的区别?"),Object(t.b)("li",{parentName:"ul"},"JS里垃圾回收机制是什么，常用的是哪种，怎么处理的?")),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"参考资料"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#参考资料"}),"#"),"参考资料"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",r({parentName:"li"},{href:"https://github.com/qq449245884/xiaozhi/issues/36"}),"前端面试：谈谈 JS 垃圾回收机制")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",r({parentName:"li"},{href:"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html"}),"JavaScript 内存泄露教程")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",r({parentName:"li"},{href:"https://github.com/kaola-fed/blog/issues/230"}),"kaola-fed/blog V8垃圾回收机制")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",r({parentName:"li"},{href:"https://juejin.im/post/5d1b69b051882579d428d458"}),"Node.js内存管理和V8垃圾回收机制")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",r({parentName:"li"},{href:"https://v8.dev/blog/concurrent-marking"}),"Concurrent marking in V8")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("a",r({parentName:"li"},{href:"https://github.com/zqjflash/nodejs-memory"}),"nodejs-memory V8的垃圾回收机制与内存限制"))))}o.isMDXComponent=!0},229:function(e,a,n){"use strict";n.d(a,"a",function(){return b}),n.d(a,"b",function(){return m});var t=n(0),r=n.n(t),l=r.a.createContext({}),c=function(e){var a=r.a.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):Object.assign({},a,e)),n},b=function(e){var a=c(e.components);return r.a.createElement(l.Provider,{value:a},e.children)};var i="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return r.a.createElement(r.a.Fragment,{},a)}},o=function(e){var a=e.components,n=e.mdxType,t=e.originalType,l=e.parentName,b=function(e,a){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===a.indexOf(t)&&(n[t]=e[t]);return n}(e,["components","mdxType","originalType","parentName"]),i=c(a),o=n,m=i[l+"."+o]||i[o]||p[o]||t;return a?r.a.createElement(m,Object.assign({},b,{components:a})):r.a.createElement(m,b)};function m(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var l=n.length,c=new Array(l);c[0]=o;var b={};for(var p in a)hasOwnProperty.call(a,p)&&(b[p]=a[p]);b.originalType=e,b[i]="string"==typeof e?e:t,c[1]=b;for(var m=2;m<l;m++)c[m]=n[m];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,n)}o.displayName="MDXCreateElement"}}]);