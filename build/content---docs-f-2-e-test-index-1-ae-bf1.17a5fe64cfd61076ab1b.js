(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{227:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return l}),t.d(n,"rightToc",function(){return o}),t.d(n,"default",function(){return s});t(0);var a=t(245);function c(){return(c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var t,a,c=function(e,n){if(null==e)return{};var t,a,c={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(c[t]=e[t]);return c}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(c[t]=e[t])}return c}var l={title:"前端测试与jest"},o=[{value:"基础",id:"基础",children:[{value:"什么是断言",id:"什么是断言",children:[]},{value:"测试框架设计原则",id:"测试框架设计原则",children:[]},{value:"什么是TDD测试驱动开发",id:"什么是tdd测试驱动开发",children:[]},{value:"持续集成",id:"持续集成",children:[]},{value:"持续交付",id:"持续交付",children:[]},{value:"流行测试框架",id:"流行测试框架",children:[]}]},{value:"jest",id:"jest",children:[{value:"入门",id:"入门",children:[]}]},{value:"配置",id:"配置",children:[]},{value:"常用的Matchers",id:"常用的matchers",children:[]},{value:"测试DOM",id:"测试dom",children:[]},{value:"测试UI组件",id:"测试ui组件",children:[]},{value:"测试异步流程",id:"测试异步流程",children:[]},{value:"mocks",id:"mocks",children:[]},{value:"代码覆盖率",id:"代码覆盖率",children:[]},{value:"怎么使用 es6 的 import 和 export",id:"怎么使用-es6-的-import-和-export",children:[]},{value:"介绍",id:"介绍",children:[{value:"配置文件",id:"配置文件",children:[]},{value:"使用Babel",id:"使用babel",children:[]}]},{value:"Matchers",id:"matchers",children:[]},{value:"异步代码测试",id:"异步代码测试",children:[{value:"回调函数，使用done",id:"回调函数，使用done",children:[]},{value:"promise，直接在then或catch里测试，注意要使用return",id:"promise，直接在then或catch里测试，注意要使用return",children:[]},{value:"async/await",id:"asyncawait",children:[]}]},{value:"钩子",id:"钩子",children:[]},{value:"mock",id:"mock",children:[{value:"mock返回值",id:"mock返回值",children:[]}]},{value:"模拟模块",id:"模拟模块",children:[]},{value:"周边库",id:"周边库",children:[]},{value:"快照测试",id:"快照测试",children:[]},{value:"dom操作",id:"dom操作",children:[]},{value:"学习资料",id:"学习资料",children:[]}],i={rightToc:o},b="wrapper";function s(e){var n=e.components,t=r(e,["components"]);return Object(a.b)(b,c({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"基础"},"基础"),Object(a.b)("h3",{id:"什么是断言"},"什么是断言"),Object(a.b)("p",null,"断言是对结果的一种预期，它是单元测试的核心。很多语言都内置了断言接口，比如",Object(a.b)("inlineCode",{parentName:"p"},"node"),"的",Object(a.b)("inlineCode",{parentName:"p"},"Assert"),"，",Object(a.b)("inlineCode",{parentName:"p"},"console.assert"),"等。"),Object(a.b)("p",null,"比如现在有个需求，实现两个数的相加。所以写了下面的代码："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"const add = (a, b) => a + b\n")),Object(a.b)("p",null,"上面的代码显然是正确的，但是无法证实，而且我有可能写错了，写成了："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"const add1 = (a, b) => a + b + 2\n")),Object(a.b)("p",null,"所以我需要验证一下方法的正确性。比如我期望",Object(a.b)("inlineCode",{parentName:"p"},"add(1, 2)"),"的结果是",Object(a.b)("inlineCode",{parentName:"p"},"3"),"。这就是一个断言。于是我封装了一个",Object(a.b)("inlineCode",{parentName:"p"},"assert"),"方法。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"/**\n * 期望fn()运行结果是result\n */\nfunction assert(message,fn, result){\n    return fn() === result\n}\nasset('我希望1 + 2 = 3', ()=> add(1,2) , 3)  // true\nasset('我希望1 + 2 = 3', ()=> add1(1,2) , 3)  // false\n")),Object(a.b)("h3",{id:"测试框架设计原则"},"测试框架设计原则"),Object(a.b)("p",null,"项目中我们往往使用测试框架来进行测试。我们期望测试框架设计成："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"抽离代码，避免污染源代码"),Object(a.b)("li",{parentName:"ol"},"放在专门的目录,持久化"),Object(a.b)("li",{parentName:"ol"},"整体设计"),Object(a.b)("li",{parentName:"ol"},"自动运行，显示结果并统计")),Object(a.b)("p",null,"按照上面的要求可以简单的封装成一个函数。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"function testCase(message, tests){\n    var total = 0\n    var success = 0\n    for(var test in tests){\n        total += 1\n        var ret = tests[test](test)\n\n        if(ret){\n            success += 1\n        }\n    }\n    console.log( success + '/' + total)\n}\n\nfunction assert(expression, message) {\n    console.log(expression, message)\n    return expression\n}\n\n// 测试用例\ntestCase('query', {\n    'test name = 3'(message){\n        return assert(query('name', 'name=3') === 3, message)\n    },\n    'test name = 3'(message){\n        return assert(query('name', '?name=3&age=12') === 3, message)\n    }\n})\n")),Object(a.b)("p",null,"上面的代码很简单，只要函数的运行结果和我们的预期一致，则表示这个测试用例成功。"),Object(a.b)("h3",{id:"什么是tdd测试驱动开发"},"什么是TDD测试驱动开发"),Object(a.b)("p",null,"TDD 是 Test Driven Development。它的流程如下: ",Object(a.b)("inlineCode",{parentName:"p"},"分析需求 -> 任务、模块拆解 ->  编写测试用例 -> 快速构建代码(代码差也不要紧，测试保证重构不出错) -> 重构 -> 功能测试、发布"),"。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"先有测试，再来开发，测试保障开发不出问题。"),Object(a.b)("li",{parentName:"ul"},"测试用例和断言"),Object(a.b)("li",{parentName:"ul"},"单元测试(模块测试)"),Object(a.b)("li",{parentName:"ul"},"测试框架")),Object(a.b)("p",null,"TDD 这个理念，很多人推崇，也有很多人反感，我们用它好的地方就行。一些开源库，如 jQuery，lodash ，TDD 再也合适不过的，当然也有不合适的地方，那就不用。"),Object(a.b)("h3",{id:"持续集成"},"持续集成"),Object(a.b)("p",null,"持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。持续集成的目的是避免集成的问题。"),Object(a.b)("h3",{id:"持续交付"},"持续交付"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://www.ibm.com/developerworks/cn/linux/l-tdd/"}),"浅谈测试驱动开发（TDD）")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/"}),"The Difference Between TDD and BDD"))),Object(a.b)("h3",{id:"流行测试框架"},"流行测试框架"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"qunit")," jquery browser"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"mocha")," node && browser expressjs"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"jasmine")," node && browser vue jsunit演化而来"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"karma")," angular a test-runner，让系统的浏览器自动跑，搭配其它框架使用"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"jest")," react koa 零配置，内置代码覆盖率，强大的mocks")),Object(a.b)("h2",{id:"jest"},"jest"),Object(a.b)("h3",{id:"入门"},"入门"),Object(a.b)("p",null,"将",Object(a.b)("inlineCode",{parentName:"p"},"package.json"),"里的",Object(a.b)("inlineCode",{parentName:"p"},"script test"),"，改成",Object(a.b)("inlineCode",{parentName:"p"},"jest"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// 测试用例 testCase\ntest('url parse', ()=>{\n    expect(url.parse('?a=1', 'a')).toBe('1')  // 断言\n    expect(url.parse('?a=1&b=2', 'b')).toBe('2')\n})\n\ntest('format date', ()=>{\n    expect(formatDate('20110101')).toBe('2011-01-01')\n})\n\n// test group\ndescribe('test date', ()=>{\n    // test case\n    test('format date', ()=>{\n        // assert\n        expect(formatDate('20110101')).toBe('2011-01-01')\n    })\n\n    // test case\n    test('format date to timestamp', ()=>{\n        expect(formatDate('20110101')).toBe('1312321321')\n    })\n})\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"test suits 测试套件，每个文件"),Object(a.b)("li",{parentName:"ul"},"test group"),Object(a.b)("li",{parentName:"ul"},"test case"),Object(a.b)("li",{parentName:"ul"},"test asset")),Object(a.b)("h2",{id:"配置"},"配置"),Object(a.b)("p",null,"可以在",Object(a.b)("inlineCode",{parentName:"p"},"package.json"),"、",Object(a.b)("inlineCode",{parentName:"p"},"jest.config.js"),"或者命令行配置。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// jest.config.js\nmodule.exports = {\n    // testMatch和testRegex互斥，只用一个\n    testMatch: ['**/test/**/*.js?(x)', '**/?(*.)(spec|test).js?(x)'], // ['<rootDir>/test/**/*.js']\n    testRegex:'',\n    testEnvironment:'jsdom', // node\n    rootDir:'', // 默认是package.json所在目录，没有则pwd\n    moduleFileExtensions: ['js', 'json', 'jsx', 'node]\n}\n\n// package.json\n{\n    \"jest\":{}\n}\n\n// 命令行\njest --watch\n")),Object(a.b)("h2",{id:"常用的matchers"},"常用的Matchers"),Object(a.b)("p",null,"因为有些东西不好比较，比如",Object(a.b)("inlineCode",{parentName:"p"},"{a:1}"),"和",Object(a.b)("inlineCode",{parentName:"p"},"{a:1}"),"是否值相等。所以出现了matchers。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBe()"),": 全等，是通过 Object.is() 实现的。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toEqual()"),"：值相等，可以用于判断对象，如 {a:1} 和 {a:1} 是相等的。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"not"),"：将 Matchers 取反，如 not.toBe()"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeNull()"),"：只能是 null"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeUndefined()"),"：只能是 undefined"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeDefined()"),"：非 undefined"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeTruthy()"),"：匹配为 true 的表达式"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeFalsy()"),"：匹配为 false 的表达式"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeGreaterThan()"),"：数字大于"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeGreaterThanOrEqual()"),"：数字大于或等于"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeLessThan()"),"：小于"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeLessThanOrEqual()"),"：小于或等于"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeCloseTo()"),"： 近似，比如 expect(0.1+0.2).toBeCloseTo(0.3)"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toMatch()"),"：可以使用正则 expect('Christoph').toMatch(/stop/)"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toContain()"),"：数组包含某个值"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toThrow()"),"：匹配抛出的错误，可以是正则或字符串"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toHaveProperty()"),"查看某个对象有某个属性")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// 例子1\nfunction compileAndroidCode() {\n    throw new ConfigError('you are using the wrong JDK');\n}\n\ntest('compiling android goes as expected', () => {\n  expect(compileAndroidCode).toThrow();\n  expect(compileAndroidCode).toThrow(ConfigError);\n\n  // You can also use the exact error message or a regexp\n  expect(compileAndroidCode).toThrow('you are using the wrong JDK');\n  expect(compileAndroidCode).toThrow(/JDK/);\n});\n\n// 例子2\nlet person = {\n    name: '张三',\n    age: 12,\n    parent: {\n        name: '张二',\n        age: 50\n    }\n}\n\ndescribe('test person', () => {\n    test('person has property', () => {\n        expect(person).toHaveProperty('parent')\n        expect(null).toBeNull()\n        expect('123').toMatch(/\\d+/)\n        expect('123').not.toMatch(/\\d+/)\n    })\n})\n\n// 例子3\nconst removeItemByIndex = (i, arr) => {\n    arr.splice(i, 1)\n    return arr\n}\n\ndescribe('remoteItemByIndex', () => {\n    test('remove item by index', () => {\n        expect(removeItemByIndex(1, [1, 2, 3])).toEqual([1, 3])\n        expect(removeItemByIndex(0, [1, 2, 3])).toEqual([2, 3])\n    })\n})\n")),Object(a.b)("h2",{id:"测试dom"},"测试DOM"),Object(a.b)("p",null,"jest 之所以能够测试 dom，是因为内置了",Object(a.b)("inlineCode",{parentName:"p"},"jsdom"),"(配置里有个",Object(a.b)("inlineCode",{parentName:"p"},"testEnvironment:'jsdom'"),")。这是一个 npm 包，它主要是给",Object(a.b)("inlineCode",{parentName:"p"},"nodejs"),"使用。除了",Object(a.b)("inlineCode",{parentName:"p"},"jsdom"),"，还有其它一些解决方案，如：",Object(a.b)("inlineCode",{parentName:"p"},"phantomjs"),"、",Object(a.b)("inlineCode",{parentName:"p"},"chrome headless"),"。vuejs 的测试方案是 ",Object(a.b)("inlineCode",{parentName:"p"},"jasmine+karma"),"，karma 会捕获本机器上的浏览器并自动运行测试代码。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// 例子1: 测试移除dom元素\nPencil.removeNode = (node) => {\n    return node.parentNode.removeChild(node)\n}\ntest('remove node', () => {\n    document.body.innerHTML = '<div id=\"p\"><p id=\"c\">hello</p></div>'\n    const p = document.querySelector('#p')\n    expect(p.nodeName.toLowerCase()).toBe('div')\n    const c = document.querySelector('#c')\n    Pencil.removeNode(c)\n    expect(document.querySelector('#c')).toBeNull()\n})\n\n// 例子2: 测试点击事件\nPencil.on = (node, type, handler) =>{\n    node.addEventListener(type, handler, false)\n}\ntest('on event', () => {\n    document.body.innerHTML = '<div id=\"p\"><p id=\"c\">hello</p></div>'\n    const p = document.querySelector('#p')\n    Pencil.on(btn, 'click', ()=>{\n        p.innerHTML = 'clicked'\n    })\n    p.click()\n    expect(p.innerHTML).toBe('clicked')\n})\n")),Object(a.b)("h2",{id:"测试ui组件"},"测试UI组件"),Object(a.b)("p",null,"下面展示一个测试UI组件的例子，点击按钮时变色，其它按钮恢复原状。"),Object(a.b)("p",null,Object(a.b)("img",c({parentName:"p"},{src:"./jest/test-radio.png",alt:null}))),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// html 结构\n<ul>\n    <li></li>\n    <li></li>\n    <li></li>\n</ul>\n\n// radio.js 功能文件\nfunction initRadio() {\n    const lis = document.querySelectorAll('li')\n    let prev = null\n    let cur = 0\n\n    lis.forEach((li, i) => {\n        li.setAttribute('data-index', i)\n        li.addEventListener('click', function () {\n            prev = cur\n            cur = this.getAttribute('data-index')\n            lis[prev].classList.remove('active')\n            lis[cur].classList.add('active')\n        })\n    })\n}\n\nmodule.exports = initRadio\n\n\n// radio.test.js 测试文件\nconst fs = require('fs')\nconst initRadio = require('../js/radio')\n\ndescribe('test radio', () => {\n    test('radio init', () => {\n        document.body.innerHTML = fs.readFileSync('./index.html')\n        initRadio()\n\n        const lis = document.querySelectorAll('li')\n        lis[0].click()\n        expect(lis[0].classList.contains('active')).toBe(true)\n        expect(lis[1].classList.contains('active')).toBe(false)\n        expect(lis[2].classList.contains('active')).toBe(false)\n\n        lis[1].click()\n        expect(lis[0].classList.contains('active')).toBe(false)\n        expect(lis[1].classList.contains('active')).toBe(true)\n        expect(lis[2].classList.contains('active')).toBe(false)\n    })\n})\n")),Object(a.b)("h2",{id:"测试异步流程"},"测试异步流程"),Object(a.b)("p",null,"异步流程需要在完成后调用",Object(a.b)("inlineCode",{parentName:"p"},"done()"),"方法，否则",Object(a.b)("inlineCode",{parentName:"p"},"jest"),"会报超时错误。下面是一个简单的例子。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),'function ajax(success) {\n    setTimeout(() => {\n        const data = { name: 3 }\n        success(data)\n    }, 1000)\n}\n\ntest("ajax data.name is 3", done => {\n    const success = data => {\n        expect(data.name).toBe(3)\n        done()\n    }\n    ajax(success)\n})\n')),Object(a.b)("p",null,"实际中不能访问远程的数据，因为没有",Object(a.b)("inlineCode",{parentName:"p"},"XMLHttpRequest"),"对象。所以需要使用",Object(a.b)("inlineCode",{parentName:"p"},"mocks"),"模拟远程数据。"),Object(a.b)("p",null,"下面是一个测试防抖函数",Object(a.b)("inlineCode",{parentName:"p"},"debounce"),"的例子。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"/**\n * 创建 debounce 函数\n * @param {Function} callback\n * @param {Number} time\n */\nfunction createDebounce(callback, time) {\n    var timer\n    time = time || 300 // 给个默认值\n\n    return function () {\n        if (timer) {\n            clearTimeout(timer)\n        }\n\n        timer = setTimeout(() => {\n            callback()\n        }, time)\n    }\n}\ndescribe('debounce', () => {\n    test('debounce', done => {\n        let a = 1\n        let debounce = createDebounce(() => { // 创建一个 debounce\n            a = 2\n        }, 1000)\n        debounce()\n        expect(a).toBe(1)\n        setTimeout(() => {\n            debounce()\n            expect(a).toBe(1)\n        }, 500)\n        setTimeout(() => {\n            expect(a).toBe(1)\n        }, 1000)\n        setTimeout(() => {\n            expect(a).toBe(2)\n            done()\n        }, 2500)\n    })\n})\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"好的代码，能被测试的代码，都是模块化的。")),Object(a.b)("h2",{id:"mocks"},"mocks"),Object(a.b)("p",null,"擦除函数的实际实现来测试代码之间的链接，模拟对函数的调用。",Object(a.b)("inlineCode",{parentName:"p"},"jest"),"里的 mocks 有2种：",Object(a.b)("inlineCode",{parentName:"p"},"Mock Function")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"Manual mock"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// Mock Function\nconst forEach = (arr, callback) => {\n    for (let i = 0; i < arr.length; i++) {\n        callback(arr[i])\n    }\n}\n\ntest('forEach', () => {\n    const mockFn = jest.fn()\n    forEach([1, 2, 3], mockFn)\n\n    // 调用多少次\n    expect(mockFn.mock.calls.length).toBe(3)\n\n    // 参数，第1次的第1个参数\n    expect(mockFn.mock.calls[0][0]).toBe(1)\n    expect(mockFn.mock.calls[2][0]).toBe(3)\n})\n\n\n// Manual Mock 模拟模块，需要在同级目录创建 __mocks__ 文件夹。\n// jquery.js \nmodule.exports = (selector) => document.querySelector(selector)\n\n// jquery.test.js\njest.mock('jquery')\nlet $ = require('jquery')\n\ntest('jquery', () => {\n    document.body.innerHTML = '<div id=\"box\">hello</div>'\n    expect($('#box').innerHTML).toBe('hello')\n})\n")),Object(a.b)("h2",{id:"代码覆盖率"},"代码覆盖率"),Object(a.b)("p",null,"代码覆盖率包括："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"line coverage 行覆盖率"),Object(a.b)("li",{parentName:"ul"},"function coverage 函数覆盖率"),Object(a.b)("li",{parentName:"ul"},"branch coverage 分支覆盖率"),Object(a.b)("li",{parentName:"ul"},"statement coverage 语句覆盖率，因为有时候一行写了多条语句，最好把语句按行分开规范化代码")),Object(a.b)("p",null,"jest 内置了 ",Object(a.b)("a",c({parentName:"p"},{href:"https://github.com/gotwarlost/istanbul"}),"istanbul")," 生成代码测试覆盖率。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-bash"}),"node_modules/.bind/jest --coverage\n\n// 或者\nnpx jest --coverage\n")),Object(a.b)("p",null,"运行上面的命令会在项目根目录生成一个 coverage 的目录。打开 ",Object(a.b)("inlineCode",{parentName:"p"},"Icov-report/index.html")," 可以查看到测试覆盖率，点击网页上具体的文件，可以看到那些代码没有测试到。"),Object(a.b)("p",null,Object(a.b)("img",c({parentName:"p"},{src:"./imgs/coverage.png",alt:null}))),Object(a.b)("h2",{id:"怎么使用-es6-的-import-和-export"},"怎么使用 es6 的 import 和 export"),Object(a.b)("p",null,"node 默认是不支持 es6 的模块导入导出的，需要使用 babel 进行转义。具体方法如下："),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"1. 安装插件")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-shell"}),"npm i --save-dev babel-jest babel-core regenerator-runtime babel-plugin-transform-es2015-modules-commonjs babel-preset-env\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"babel-jest"),"：安装jest时它会被自动安装，作用是将代码通过 babel 转义。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"babel-plugin-transform-es2015-modules-commonjs"),"：用于将es6的 import 和 export 转义"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"regenerator-runtime"),"：facebook自己出的用于 async/generator 转义的插件"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"babel-preset-env"),'：会根据当前环境转换不支持的代码。当前环境是指执行编译后代码的环境，比如浏览器比如nodejs 等。babel-preset-env 中存储的是 各个浏览器和其它运行环境的核心版本号以及支持js的版本标识。然后自动生成一个配置给babel来做编译转换。babelrc里设置{  "presets": ','["env"]'," } 会自动转换那些环境不支持的代码。")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"2. 配置babel")),Object(a.b)("p",null,"jest 默认运行环境就是 test。所以在根目录的 .babelrc 文件新增下面代码："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),'{\n    "presets": ["env"],\n    "env": {\n        "test": {\n            "plugins": ["transform-es2015-modules-commonjs"]\n        }\n    }\n}\n')),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"3. 使用")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),'// es6模块文件：util.js\nconst util = {\n    query: function(str){\n        return str.replace(/^.+=/, \'\')\n    }\n}\n\nexport default util\n\n\n// 测试文件：__test__/util.js\nimport util from "../src/query"\n\ntest("query a  =  3", () => {\n    expect(util.query("a=3")).toBe("3")\n})\n')),Object(a.b)("h2",{id:"介绍"},"介绍"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"1. 安装jest")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"yarn add --dev jest\nnpm i jest\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"2. 运行")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),'# 测试，配置package.json的test， { "test": "jest --watchAll"}\nnpm run test\n\n# 运行某个目录的测试\nnpx jest src/ --notify --config=config.json\n\n# 运行单文件测试\nnpx jest 1.test.js\n')),Object(a.b)("h3",{id:"配置文件"},"配置文件"),Object(a.b)("p",null,"通过",Object(a.b)("inlineCode",{parentName:"p"},"jest --init"),"命令初始化创建，会在根目录创建",Object(a.b)("inlineCode",{parentName:"p"},"jest.config.js"),"。"),Object(a.b)("h3",{id:"使用babel"},"使用Babel"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"# 安装 babel-jest regenerator-runtime\nyarn add --dev babel-jest babel-core regenerator-runtime\n\n# babel 7，需要安装babel-jest, babel-core@^7.0.0-bridge.0, @babel/core\nyarn add --dev babel-jest babel-core@^7.0.0-bridge.0 @babel/core regenerator-runtime\n")),Object(a.b)("p",null,"如果使用",Object(a.b)("inlineCode",{parentName:"p"},"npm 3/4"),"或",Object(a.b)("inlineCode",{parentName:"p"},"yarn"),"不需要安装",Object(a.b)("inlineCode",{parentName:"p"},"regenerator-runtime"),"。"),Object(a.b)("p",null,"如果使用es6和react.js，需要配置.babelrc的预设："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "presets": ["env", "react"]\n}\n')),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"注意：Babel 的 env 配置，jest会自动定义 NODE_ENV 为",Object(a.b)("inlineCode",{parentName:"p"},"test"),"，它不会在 Babel 没有设置 NODE_ENV 时使用",Object(a.b)("inlineCode",{parentName:"p"},"development"),"。")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"注意：如果关闭了 es6 module，",Object(a.b)("inlineCode",{parentName:"p"},'{"modules": false}'),"，需要在测试环境打开它")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'{\n  "presets": [["env", {"modules": false}], "react"],\n  "env": {\n    "test": {\n      "presets": [["env"], "react"]\n    }\n  }\n}\n')),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"提示：如果有 babel 配置，安装 jest 时会自动安装",Object(a.b)("inlineCode",{parentName:"p"},"babel-jest"),"来自动转换文件。如果不需要可以修改",Object(a.b)("inlineCode",{parentName:"p"},"transform"),"配置。")),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-json"}),'// package.json\n{\n    "jest": {\n        "transform": {}\n    }\n}\n')),Object(a.b)("p",null,"要用 typescript，可以使用",Object(a.b)("a",c({parentName:"p"},{href:"https://github.com/kulshekhar/ts-jest"}),Object(a.b)("inlineCode",{parentName:"a"},"ts-jest")),"。"),Object(a.b)("h2",{id:"matchers"},"Matchers"),Object(a.b)("p",null,"toBe使用",Object(a.b)("inlineCode",{parentName:"p"},"Object.js"),"测试确切的相等性。如果要检查对象值相等，用",Object(a.b)("inlineCode",{parentName:"p"},"toEqual"),"。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// Object.is  和  === 的区别\nObject.is(0, +0)  // true\nObject.is(-0, +0) // false\nObject.is(-0, 0)  // false\nObject.is(NaN, NaN) // true\n\n// 测试对象值相等\ntest('object assignment', () => {\n  const data = {one: 1};\n  data['two'] = 2;\n  expect(data).toEqual({one: 1, two: 2});\n});\n\n// 测试反面\nexpect(3).not.toBe(4)\n")),Object(a.b)("p",null,"测试中，有时需要区分",Object(a.b)("inlineCode",{parentName:"p"},"undefined"),"、",Object(a.b)("inlineCode",{parentName:"p"},"null"),"以及",Object(a.b)("inlineCode",{parentName:"p"},"false"),"。jest相关的matchers如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeNull"),"只匹配",Object(a.b)("inlineCode",{parentName:"li"},"null")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeUndefined"),"只匹配",Object(a.b)("inlineCode",{parentName:"li"},"undefined")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeDefined")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeTruthy"),"匹配if判断为true的内容"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"toBeFalsy"),"匹配if判断为false的内容")),Object(a.b)("p",null,"数字的比较:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"test('two plus two', () => {\n  const value = 2 + 2;\n  expect(value).toBeGreaterThan(3);\n  expect(value).toBeGreaterThanOrEqual(3.5);\n  expect(value).toBeLessThan(5);\n  expect(value).toBeLessThanOrEqual(4.5);\n\n  // toBe and toEqual are equivalent for numbers\n  expect(value).toBe(4);\n  expect(value).toEqual(4);\n});\n")),Object(a.b)("p",null,"对于浮点数相等，使用",Object(a.b)("inlineCode",{parentName:"p"},"toBeCloseTo"),"而不是",Object(a.b)("inlineCode",{parentName:"p"},"toEqual"),"，因为您不希望测试依赖于微小的舍入误差。。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"expect(0.1+0.2).toBeCloseTo(0.3)\n")),Object(a.b)("p",null,"检查字符串可以使用toMatch:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"expect('team').not.toMatch(/I/);\nexpect('Christoph').toMatch(/stop/);\n")),Object(a.b)("p",null,"数组可以使用",Object(a.b)("inlineCode",{parentName:"p"},"toContain"),"，不会隐式转换数字和字符串:"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"expect(arr).toContain(1);\n")),Object(a.b)("p",null,"测试抛出异常："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"function compileAndroidCode() {\n  throw new ConfigError('you are using the wrong JDK');\n}\n\ntest('compiling android goes as expected', () => {\n  expect(compileAndroidCode).toThrow();\n  expect(compileAndroidCode).toThrow(ConfigError);\n\n  // You can also use the exact error message or a regexp\n  expect(compileAndroidCode).toThrow('you are using the wrong JDK');\n  expect(compileAndroidCode).toThrow(/JDK/);\n});\n")),Object(a.b)("h2",{id:"异步代码测试"},"异步代码测试"),Object(a.b)("h3",{id:"回调函数，使用done"},"回调函数，使用done"),Object(a.b)("h3",{id:"promise，直接在then或catch里测试，注意要使用return"},"promise，直接在then或catch里测试，注意要使用return"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"const fetchData1 = () => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(10)\n        }, 1000)\n    })\n}\n\ntest('this data is hello', () => {\n    return fetchData1().then(data => {\n        expect(data).toBe(10)\n    })\n})\n\n// 使用.resolves将自动resolve()\nreturn expect(fetchData()).resolves.toBe('peanut butter');\n// 使用.resolves将自动reject()\nreturn expect(fetchData()).rejects.toBe('peanut butter');\n")),Object(a.b)("h3",{id:"asyncawait"},"async/await"),Object(a.b)("p",null,"很简单，像同步即可。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"test('the data is peanut butter', async () => {\n  expect.assertions(1);\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  expect.assertions(1);\n  try {\n    await fetchData();\n  } catch (e) {\n    expect(e).toMatch('error');\n  }\n});\n\n// 也可以使用.resolves、.rejects\ntest('the data is peanut butter', async () => {\n  expect.assertions(1);\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  expect.assertions(1);\n  await expect(fetchData()).rejects.toMatch('error');\n});\n")),Object(a.b)("h2",{id:"钩子"},"钩子"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"// 会在每个测试用例test调用之前或之后执行，可以处理异步，使用done\nbeforeEach(()=>{})\nafterEach(()=>{})\nbeforeEach(()=>{\n  return new Promise()\n})\n\n// 在测试之前和之后执行\nbeforeAll()\nafterAll()\n")),Object(a.b)("p",null,"关于作用域问题："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// 作用域当前文件的所有testApplies to all tests in this file\nbeforeEach(() => {\n  return initializeCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n\ndescribe('matching cities to foods', () => {\n  // 作用于当前describe\n  beforeEach(() => {\n    return initializeFoodDatabase();\n  });\n\n  test('Vienna <3 sausage', () => {\n    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);\n  });\n\n  test('San Juan <3 plantains', () => {\n    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);\n  });\n});\n")),Object(a.b)("p",null,"忽略其它的test。使用",Object(a.b)("inlineCode",{parentName:"p"},"test.only()"),"进行调试。"),Object(a.b)("h2",{id:"mock"},"mock"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"\nfunction forEach(items, callback) {\n    for (let index = 0; index < items.length; index++) {\n        callback(items[index])\n    }\n}\n\nconst mockCallback = jest.fn(x => 42 + x)\n\nforEach([0, 1], mockCallback)\n\nexpect(mockCallback.mock.calls.length).toBe(2)\nexpect(mockCallback.mock.calls[0][0]).toBe(0)\nexpect(mockCallback.mock.calls[1][0]).toBe(1)\nexpect(mockCallback.mock.result[0].value).toBe(42)\n\n// 调用函数的this实例\nexpect(someMockFunction.mock.instances.length).toBe(2);\n")),Object(a.b)("h3",{id:"mock返回值"},"mock返回值"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{}),"const myMock = jest.fn();\nconsole.log(myMock());\n// > undefined\n\nmyMock\n  .mockReturnValueOnce(10)\n  .mockReturnValueOnce('x')\n  .mockReturnValue(true);\n\nconsole.log(myMock(), myMock(), myMock(), myMock());\n// > 10, 'x', true, true\n\n// 例子\nconst filterTestFn = jest.fn();\n\n// Make the mock return `true` for the first call,\n// and `false` for the second call\nfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);\n\nconst result = [11, 12].filter(filterTestFn);\n\nconsole.log(result);\n// > [11]\nconsole.log(filterTestFn.mock.calls);\n// > [ [11], [12] ]\n")),Object(a.b)("h2",{id:"模拟模块"},"模拟模块"),Object(a.b)("p",null,"下面的方法，模拟axios模块后，再模拟get的返回值。"),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"// users.js\nimport axios from 'axios';\n\nclass Users {\n  static all() {\n    return axios.get('/users.json').then(resp => resp.data);\n  }\n}\n\nexport default Users;\n\n\n// users.test.js\nimport axios from 'axios';\nimport Users from './users';\n\njest.mock('axios');\n\ntest('should fetch users', () => {\n  const resp = {data: [{name: 'Bob'}]};\n  axios.get.mockResolvedValue(resp);\n\n  // or you could use the following depending on your use case:\n  // axios.get.mockImplementation(() => Promise.resolve(resp))\n\n  return Users.all().then(users => expect(users).toEqual(resp.data));\n});\n")),Object(a.b)("h2",{id:"周边库"},"周边库"),Object(a.b)("h2",{id:"快照测试"},"快照测试"),Object(a.b)("h2",{id:"dom操作"},"dom操作"),Object(a.b)("h2",{id:"学习资料"},"学习资料"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://blog.csdn.net/winteroak/article/details/81585299"}),"行为驱动开发（BDD）全面介绍")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"http://fex.baidu.com/blog/2015/07/front-end-test/"}),"前端自动化测试探索")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://www.zhihu.com/question/29922082"}),"如何进行前端自动化测试？")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://facebook.github.io/jest/docs/en/getting-started.html"}),"jest document")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://jestjs.io/docs/en/expect.html"}),"jest matchers")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://www.chaijs.com/"}),"断言库chaijs")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",c({parentName:"li"},{href:"https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/"}),"实例解析防抖动（Debouncing）和节流阀（Throttling）"))))}s.isMDXComponent=!0},245:function(e,n,t){"use strict";t.d(n,"a",function(){return o}),t.d(n,"b",function(){return p});var a=t(0),c=t.n(a),r=c.a.createContext({}),l=function(e){var n=c.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=l(e.components);return c.a.createElement(r.Provider,{value:n},e.children)};var i="mdxType",b={inlineCode:"code",wrapper:function(e){var n=e.children;return c.a.createElement(c.a.Fragment,{},n)}},s=function(e){var n=e.components,t=e.mdxType,a=e.originalType,r=e.parentName,o=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),i=l(n),s=t,p=i[r+"."+s]||i[s]||b[s]||a;return n?c.a.createElement(p,Object.assign({},o,{components:n})):c.a.createElement(p,o)};function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=s;var o={};for(var b in n)hasOwnProperty.call(n,b)&&(o[b]=n[b]);o.originalType=e,o[i]="string"==typeof e?e:a,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return c.a.createElement.apply(null,l)}return c.a.createElement.apply(null,t)}s.displayName="MDXCreateElement"}}]);