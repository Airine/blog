(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{209:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return c}),a.d(n,"rightToc",function(){return b}),a.d(n,"default",function(){return p});a(0);var t=a(217);function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var c={title:"webpack (1): 官方文档总结"},b=[{value:"入口 entry",id:"入口-entry",children:[]},{value:"出口 output",id:"出口-output",children:[]},{value:"Loader",id:"loader",children:[{value:"编写 Loader",id:"编写-loader",children:[]}]},{value:"tapable",id:"tapable",children:[]},{value:"插件",id:"插件",children:[{value:"编写插件",id:"编写插件",children:[]},{value:"钩子类型",id:"钩子类型",children:[]},{value:"例子",id:"例子",children:[]},{value:"常用插件列表",id:"常用插件列表",children:[]}]},{value:"配置",id:"配置",children:[]},{value:"webpack 模块",id:"webpack-模块",children:[]},{value:"模块解析",id:"模块解析",children:[]},{value:"依赖图",id:"依赖图",children:[]},{value:"部署目标",id:"部署目标",children:[]},{value:"Manifest",id:"manifest",children:[]},{value:"模式",id:"模式",children:[]},{value:"浏览器兼容性",id:"浏览器兼容性",children:[]},{value:"tree sharking",id:"tree-sharking",children:[{value:"sideEffect",id:"sideeffect",children:[]},{value:"注意事项",id:"注意事项",children:[]},{value:"为什么要es6 module",id:"为什么要es6-module",children:[]}]},{value:"调试 webpack",id:"调试-webpack",children:[]},{value:"webpack 打包流程",id:"webpack-打包流程",children:[]},{value:"进度",id:"进度",children:[]}],o={rightToc:b},i="wrapper";function p(e){var n=e.components,a=r(e,["components"]);return Object(t.b)(i,l({},o,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("ul",{className:"contains-task-list"},Object(t.b)("li",l({parentName:"ul"},{className:"task-list-item"}),Object(t.b)("input",l({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Markdown  "),Object(t.b)("li",l({parentName:"ul"},{className:"task-list-item"}),Object(t.b)("input",l({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","JavaScript")),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"指南"),Object(t.b)("li",{parentName:"ol"},"打包结果分析",Object(t.b)("ol",{parentName:"li"},Object(t.b)("li",{parentName:"ol"},"同步"),Object(t.b)("li",{parentName:"ol"},"异步"))),Object(t.b)("li",{parentName:"ol"},"loader",Object(t.b)("ol",{parentName:"li"},Object(t.b)("li",{parentName:"ol"},"babel-loader"),Object(t.b)("li",{parentName:"ol"},"css-loader style-loader"),Object(t.b)("li",{parentName:"ol"},"file-loader"))),Object(t.b)("li",{parentName:"ol"},"plugin  - tapable - ast"),Object(t.b)("li",{parentName:"ol"},"编译流程")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"webpack 作为现在前端的一大利器，虽然说平时工作中都是用的脚手架，自定义的需求不多，但是",Object(t.b)("a",l({parentName:"p"},{href:"https://webpack.js.org/concepts/"}),"官方文档"),"还是要细读几遍的。这篇笔记是阅读文档的总结，当然，遇到细节时还是需要再查文档。")),Object(t.b)("p",null,"webpack 是一个静态模块打包器，它可以根据入口文件生成依赖关系图，然后打成一个包(或多个)。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"入口-entry"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#入口-entry"}),"#"),"入口 entry"),Object(t.b)("p",null,"如果通过 ",Object(t.b)("inlineCode",{parentName:"p"},"entry: String|Array|Object")," 配置。当为数组时，会将数组里的文件打包成一个。Object 可以用于多页应用。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// 单页应用\nmodule.exports = {\n//   entry: {\n//     main: './path/entry.js'\n//   }\n  entry: './path/entry.js' \n};\n\n// 多页应用\nmodule.exports = {\n  entry: {\n    pageOne: './src/pageOne/index.js',\n    pageTwo: './src/pageTwo/index.js',\n    pageThree: './src/pageThree/index.js'\n  }\n};\n")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"出口-output"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#出口-output"}),"#"),"出口 output"),Object(t.b)("p",null,"output 告诉 webpack 如何将打包后的文件写入磁盘。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"module.exports = {\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',  // [name] 是个变量，根据 entry 来的\n    path: __dirname + '/dist'\n  }\n};\n\n// 会写到磁盘: ./dist/app.js, ./dist/search.js\n")),Object(t.b)("p",null,"如果利用 CDN，可以："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"module.exports = {\n  //...\n  output: {\n    path: '/home/proj/cdn/assets/[hash]',\n    publicPath: 'https://cdn.example.com/assets/[hash]/'\n  }\n};\n")),Object(t.b)("p",null,"还可以在入口文件中使用 ",Object(t.b)("strong",{parentName:"p"},"webpack_plugin_path")," 变量指定："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"__webpack_public_path__ = myRuntimePublicPath;\n// rest of your application entry\n")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"loader"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#loader"}),"#"),"Loader"),Object(t.b)("p",null,"默认情况下，webpack 只认识 .js 和 .json 文件。如果有其它类型文件，如 css，则需要使用 loader 将它转换为 js 模块。"),Object(t.b)("p",null,"loader 可以配置 test 和 use。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const path = require('path');\nmodule.exports = {\n  output: {\n    filename: 'my-first-webpack.bundle.js'\n  },\n  module: {\n    rules: [\n      { test: /\\.txt$/, use: 'raw-loader' }\n    ]\n  }\n};\n")),Object(t.b)("p",null,"上面代码相当于告诉 webpack，当遇到 ",Object(t.b)("inlineCode",{parentName:"p"},"require() / import")," 引入 .txt 文件的语句时，使用 raw-loader 来转换它。"),Object(t.b)("p",null,"有三种方式可以配置 loader。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"文件，如 webpack.config.js。"),Object(t.b)("li",{parentName:"ul"},"行内：特别指定 import 语句")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"// 普通使用法：资源和loader 之间通过 ! 分开\nimport Styles from 'style-loader!css-loader?modules!./styles.css';\n\n// ! 禁用普通loaders\nimport Styles from '!style-loader!css-loader?modules!./styles.css';\n\n// !! 禁用所有loader(preLoaders、loaders、postLoaders)\nimport Styles from '!!style-loader!css-loader?modules!./styles.css';\n\n// -! 禁用preLoaders、loaders\nimport Styles from '-!style-loader!css-loader?modules!./styles.css';\n\n// 可以通过 ? 传递参数 k=v&k1=v1 或 json 对象 ?{'k':'v'}\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"cli")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'\n")),Object(t.b)("p",null,"loader 的特点：\n1. loaders 是链式调用的，从后往前处理\n2. loaders 可以是同步和异步\n3. loaders 可以配置 options 参数"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"编写-loader"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#编写-loader"}),"#"),"编写 Loader"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"tapable"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#tapable"}),"#"),"tapable"),Object(t.b)("p",null,"webpack 插件内部实现是自己写的一个名叫 tapable 库，如果不学习一下它，看插件这部分内容可能会很蒙。"),Object(t.b)("p",null,"tapable 是一个类似 nodejs EventEmitter 的发布订阅模式库，不过它要强大的多。它提供了一些 api："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'const {\n    SyncHook,\n    SyncBailHook,\n    SyncWaterfallHook,\n    SyncLoopHook,\n    AsyncParallelHook,\n    AsyncParallelBailHook,\n    AsyncSeriesHook,\n    AsyncSeriesBailHook,\n    AsyncSeriesWaterfallHook\n} = require("tapable");\n')),Object(t.b)("p",null,"先感受一下用法："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const { SyncHook } = require(\"tapable\");\nlet queue = new SyncHook(['name'])\nqueue.tap('1', function (name) {\n    console.log(11, name)\n})\nqueue.tap('2', function (name) {\n    console.log(22, name)\n})\nqueue.call('hi')\n// 结果\n// 11 'hi'\n// 22 'hi'\n")),Object(t.b)("p",null,Object(t.b)("img",l({parentName:"p"},{src:"./index/2.png",alt:null}))),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"钩子的分类")),Object(t.b)("p",null,"钩子可以按同步和异步分类，分为。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"Sync 开头的是同步钩子，只能用 tap 绑定事件，用",Object(t.b)("inlineCode",{parentName:"p"},"call()"),"触发，绑定事件时需要传入事件名和事件函数；")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"Async 开头的是异步钩子，可以用 tap、tapAsync、tapPromise 绑定事件，但是它没有 call 方法，对应的需要用",Object(t.b)("inlineCode",{parentName:"p"},"callAsync()"),"、",Object(t.b)("inlineCode",{parentName:"p"},"promise()"),"触发。"))),Object(t.b)("p",null,"同步钩子只支持串行，即执行完一个再执行下一个。异步钩子分为串行和并行。并行相当于 Promise.all()。"),Object(t.b)("p",null,"钩子还可以按功能来分类，分为。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},Object(t.b)("inlineCode",{parentName:"p"},"Hook"),":普通钩子， 与事件函数执行的返回值无关；")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},Object(t.b)("inlineCode",{parentName:"p"},"BailHook"),": 保险钩子 ，一旦事件函数返回 null，则后面的钩子不再执行；")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},Object(t.b)("inlineCode",{parentName:"p"},"WaterfallHook"),": 瀑布流钩子， 上一个事件函数执行结果会作为参数传递给下一个事件函数，如果当前没有返回值，则上一个返回结果会穿透给下一个函数。")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},Object(t.b)("inlineCode",{parentName:"p"},"LoopHook"),": 循环钩子，如果事件函数返回值不为 undefined，则重复执行，否则(即return 或 return undefined)会执行下一个。"))),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"备注")),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"所有的钩子都接受一个可选参数，用来声明事件函数要接收的参数。如下：")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const { SyncHook } = require(\"tapable\");\n// 只声明了一个参数name，结果 call 时传入了多的参数，会被忽略掉\nlet queue = new SyncHook(['name'])\nqueue.tap('1', function (name, age) {\n    console.log(11, name, age)  // 11, zhangsan, undefined\n})\nqueue.call('zhangsan', 12)\n")),Object(t.b)("ol",{start:2},Object(t.b)("li",{parentName:"ol"},"拦截器 intercept() 方法可以钩子运行期间做一些事情。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'myCar.hooks.calculateRoutes.intercept({\n    call: (source, target, routesList) => {\n        console.log("Starting to calculate routes");\n    },\n    register: (tapInfo) => {\n        // tapInfo = { type: "promise", name: "GoogleMapsPlugin", fn: ... }\n        console.log(`${tapInfo.name} is doing its job`);\n        return tapInfo; // may return a new tapInfo object\n    },\n    loop:(...args) =>{},\n    tap: (tap) => {}\n})\n')),Object(t.b)("ol",{start:3},Object(t.b)("li",{parentName:"ol"},"context 对象，可以通过这个对象传递自己需要的数据给后续插件或拦截器。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'myCar.hooks.accelerate.intercept({\n    context: true,\n    tap: (context, tapInfo) => {\n        // tapInfo = { type: "sync", name: "NoisePlugin", fn: ... }\n        console.log(`${tapInfo.name} is doing it\'s job`);\n\n        // `context` starts as an empty object if at least one plugin uses `context: true`.\n        // If no plugins use `context: true`, then `context` is undefined.\n        if (context) {\n            // Arbitrary properties can be added to `context`, which plugins can then access.\n            context.hasMuffler = true;\n        }\n    }\n});\n\nmyCar.hooks.accelerate.tap({\n    name: "NoisePlugin",\n    context: true\n}, (context, newSpeed) => {\n    if (context && context.hasMuffler) {\n        console.log("Silence...");\n    } else {\n        console.log("Vroom!");\n    }\n});\n')),Object(t.b)("ol",{start:4},Object(t.b)("li",{parentName:"ol"},"HookMap 是用来映射 key -> Hook 的一个帮助类。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'const keyedHook = new HookMap(key => new SyncHook(["arg"]))\nkeyedHook.tap("some-key", "MyPlugin", (arg) => { /* ... */ });\nkeyedHook.tapAsync("some-key", "MyPlugin", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise("some-key", "MyPlugin", (arg) => { /* ... */ });\nconst hook = keyedHook.get("some-key");\nif(hook !== undefined) {\n    hook.callAsync("arg", err => { /* ... */ });\n}\n')),Object(t.b)("ol",{start:5},Object(t.b)("li",{parentName:"ol"},"MultiHook 可以将多个 hook 合起来一起操作。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'const { MultiHook } = require("tapable");\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n')),Object(t.b)("p",null,"下面详细看一下各个钩子的用法。"),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"1. SyncHook")),Object(t.b)("p",null,"串行同步执行，当调用 ",Object(t.b)("inlineCode",{parentName:"p"},"call()"),"方法时它会一个个执行 tap 绑定的函数，如下。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const { SyncHook } = require(\"tapable\");\nlet queue = new SyncHook(['name'])\nqueue.tap('1', function (name) {\n    console.log(11, name)\n})\nqueue.tap('2', function (name) {\n    console.log(22, name)\n})\nqueue.call('hi')\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"2. SyncBailHook")),Object(t.b)("p",null,"同步保险钩子，如果有一个事件函数返回值为 null 则停止执行后面的事件函数。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let {SyncBailHook} = require('tapable')\nlet h = new SyncBailHook(['name'])\nh.tap('1', function (name) {\n    console.log('1', name)\n})\nh.tap('2', function (name) {\n    console.log('2', name)\n    return null\n})\nh.call('hi')\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"3. SyncWaterfallHook")),Object(t.b)("p",null,"同步瀑布流钩子，上一个事件函数的返回值会作为下一个事件函数的参数，如果当前没有返回值或返回 undefined 则上一个事件函数的返回值会穿透给下一个事件函数的参数。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let {\n    SyncWaterfallHook\n} = require('tapable')\nlet h = new SyncWaterfallHook(['name'])\nh.tap('1', function (name) {\n    console.log(name, 1)\n    return 11\n})\nh.tap('2', function (data) {\n    console.log(data, 2)\n})\nh.call('zs')\n\n// zs 1\n// 11 2\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"4. SyncLoopHook")),Object(t.b)("p",null,"同步循环钩子，如果当前事件函数的返回值为 undefined，则继续执行下一个，否则一直循环执行。要注意的是返回值不会传递给下一个事件函数，只有瀑布流钩子与返回值有关。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const {SyncLoopHook } = require('tapable')\nlet h = new SyncLoopHook(['name'])\nlet count = 0\nh.tap('1', function (name) {\n    console.log(count)\n    count++\n    if (count === 3) {\n        return \n    }\n    return true\n})\nh.tap('2', function (name) {\n    console.log(name)\n})\nh.call('hi')\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"5. AsyncParallelHook")),Object(t.b)("p",null,"异步并行钩子，可以通过 tap、tapAsync、tapPromise 三种方式绑定事件，对应的需要用 callAsync()、callAsync()、promise() 方法触发，它们的最后一个参数是一个回调函数。"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"tap + callAsync() 搭配，和 SyncHook 效果一样。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let { AsyncParallelHook } = require('tapable')\nlet h = new AsyncParallelHook(['name'])\nconsole.time('cost')\nh.tap('1', function (name) {\n    setTimeout(() => {\n        console.log(1, name)\n    }, 1000)\n})\nh.tap('2', function (name) {\n    setTimeout(() => {\n        console.log(2, name)\n    }, 2000)\n})\nh.callAsync('hi', err => {\n    console.log('err:', err)\n    console.timeEnd('cost')  \n})\n\n// err:undefined\n// cost: 10.181ms\n// 1 hi\n// 2 hi\n")),Object(t.b)("ol",{start:2},Object(t.b)("li",{parentName:"ol"},"tapAsync + callAsync() 搭配，则需要使用事件回调函数的最后一个参数 callback，表示事件执行完成了，如果有一个事件回调函数没有调用 callback()，则不会触发 callAsync() 的回调。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let { AsyncParallelHook } = require('tapable')\nlet h = new AsyncParallelHook(['name'])\nconsole.time('cost')\nh.tapAsync('1', function (name,callback) {\n    setTimeout(() => {\n        console.log(1, name)\n        callback()\n    }, 1000)\n})\nh.tapAsync('2', function (name,callback) {\n    setTimeout(() => {\n        console.log(2, name)\n        callback()   \n    }, 2000)\n})\nh.callAsync('hi', err => {\n    // 假设其中一个不使用callback()，则这里回调不会执行\n    console.log('err:',err)\n    console.timeEnd('cost')\n})\n// 1 hi\n// 2 hi\n// err:undefined\n// cost: 2008.706ms\n")),Object(t.b)("ol",{start:3},Object(t.b)("li",{parentName:"ol"},"tapPromis + promise() 搭配，事件处理函数需要返回一个 promise。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let { AsyncParallelHook } = require('tapable')\nlet h = new AsyncParallelHook(['name'])\nconsole.time('cost')\nh.tapPromise('1', function (name, callback) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(1, name)\n            resolve('xx')\n        }, 1000)\n    })\n})\nh.tapPromise('2', function (name, callback) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(2, name)\n            resolve('xx')\n        }, 2000)\n    })\n})\nh.promise('hi').then((data)=> {\n    // 这里data 不会接收resolve(data)的返回值，除非用 waterfall 类型的钩子\n    console.log(`data:${data}`) \n    console.timeEnd('cost')\n})\n\n// 1 hi\n// 2 hi\n// cost: 2008.312ms\n")),Object(t.b)("ol",{start:4},Object(t.b)("li",{parentName:"ol"},"不要用 tapAsync + promise() 搭配或其它搭配方式，有很多问题，而且从名字来看也是不合理的。")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"6. AsyncParallelBailHook")),Object(t.b)("p",null,"异步并行保险钩子，一旦有事件函数返回值为真值(",Object(t.b)("inlineCode",{parentName:"p"},"if(data)"),")，则终止。"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"tap + callAsync() 搭配。一旦有事件函数返回值为真，则执行 callAsync 回调不再执行其它事件函数。"),Object(t.b)("li",{parentName:"ol"},"tapAsync + callAsync() 搭配，一旦有事件函数的回调 callback(真值)，则执行 callAsync 回调，继续执行其它事件函数。"),Object(t.b)("li",{parentName:"ol"},"tapPromsie + promise() 搭配，一旦有reject()，则执行 promise.then() 的 onRejected，只有全部都 resolve()，才执行promise.then 的 onFullfilled。")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"7. AsyncSeriesHook")),Object(t.b)("p",null,"异步串行钩子"),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"8. AsyncSeriesBailHook")),Object(t.b)("p",null,"异步串行保险钩子"),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"9. AsyncSeriesWaterfallHook")),Object(t.b)("p",null,"异步串行瀑布流钩子"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"插件"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#插件"}),"#"),"插件"),Object(t.b)("p",null,"看完了上面的 tapable 的介绍，再看插件这部分内容就一路通畅了。"),Object(t.b)("p",null,"插件调用方式很多，可以在 webpack.config.js 的 plugins 配置里通过 new 调用，也可以通过 nodejs："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const webpack = require('webpack'); //to access webpack runtime\nconst configuration = require('./webpack.config.js');\nlet compiler = webpack(configuration);\nnew webpack.ProgressPlugin().apply(compiler);\ncompiler.run(function(err, stats) {\n  // ...\n});\n")),Object(t.b)("p",null,"上面代码和 webpack 内部源码很像。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"编写插件"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#编写插件"}),"#"),"编写插件"),Object(t.b)("p",null,"webpack 插件是一个拥有 apply() 方法的类，在 apply 方法里绑定事件，webpack 会在生命周期里触发。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class MyExampleWebpackPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tapAsync( 'MyExampleWebpackPlugin', (compilation, callback) => {\n        // ... 可以写自定义要做的事, webpack 文件发射(emit) 时执行\n\n        compilation.hooks.optimize.tap('HelloCompilationPlugin', () => {\n            // webpack编译期间,优化代码时执行\n            console.log('Assets are being optimized.');\n        });\n        callback()\n      }\n    );\n  }\n}\n")),Object(t.b)("p",null,"同步的钩子只能通过 tap 绑定事件，异步的钩子可以用 tapAsync 绑定事件，但是最后要用 callback() 告诉 webpack 事情做完了，继续往下执行。钩子在下面有介绍。"),Object(t.b)("p",null,"这些插件可以绑定在 webpack 生命周期或编译周期执行。可以加载插件的常用对象有：compiler、compilation 、parser 和 resolvers。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。如果是",Object(t.b)("inlineCode",{parentName:"p"},"--watch"),"模式，这个对象会监听文件的改变后重新编译，并发出额外的事件",Object(t.b)("inlineCode",{parentName:"p"},"watchRun"),"、",Object(t.b)("inlineCode",{parentName:"p"},"watchClose"),"、",Object(t.b)("inlineCode",{parentName:"p"},"invalid"),"，一般用于开发模式，在",Object(t.b)("inlineCode",{parentName:"p"},"webpack-dev-server"),"里被使用。")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"parser: 解析 webpack 正在处理的模块。"))),Object(t.b)("p",null,"常用的钩子列表："),Object(t.b)("table",null,Object(t.b)("thead",{parentName:"table"},Object(t.b)("tr",{parentName:"thead"},Object(t.b)("th",l({parentName:"tr"},{align:null}),"对象"),Object(t.b)("th",l({parentName:"tr"},{align:null}),"钩子"))),Object(t.b)("tbody",{parentName:"table"},Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"compiler"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"run,compile,compilation,make,emit,done")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"compilation"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"buildModule,normalModuleLoader,succeedModule,finishModules,seal,optimize,after-seal")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"Parser"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"program,statement,call,expression")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"Module Factory"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"beforeResolver,afterResolver,module,parser")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"Resolvers"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"hash,bootstrap,localVars,render")))),Object(t.b)("p",null,"具体的列表，点击查看：",Object(t.b)("a",l({parentName:"p"},{href:"https://webpack.js.org/api/compiler-hooks/"}),"webpack API PLUGINS")),Object(t.b)("p",null,"当然，如果不满足于这些钩子，还可以使用 tapable 自定义钩子。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const {SyncHook} = require('tapable');\n\n// 在 `apply` 方法里...\nif (compiler.hooks.myCustomHook) throw new Error('Already in use');\ncompiler.hooks.myCustomHook = new SyncHook(['a', 'b', 'c']);\n\n// 在合适的地方触发\ncompiler.hooks.myCustomHook.call(a, b, c);\n")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"钩子类型"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#钩子类型"}),"#"),"钩子类型"),Object(t.b)("table",null,Object(t.b)("thead",{parentName:"table"},Object(t.b)("tr",{parentName:"thead"},Object(t.b)("th",l({parentName:"tr"},{align:null}),"类型"),Object(t.b)("th",l({parentName:"tr"},{align:null}),"钩子名"),Object(t.b)("th",l({parentName:"tr"},{align:null}),"实例"))),Object(t.b)("tbody",{parentName:"table"},Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"同步钩子"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"SyncHook"),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"SyncBailHook"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"optimizeChunks、optimizeChunkModules"),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"SyncWaterfallHook"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"ModuleTemplate，ChunkTemplate"),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"异步钩子"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"AsyncSeriesHook"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"emit，run")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"AsyncWaterfallHook"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"beforeResolve、afterResolve"),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"AsyncSeriesBailHook"),Object(t.b)("td",l({parentName:"tr"},{align:null})),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"AsyncParallelHook"),Object(t.b)("td",l({parentName:"tr"},{align:null})),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"AsyncSeriesBailHook"),Object(t.b)("td",l({parentName:"tr"},{align:null})),Object(t.b)("td",l({parentName:"tr"},{align:null}))))),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"例子"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#例子"}),"#"),"例子"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"如果我们需要在 webpack 打包后的文件中增加一个",Object(t.b)("inlineCode",{parentName:"p"},"filelist.md"),"，里面显示一个列表，是所有文件的大小信息。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class FileListPlugin {\n  apply(compiler) {\n    // emit 是一个异步钩子，可以用 tapAsync 绑定事件, 当然也可以用 tapPromise/tap 绑定\n    compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, callback) => {\n      // 开始拼接 filelist 里的信息\n      var filelist = 'In this build:\\n\\n';\n      // 遍历要编译输出文件，compilation.assets 包含所有要输出到 dist 的文件信息\n      for (var filename in compilation.assets) {\n        filelist += '- ' + filename + '\\n';\n      }\n      // 在要输出的文件对象里新增一个 filelist.md\n      compilation.assets['filelist.md'] = {\n        source: function() {\n          return filelist;\n        },\n        size: function() {\n          return filelist.length;\n        }\n      };\n      callback();\n    });\n  }\n}\n\nmodule.exports = FileListPlugin;\n")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"打印进度")),Object(t.b)("p",null,"在上面 tapable 部分，介绍过 context 可以用来给后面的插件传递数据。这里我们可以利用它和 ProgressPlugin 插件的 reportProgress() 方法来自定义打印进度。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"compiler.hooks.emit.tapAsync({\n  name: 'MyPlugin',\n  context: true\n}, (context, compiler, callback) => {\n  const reportProgress = context && context.reportProgress;\n  if (reportProgress) reportProgress(0.95, 'Starting work');\n  setTimeout(() => {\n    if (reportProgress) reportProgress(0.95, 'Done work');\n    callback();\n  }, 1000);\n});\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"reportProgress(percentage, ...args)"),"的第一个参数 percentage 没有用，ProgressPlugin 会基于当前的钩子来计算进度。",Object(t.b)("inlineCode",{parentName:"p"},"...args"),"被用来报告给用户。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"常用插件列表"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#常用插件列表"}),"#"),"常用插件列表"),Object(t.b)("table",null,Object(t.b)("thead",{parentName:"table"},Object(t.b)("tr",{parentName:"thead"},Object(t.b)("th",l({parentName:"tr"},{align:null}),"插件"),Object(t.b)("th",l({parentName:"tr"},{align:null}),"描述"))),Object(t.b)("tbody",{parentName:"table"},Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"BabelMinifyWebpackPlugin"),Object(t.b)("td",l({parentName:"tr"},{align:null}))),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),Object(t.b)("a",l({parentName:"td"},{href:"https://webpack.js.org/plugins/banner-plugin/"}),"webpack.BannerPlugin")),Object(t.b)("td",l({parentName:"tr"},{align:null}),"用于在打包文件头添加注释或一段文本")))),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"配置"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#配置"}),"#"),"配置"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"webpack-模块"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#webpack-模块"}),"#"),"webpack 模块"),Object(t.b)("p",null,"webpack 模块可以是："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"es6 import"),Object(t.b)("li",{parentName:"ol"},"commonjs require()"),Object(t.b)("li",{parentName:"ol"},"amd 的 define 和 require"),Object(t.b)("li",{parentName:"ol"},"css/sass/less 中的 @import"),Object(t.b)("li",{parentName:"ol"},"样式表的 url() 或 html ",Object(t.b)("inlineCode",{parentName:"li"},"<img src=xxx>")," 里的图像 url")),Object(t.b)("p",null,"社区"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"模块解析"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#模块解析"}),"#"),"模块解析"),Object(t.b)("p",null,"resolver 表示一个用来解析定位模块绝对路径的包。webpack 使用 ",Object(t.b)("inlineCode",{parentName:"p"},"enhanced-resolve"),"来解析路径。它可以解析三种文件路径："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"绝对路径")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"import '/home/me/file';\nimport 'C:\\\\Users\\\\me\\\\file';\n")),Object(t.b)("ol",{start:2},Object(t.b)("li",{parentName:"ol"},"相对路径")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"import '../src/file1';\nimport './file2';\n")),Object(t.b)("p",null,"这种情况会将资源文件的目录作为上下文目录，在 import 或 require 时生成模块的绝对路径。"),Object(t.b)("ol",{start:3},Object(t.b)("li",{parentName:"ol"},"模块路径")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"import 'module';\nimport 'module/lib/file';\n")),Object(t.b)("p",null,"会从 ",Object(t.b)("inlineCode",{parentName:"p"},"resolve.modules")," 里搜索模块，你还可以指定 ",Object(t.b)("inlineCode",{parentName:"p"},"resolve.alias"),"。"),Object(t.b)("p",null,"根据上面规则解析为路径后，路径有可能是文件或目录。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"如果路径为文件：",Object(t.b)("ul",{parentName:"li"},Object(t.b)("li",{parentName:"ul"},"有文件扩展名，则绑定"),Object(t.b)("li",{parentName:"ul"},"否则，使用 resolve.extensions 解析文件扩展名"))),Object(t.b)("li",{parentName:"ul"},"如果路径为目录，则",Object(t.b)("ul",{parentName:"li"},Object(t.b)("li",{parentName:"ul"},"有 package.json，按 ",Object(t.b)("inlineCode",{parentName:"li"},"resolve.mainFields"),"顺序查找字段。第一个匹配的会绑定。"),Object(t.b)("li",{parentName:"ul"},"上面找不到，则按",Object(t.b)("inlineCode",{parentName:"li"},"resolve.mainFiles"),"顺序查找指定的文件名"),Object(t.b)("li",{parentName:"ul"},"使用",Object(t.b)("inlineCode",{parentName:"li"},"resolve.extensions"),"解析文件扩展名")))),Object(t.b)("p",null,"resolveLoader 选项可以专门配置 loaders 的解析路径。"),Object(t.b)("p",null,"加载过的文件都会被缓存，在",Object(t.b)("inlineCode",{parentName:"p"},"watch"),"模式下，只有修改的文件会清除缓存，非",Object(t.b)("inlineCode",{parentName:"p"},"watch"),"模式下，每次编译都会清除缓存。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"依赖图"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#依赖图"}),"#"),"依赖图"),Object(t.b)("p",null,"当有文件依赖另一个文件时，webpack 会将它看作是依赖项。webpack 会根据入口构建依赖关系图。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"部署目标"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#部署目标"}),"#"),"部署目标"),Object(t.b)("p",null,"因为 js 可以用于浏览器和服务器，所以 webpack 可以设置部署目标。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"module.exports = {\n  target: 'node'\n};\n")),Object(t.b)("p",null,"上面示例中，webpack 会根据 node 环境编译，会编译成 require，而不是使用内置的 ",Object(t.b)("strong",{parentName:"p"},"webpack_require"),"。"),Object(t.b)("p",null,"可以编译多个目标："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"const path = require('path');\nconst serverConfig = {\n  target: 'node',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'lib.node.js'\n  }\n  //…\n};\n\nconst clientConfig = {\n  target: 'web', // <=== can be omitted as default is 'web'\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'lib.js'\n  }\n  //…\n};\n\nmodule.exports = [ serverConfig, clientConfig ];\n")),Object(t.b)("p",null,"上面的示例将在您的文件夹中创建一个lib.js和lib.node.js文件dist。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"manifest"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#manifest"}),"#"),"Manifest"),Object(t.b)("p",null,"使用 webpack 打包的应用，有 3 种类型的代码。"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"自己写的或团队写的代码"),Object(t.b)("li",{parentName:"ol"},"第三方包的代码，通常叫 vendor"),Object(t.b)("li",{parentName:"ol"},"webpack runtime 和 manifest，用来连接所有模块的逻辑代码，")),Object(t.b)("p",null,"根据官方的解释: "),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"manifest 是 webpack 在浏览器端运行时 runtime 产生的加载解析模块、连接已加载模块的逻辑代码。"),Object(t.b)("li",{parentName:"ol"},"多页面打包时，一般会提取公共文件 vendor 做缓存，但是有时修改了业务代码，vendor 的 chunkhash 也会变化，这是因为 webpack 将公共代码和 runtime 时的 manifest 打包成了 vendor，修改业务代码可能影响了 runtime，所以 vendor 的 chunkhash 也变化了，这会造成缓存失效。为了解决这个问题，可以将 manifest 单独打成一个包。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'optimization: {\n    runtimeChunk: {\n        name: \'manifest\'\n    },\n    splitChunks: {\n        cacheGroups: {\n            // commons: {\n            //     chunks: "initial",\n            //     minChunks: 2, //最小重复的次数\n            //     minSize: 0 //最小提取字节数\n            // },\n            vendor: {\n                test: /node_modules/,\n                chunks: "initial",\n                name: "vendor",\n            }\n        }\n    }\n}\n')),Object(t.b)("p",null,"但是个人做测试时发现，如果没有配置 runtimeChunk，webpack4 并没有将 manifest 打包到 vendor 中，而是将它放在各自的入口文件中。所以修改业务代码，vendor chunkhash不会变化。不过 manifest 确实有很大一部分代码可以公用，所以最好还是将它单独打包出来。打包出来的 mainfest 代码大致如下，其实就是 webpack 打包时自己的代码："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),' (function(modules) { // webpackBootstrap\n    // install a JSONP callback for chunk loading\n    function webpackJsonpCallback(data) {\n        // ...\n    };\n    function checkDeferredModules() {\n         // ...\n    }\n    var installedModules = {};\n    var installedChunks = {\n        "manifest": 0\n    };\n    var deferredModules = [];\n    function __webpack_require__(moduleId) {\n         // ...\n     }\n     // __webpack_require__工具方法等 ...\n })\n ([]);\n')),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"模式"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#模式"}),"#"),"模式"),Object(t.b)("p",null,"通过设置 mode 参数可以配置环境为 development、production(默认) 或 none。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"浏览器兼容性"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#浏览器兼容性"}),"#"),"浏览器兼容性"),Object(t.b)("p",null,"不支持 IE8 及以下。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"tree-sharking"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#tree-sharking"}),"#"),"tree sharking"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"tree sharking"),"是去除无用的代码。webpack4 可以通过在 package.json 文件中指定",Object(t.b)("inlineCode",{parentName:"p"},"sideEffects"),"属性告诉 compiler 哪些文件是 es6 module，从而安全删除未使用的代码。"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"传统的 DCE, dead code elimination 是通过 AST 处理。")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"sideeffect"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#sideeffect"}),"#"),"sideEffect"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"sideEffects"),"表示告诉 webpack 我这个包是否有",Object(t.b)("a",l({parentName:"p"},{href:"https://github.com/webpack/webpack/tree/next/examples/side-effects"}),"副作用"),"(如增加了window属性、复写原生方法等)。"),Object(t.b)("p",null,"默认情况下，面对代码",Object(t.b)("inlineCode",{parentName:"p"},'import { a, b } from "big-module-with-flag"'),"，webpack 会分析代码整个",Object(t.b)("inlineCode",{parentName:"p"},"big-module-with-flag"),"包里的模块，因为根据 ecmascript 规范，其它子模块可能会有副作用。如果加了",Object(t.b)("inlineCode",{parentName:"p"},"sideEffects:false"),"，会被 webpack 改写为：",Object(t.b)("inlineCode",{parentName:"p"},'import { a } from "big-module-with-flag/a"; import { b } from "big-module-with-flag/b"'),"。这样相当于只引入了a.js 和 b.js。"),Object(t.b)("p",null,"好处是：缩小包、加快速度。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"注意事项"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#注意事项"}),"#"),"注意事项"),Object(t.b)("p",null,"要使用 tree sharking，需要注意："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"使用 es6 module，即 import 和 export 语法。"),Object(t.b)("li",{parentName:"ol"},"确保 babel 没有将 es6 module 转换，可以配置 babel ",Object(t.b)("inlineCode",{parentName:"li"},"{module:false}"),"。"),Object(t.b)("li",{parentName:"ol"},"在 package.json 文件中，添加 sideEffect 属性。"),Object(t.b)("li",{parentName:"ol"},"设置 ",Object(t.b)("inlineCode",{parentName:"li"},"mode: production"),"，启用代码压缩和tree sharking。"),Object(t.b)("li",{parentName:"ol"},"class 没有做 tree sharking ，因为无法保证里面的方法只有当前对象使用，可能会被继承的类使用。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"export default"),"的模块进行",Object(t.b)("inlineCode",{parentName:"li"},"import util from 'x'"),"不会被tree sharking。 但是",Object(t.b)("inlineCode",{parentName:"li"},"export default * as"),"会被 tree sharking。")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"为什么要es6-module"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#为什么要es6-module"}),"#"),"为什么要es6 module"),Object(t.b)("p",null,"ES6 module 和 CommonJS 有本质区别："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"只能在顶层出现，不能出现在 function 或 if 里。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"import"),"模块名只能是字符串常量。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"import"),"会被提升到顶部。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"import"),"绑定的变量是不变量，类似 const。如",Object(t.b)("inlineCode",{parentName:"li"},"import a from './a'"),"，a 不能重新赋值。"),Object(t.b)("li",{parentName:"ol"},"commonjs 是动态的，比如下面的代码，不运行不知道加载哪个模块：")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"if(a){\n    require('./a.js')\n}else{\n    require('./b.js')\n}\n")),Object(t.b)("p",null,"所以 es6 module 的依赖关系是确定的，和运行时无关，从而保证了可以进行可靠的静态分析。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"调试-webpack"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#调试-webpack"}),"#"),"调试 webpack"),Object(t.b)("p",null,"如果需要调试 webpack 的打包过程，可以使用命令："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"node --inspect-brk  ./node_modules/webpack/bin/webpack.js --config webpack.config.js\n")),Object(t.b)("p",null,"然后打开 chrome 地址: ",Object(t.b)("inlineCode",{parentName:"p"},"chrome://inspect"),"。点击一下",Object(t.b)("inlineCode",{parentName:"p"},"Remote Target"),"中要调试的程序即可。"),Object(t.b)("p",null,Object(t.b)("img",l({parentName:"p"},{src:"./index/1.png",alt:null}))),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"webpack-打包流程"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#webpack-打包流程"}),"#"),"webpack 打包流程"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"进度"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#进度"}),"#"),"进度"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"2019-7-6 看完了",Object(t.b)("a",l({parentName:"li"},{href:"https://webpack.js.org/concepts/"}),"概念部分内容"))))}p.isMDXComponent=!0},217:function(e,n,a){"use strict";a.d(n,"a",function(){return b}),a.d(n,"b",function(){return s});var t=a(0),l=a.n(t),r=l.a.createContext({}),c=function(e){var n=l.a.useContext(r),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},b=function(e){var n=c(e.components);return l.a.createElement(r.Provider,{value:n},e.children)},o="mdxType",i={inlineCode:"code",wrapper:function(e){return l.a.createElement(l.a.Fragment,{},e.children)}},p=function(e){var n=e.components,a=e.mdxType,t=e.originalType,r=e.parentName,b=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),o=c(n);return l.a.createElement(o[r+"."+a]||o[a]||i[a]||t,n?Object.assign({},b,{components:n}):b)};function s(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var r=a.length,c=new Array(r);c[0]=p;var b={};for(var i in n)hasOwnProperty.call(n,i)&&(b[i]=n[i]);b.originalType=e,b[o]="string"==typeof e?e:t,c[1]=b;for(var s=2;s<r;s++)c[s]=a[s];return l.a.createElement.apply(null,c)}return l.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"}}]);