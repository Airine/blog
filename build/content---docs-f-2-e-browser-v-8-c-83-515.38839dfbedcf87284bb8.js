(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{152:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return c}),n.d(t,"rightToc",function(){return b}),n.d(t,"default",function(){return p});n(0);var r=n(245);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c={id:"v8",title:"V8 引擎原理"},b=[{value:"内存泄露",id:"内存泄露",children:[]},{value:"垃圾回收机制",id:"垃圾回收机制",children:[{value:"标记清除算法",id:"标记清除算法",children:[]},{value:"引用计数（不常用）",id:"引用计数（不常用）",children:[]}]},{value:"面试题",id:"面试题",children:[]},{value:"参考资料",id:"参考资料",children:[]}],i={rightToc:b},o="wrapper";function p(e){var t=e.components,n=l(e,["components"]);return Object(r.b)(o,a({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"内存泄露"},"内存泄露"),Object(r.b)("p",null,"内存泄露(Memory Leak)是指程序中动态分配的内存没有释放，造成系统内存浪费，导致程序运行变慢，甚至系统崩溃等严重后果。"),Object(r.b)("p",null,"有些语言(如 C 语言)，需要程序员手动释放和管理内存。这很麻烦，所以大多数语言提供了自动内存管理，这叫",Object(r.b)("inlineCode",{parentName:"p"},"垃圾回收机制(garbage collector，GC)"),"。"),Object(r.b)("h2",{id:"垃圾回收机制"},"垃圾回收机制"),Object(r.b)("p",null,"JavaScript 引擎有一个后台进程，叫垃圾回收器，它监视所有对象，并删除不可访问的对象。"),Object(r.b)("h3",{id:"标记清除算法"},"标记清除算法"),Object(r.b)("p",null,"标记清除算法的步骤是："),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"垃圾回收器获取根并标记它们。"),Object(r.b)("li",{parentName:"ol"},"根据根，访问并标记所有来自它们的引用。"),Object(r.b)("li",{parentName:"ol"},"然后访问标记的对象并标记它们的引用。以此类推。"),Object(r.b)("li",{parentName:"ol"},"将未标记的对象删除。")),Object(r.b)("h3",{id:"引用计数（不常用）"},"引用计数（不常用）"),Object(r.b)("p",null,"引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。"),Object(r.b)("p",null,"如果一个值不需要了，但是引用次数不为0，垃圾回收机制无法回收这块内存，从而导致内存泄露。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = {}\n")),Object(r.b)("p",null,"上面代码中，",Object(r.b)("inlineCode",{parentName:"p"},"{}"),"会占用一块内存，a 引用了它，所以引用次数为 1，尽管后面的代码没有用到 a，但是它不会被回收，依然会占用内存。"),Object(r.b)("p",null,"通过删除引用，可以让垃圾回收机制回收这块内存。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"a = null\n")),Object(r.b)("p",null,"上面代码，通过设置",Object(r.b)("inlineCode",{parentName:"p"},"a = null"),"，接触了 a 对 {} 的引用，内存就可以被垃圾回收器回收。所以有时候，垃圾回收器并不会很好的工作，为了避免内存泄露，我们需要人工干预。"),Object(r.b)("p",null,"IE9 之前存储循环引用的问题。它的 DOM 和 BOM 对象是以 COM 对象形式实现的，它的垃圾回收机制采用引用计数策略。因此，即使 IE 的 JavaScript 引擎使用标记清除策略实现，但是 JavaScript 访问 COM 对象是基于引用计数的。所以只要 IE 中涉及 COM 对象，就会有循环引用的问题。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'var element = document.getElementById("some_element");\nvar myObject = new Object();\nmyObject.element = element;\nelement.someObject = myObject;\n')),Object(r.b)("p",null,"上面例子，DOM 元素(element)和 JavaScript 对象(myObject)形成循环引用，即使 element 从页面移除，它也不会被回收。所以应该在不需要时，手动消除循环引用。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{}),"myObject.element = null;\nelement.someObject = null;\n")),Object(r.b)("p",null,"IE9 已经将 DOM 和 BOM 转成了 JavaScript 对象，这就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。"),Object(r.b)("h2",{id:"面试题"},"面试题"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"垃圾回收时栈和堆的区别?"),Object(r.b)("li",{parentName:"ul"},"JS里垃圾回收机制是什么，常用的是哪种，怎么处理的?")),Object(r.b)("h2",{id:"参考资料"},"参考资料"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/qq449245884/xiaozhi/issues/36"}),"前端面试：谈谈 JS 垃圾回收机制")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html"}),"JavaScript 内存泄露教程")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/kaola-fed/blog/issues/230"}),"kaola-fed/blog V8垃圾回收机制")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://juejin.im/post/5d1b69b051882579d428d458"}),"Node.js内存管理和V8垃圾回收机制")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://v8.dev/blog/concurrent-marking"}),"Concurrent marking in V8")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/zqjflash/nodejs-memory"}),"nodejs-memory V8的垃圾回收机制与内存限制"))))}p.isMDXComponent=!0},245:function(e,t,n){"use strict";n.d(t,"a",function(){return b}),n.d(t,"b",function(){return u});var r=n(0),a=n.n(r),l=a.a.createContext({}),c=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},b=function(e){var t=c(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},i="mdxType",o={inlineCode:"code",wrapper:function(e){return a.a.createElement(a.a.Fragment,{},e.children)}},p=function(e){var t=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,b=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===t.indexOf(r)&&(n[r]=e[r]);return n}(e,["components","mdxType","originalType","parentName"]),i=c(t);return a.a.createElement(i[l+"."+n]||i[n]||o[n]||r,t?Object.assign({},b,{components:t}):b)};function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,c=new Array(l);c[0]=p;var b={};for(var o in t)hasOwnProperty.call(t,o)&&(b[o]=t[o]);b.originalType=e,b[i]="string"==typeof e?e:r,c[1]=b;for(var u=2;u<l;u++)c[u]=n[u];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);