(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{197:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return b}),t.d(n,"rightToc",function(){return c}),t.d(n,"default",function(){return p});t(0);var a=t(283);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var b={title:"javascript 语法",sidebar_label:"语法"},c=[{value:"var、let 和 const",id:"var、let-和-const",children:[{value:"提升",id:"提升",children:[]},{value:"重复声明",id:"重复声明",children:[]},{value:"暂时性死区",id:"暂时性死区",children:[]},{value:"区别",id:"区别",children:[]}]},{value:"结尾写分号",id:"结尾写分号",children:[{value:"自动插入分号规则",id:"自动插入分号规则",children:[]},{value:"no LineTerminator here 规则",id:"no-lineterminator-here-规则",children:[]},{value:"不写分号注意情况",id:"不写分号注意情况",children:[]}]},{value:"脚本与模块",id:"脚本与模块",children:[{value:"import 声明",id:"import-声明",children:[]},{value:"export 声明",id:"export-声明",children:[]},{value:"函数体",id:"函数体",children:[]},{value:"预处理",id:"预处理",children:[]},{value:"指令序言",id:"指令序言",children:[]}]},{value:"语句",id:"语句",children:[]},{value:"表达式语句",id:"表达式语句",children:[]},{value:"词法",id:"词法",children:[]},{value:"参考资料",id:"参考资料",children:[]}],o={rightToc:c},i="wrapper";function p(e){var n=e.components,t=l(e,["components"]);return Object(a.b)(i,r({},o,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"var、let-和-const"},"var、let 和 const"),Object(a.b)("h3",{id:"提升"},"提升"),Object(a.b)("p",null,"提升是指使用 var 声明的变量、function 声明定义的函数会提升到作用域前面。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"a()\nfunction a(){}\n\nconsole.log(b)  // undefined\nvar b = 3\n")),Object(a.b)("p",null,"上面的代码，a 在",Object(a.b)("inlineCode",{parentName:"p"},"function a()"),"之前使用，b 在",Object(a.b)("inlineCode",{parentName:"p"},"var b"),"之前使用，并没有报错。这就是提升，实际相当于:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = function(){}\na()\n\nvar b \nconsole.log(b)  // undefined\nb = 3\n")),Object(a.b)("p",null,"可以看到，函数 a 的声明和定义都提前了，var 声明的变量 b 的声明提前了，赋值并没有提前，所以输出 b 为 undefind。"),Object(a.b)("p",null,"提升存在的根本原因就是为了解决函数间互相调用的情况"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function test1() {\n    test2()\n}\nfunction test2() {\n    test1()\n}\ntest1()\n")),Object(a.b)("h3",{id:"重复声明"},"重复声明"),Object(a.b)("p",null,"重复 var 声明同一个变量，只有第一次声明有效。后面的定义会覆盖前面的值。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"// --- example 1\nvar a = 1\nvar a = 3\n// 相当于\nvar a \na = 1\na = 3\n\n// --- example 2\nconsole.log(a) // ƒ a() {}\nvar a = 1\nfunction a() {}\n")),Object(a.b)("p",null,"上面 example 2 可以看到，函数的声明定义要优先于变量 var 的声明。因为 function a 后，var a 并没有生效。"),Object(a.b)("h3",{id:"暂时性死区"},"暂时性死区"),Object(a.b)("p",null,"var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function test(){\n  console.log(a)\n  let a\n}\ntest()  // Uncaught ReferenceError: a is not defined\n")),Object(a.b)("h3",{id:"区别"},"区别"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部"),Object(a.b)("li",{parentName:"ul"},"var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用"),Object(a.b)("li",{parentName:"ul"},"var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会"),Object(a.b)("li",{parentName:"ul"},"let 和 const 作用基本一致，但是后者声明的变量不能再次赋值")),Object(a.b)("h2",{id:"结尾写分号"},"结尾写分号"),Object(a.b)("p",null,"最初，行尾使用分号是为了降低编译器的负担。但是今天编译器效率已经足够高，行尾使用分号反而成为了一种语法噪音。"),Object(a.b)("h3",{id:"自动插入分号规则"},"自动插入分号规则"),Object(a.b)("p",null,"自动插入分号的规则有 3 条，如下："),Object(a.b)("p",null,"1、有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"let a = 1\nlet b = 2\n")),Object(a.b)("p",null,"2、有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。"),Object(a.b)("p",null,"根据 JavaScript 标准，表达式和",Object(a.b)("inlineCode",{parentName:"p"},"++"),"之间不能有换行符。如下",Object(a.b)("inlineCode",{parentName:"p"},"[no LineTerminator here]"),"。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{}),"UpdateExpression[Yield, Await]:\n    LeftHandSideExpression[?Yield, ?Await]\n    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++\n    LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]--\n    ++UnaryExpression[?Yield, ?Await]\n    --UnaryExpression[?Yield, ?Await]\n")),Object(a.b)("p",null,"再看下面代码："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{}),"var a = 1, b = 1, c = 1;\na\n++\nb\n++\nc\n")),Object(a.b)("p",null,"根据第 1 条规则，a 后面可以跟 ++，但是根据第 2 条规则，a 与 ++ 之间不能有换行，所以 a 后面会自动插入分号，而 b、c 会变成 2。"),Object(a.b)("p",null,"return 也有","[no LineTerminator here]"," 规则的要求，而带换行符的注释也会被认为有换行符。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function f(){\n    return/*\n        This is a return value.\n    */1;\n}\nf();\n")),Object(a.b)("p",null,"上面代码会返回 undefined。"),Object(a.b)("p",null,"3、源代码结束处，不能形成完整的脚本或模块结构，那么就自动插入分号。"),Object(a.b)("h3",{id:"no-lineterminator-here-规则"},"no LineTerminator here 规则"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"no LineTerminator here"),"规则表示，在规定的结构中不能有换行符，否则会自动插入分号，如上面的例子。"),Object(a.b)("p",null,"规则如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"带标签的 continue 语句，不能在 continue 后插入换行。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"outer:for(var j = 0; j < 10; j++)\n    for(var i = 0; i < j; i++)\n        continue /*no LineTerminator here*/ outter\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"带标签的 break 语句，不能在 break 后插入换行。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"outer:for(var j = 0; j < 10; j++)\n    for(var i = 0; i < j; i++)\n        break /*no LineTerminator here*/ outter\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"return 后面不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"后自增，后自减运算符前不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"throw 和 Exception 之间不能插入换行。会报错",Object(a.b)("inlineCode",{parentName:"li"},"Uncaught SyntaxError: Illegal newline after throw"),"。"),Object(a.b)("li",{parentName:"ul"},"async 关键字后面不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"箭头函数箭头前，不能插入换行。"),Object(a.b)("li",{parentName:"ul"},"yield 之后，不能插入换行。")),Object(a.b)("h3",{id:"不写分号注意情况"},"不写分号注意情况"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"no LineTerminator here"),"规则实际是为了保证自动插入分号符合预期，但是最初 JavaScript 设计遗漏了一些情况。所以需要注意它们。"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"以括号开头的语句。会解析成函数调用。所以下面代码会报错。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"(function(a){\n    console.log(a);\n})()/* 这里没有被自动插入分号 */\n(function(a){\n    console.log(a);\n})()\n")),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},"以数组开头的语句。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = [[]]/* 这里没有被自动插入分号 */\n[3, 2, 1, 0].forEach(e => console.log(e))\n")),Object(a.b)("p",null,"上面代码被理解成了下标运输符和逗号表达式。这里不会报错，对代码调试是噩梦。"),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},"以正则开头的语句。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'var x = 1, g = {test:()=>0}, b = 1/* 这里没有被自动插入分号 */\n/(a)/g.test("abc")\nconsole.log(RegExp.$1)\n')),Object(a.b)("p",null,"上面正则的",Object(a.b)("inlineCode",{parentName:"p"},"/"),"被理解成了除号。"),Object(a.b)("ol",{start:4},Object(a.b)("li",{parentName:"ol"},"以 Template 开头的语句。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'var f = function(){\n  return "";\n}\nvar g = f/* 这里没有被自动插入分号 */\n`Template`.match(/(a)/);\nconsole.log(RegExp.$1)\n')),Object(a.b)("p",null,"我们知道 fn","`","Template","`"," 是会执行函数的。上面代码被解析成了函数执行。"),Object(a.b)("p",null,"在实际项目中，如果不写分号，那么最好使用 eslint。"),Object(a.b)("h2",{id:"脚本与模块"},"脚本与模块"),Object(a.b)("p",null,"JavaScript 有两种源文件，一种叫脚本，一种叫模块(ES6)。脚本可以在浏览器或 node 环境执行，模块只能由 import 引入执行。\n脚本是主动执行的代码，而模块是被调用执行的代码。实际上，区别脚本或模块，可以看是否包含 import 和 export。"),Object(a.b)("p",null,"script 标签可以引入脚本或模块，如果要引入模块，需要加",Object(a.b)("inlineCode",{parentName:"p"},'type="module"'),"。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'<script type="module" src="xxxxx.js"><\/script>\n')),Object(a.b)("p",null,"上面代码，如果不加",Object(a.b)("inlineCode",{parentName:"p"},'type="module"'),"，浏览器认为这是一个脚本，而不是模块，所以如果里面写了 export，就会报错。"),Object(a.b)("p",null,"脚本可以包含语句，而模块可以包含语句、import 声明和 export 声明。"),Object(a.b)("h3",{id:"import-声明"},"import 声明"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"import"),"声明有两种用法。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import 'mod'         // 引入模块\nimport v from 'mod'  // 将模块导出的默认值赋给变量v\n")),Object(a.b)("p",null,"单纯引入模块，只是为了执行模块。带 from，则是将模块的信息变成本地变量使用。"),Object(a.b)("p",null,"带 from 的 import 又细分为三种用法。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import x from \"./a.js\"    // 1.引入默认值\nimport {a as x, modify} from './a.js'  // 2.引入模块中的变量\nimport * as x from './a.js'    // 3.将模块所有变量以属性形式挂在对象x上\n\n// 第一种方式还可以与后面两种混合使用,语法要求不带 as 的默认值永远在最前面\nimport d, {a as x, modify} from './a.js'\nimport d, * as x from './a.js'\n")),Object(a.b)("p",null,"注意，这里的变量仍然受原来模块的控制。"),Object(a.b)("h3",{id:"export-声明"},"export 声明"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"export"),"的用法有下面几种:"),Object(a.b)("p",null,"1、",Object(a.b)("inlineCode",{parentName:"p"},"export"),"后面跟变量名列表，如",Object(a.b)("inlineCode",{parentName:"p"},"export {a, b, c}"),"。"),Object(a.b)("p",null,"2、",Object(a.b)("inlineCode",{parentName:"p"},"export"),"可以加在任何声明语句前，如 var、function(含 async 和 generator)、class、let、const。"),Object(a.b)("p",null,"3、",Object(a.b)("inlineCode",{parentName:"p"},"export default"),",导出一个默认值"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"export default"),"可以用于",Object(a.b)("inlineCode",{parentName:"p"},"class"),"、",Object(a.b)("inlineCode",{parentName:"p"},"function"),"和表达式。这里导出的变量没有名字，可以用",Object(a.b)("inlineCode",{parentName:"p"},"import x from './a.js'")," 语法引入。"),Object(a.b)("p",null,"当它导出一个变量时，实际上会导出变量的值，之后对变量重新赋值，不影响导出的值。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"a.js")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"let a = 1\nfunction modify(){\n    a = 2\n}\nexport default a\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"b.js")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import a from './a.js'\na  // 1\nmodify()\na  // 1\n")),Object(a.b)("p",null,"当然，如果导出的是对象，可以给对象添加属性。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"a.js")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"let a = {}\nfunction modify(){\n    a.x = 1\n}\nexport default a\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"b.js")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import a from './a.js'\na  // {}\nmodify()\na  // {x:1}\n")),Object(a.b)("p",null,"4、",Object(a.b)("inlineCode",{parentName:"p"},"export from"),"语法，从文件导出。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"x.js")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"export a from 'a.js'\nexport b from 'b.js'\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"main.js")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{}),"import {a, b} from 'x.js'\n")),Object(a.b)("h3",{id:"函数体"},"函数体"),Object(a.b)("p",null,"宏任务可能会执行的代码包括脚本、模块和函数体。"),Object(a.b)("p",null,"函数体多了 return 语句，函数体可以分为四种："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"普通函数体"),Object(a.b)("li",{parentName:"ol"},"异步函数体"),Object(a.b)("li",{parentName:"ol"},"生成器函数体"),Object(a.b)("li",{parentName:"ol"},"异步生成器函数体")),Object(a.b)("p",null,"它们的区别在于，能否使用 await 或 yield 语句。"),Object(a.b)("h3",{id:"预处理"},"预处理"),Object(a.b)("p",null,"JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程会提前处理",Object(a.b)("inlineCode",{parentName:"p"},"var/let/const"),"、",Object(a.b)("inlineCode",{parentName:"p"},"function/class"),"。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"var a = 1;\n\nfunction foo() {\n    var o= {a:3}\n    with(o) {\n        var a = 2;\n    }\n    console.log(o.a);   // 2\n    console.log(a);     // undefined\n}\n\nfoo();\n")),Object(a.b)("p",null,"function 声明出现在 if 等语句中时，只会提前声明，不再提前赋值。"),Object(a.b)("p",null,"class 声明前使用 class 名，会报错。它也会预处理，但是在声明前访问会报错。另外 class 声明不会穿透 if 等语句结构，所以只有写在全局才有声明作用。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"var c = 1;\nfunction foo(){\n    console.log(c);   // Uncaught ReferenceError: Cannot access 'c' before initialization\n    class c {}\n}\nfoo();\n")),Object(a.b)("h3",{id:"指令序言"},"指令序言"),Object(a.b)("p",null,'脚本和模块都支持指令序言(Directive Prologs)。它规定了给 JavaScript 代码添加元信息的方式。"use strict"是标准中规定的唯一一种指令序言。但指令序言的目的，是为了给引擎和实现者一些统一的表达方式，在静态扫描时指定代码的一些特性。'),Object(a.b)("p",null,"指令序言只能出现在脚本、模块和函数体的最前面。否则，它不是指令序言。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'function doSth(){\n    //......\n}\n"use strict";  // 不是指令序言\nvar a = 1;\n//......\n')),Object(a.b)("h2",{id:"语句"},"语句"),Object(a.b)("p",null,"语句\n声明"),Object(a.b)("h2",{id:"表达式语句"},"表达式语句"),Object(a.b)("h2",{id:"词法"},"词法"),Object(a.b)("h2",{id:"参考资料"},"参考资料"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://time.geekbang.org/column/article/87179"}),"重学前端")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://www.codesky.me/archives/be-careful-what-you-copy-invisibly-inserting-usernames-into-text-with-zero-width-characters.wind"}),"小心你复制的内容：使用零宽字符将用户名不可见的插入文本中")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://juejin.im/post/5b87a6e26fb9a019b953ee8b"}),"零宽度字符：和谐？屏蔽？不存在的"))))}p.isMDXComponent=!0},283:function(e,n,t){"use strict";t.d(n,"a",function(){return c}),t.d(n,"b",function(){return u});var a=t(0),r=t.n(a),l=r.a.createContext({}),b=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=b(e.components);return r.a.createElement(l.Provider,{value:n},e.children)};var o="mdxType",i={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},p=function(e){var n=e.components,t=e.mdxType,a=e.originalType,l=e.parentName,c=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),o=b(n),p=t,u=o[l+"."+p]||o[p]||i[p]||a;return n?r.a.createElement(u,Object.assign({},c,{components:n})):r.a.createElement(u,c)};function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,b=new Array(l);b[0]=p;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=e,c[o]="string"==typeof e?e:a,b[1]=c;for(var u=2;u<l;u++)b[u]=t[u];return r.a.createElement.apply(null,b)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);