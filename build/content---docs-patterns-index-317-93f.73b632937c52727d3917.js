(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{101:function(e,a,n){"use strict";n.r(a),n.d(a,"frontMatter",function(){return b}),n.d(a,"rightToc",function(){return c}),n.d(a,"default",function(){return o});n(0);var t=n(217);function l(){return(l=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}function r(e,a){if(null==e)return{};var n,t,l=function(e,a){if(null==e)return{};var n,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(l[n]=e[n]);return l}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var b={title:"设计模式简介",sidebar_label:"简介"},c=[{value:"面向对象和UML类图",id:"面向对象和uml类图",children:[{value:"面向对象的意义",id:"面向对象的意义",children:[]},{value:"UML类图",id:"uml类图",children:[]}]},{value:"设计原则与编程技巧",id:"设计原则与编程技巧",children:[{value:"什么是设计",id:"什么是设计",children:[]},{value:"SOLID五大设计原则",id:"solid五大设计原则",children:[]},{value:"第二题",id:"第二题",children:[]}]}],i={rightToc:c},p="wrapper";function o(e){var a=e.components,n=r(e,["components"]);return Object(t.b)(p,l({},i,n,{components:a,mdxType:"MDXLayout"}),Object(t.b)("p",null,"设计模式是一套让代码可重用，可读，可靠的经验总结。它可以分为三类："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。"),Object(t.b)("li",{parentName:"ul"},"结构型模式：把类或对象结合在一起形成一个更大的结构。"),Object(t.b)("li",{parentName:"ul"},"行为型模式：类和对象如何交互，及划分责任和算法。")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"面向对象和uml类图"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#面向对象和uml类图"}),"#"),"面向对象和UML类图"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"面向对象的意义"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#面向对象的意义"}),"#"),"面向对象的意义"),Object(t.b)("p",null,"面向对象的本质实际是对数据进行结构化，即归类，这是为了更加方便的管理代码。对于计算机来说，结构化的才是最简单的。"),Object(t.b)("p",null,"面向对象的三要素: 继承、封装、多态"),Object(t.b)("p",null,"继承"),Object(t.b)("p",null,"js 里通过 extends 来继承类。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-javascript"}),"class Person{\n    constructor(name){\n        this.name = name\n    }\n}\n\nclass Student extends Person{\n    constructor(name, classroom){\n        super(name)\n        this.classroom = classroom \n    }\n    study(){\n        //...\n    }\n}\n")),Object(t.b)("p",null,"封装"),Object(t.b)("p",null,"面向对象语言中的封装是通过下面三个关键词来限定属性、方法的访问权限。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"public"),": 公开的，父类、子类、实例都可以访问。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"protected"),": 保护的，父类、子类可以访问。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"private"),": 私有的，只有当前类可以访问。")),Object(t.b)("p",null,"在 js 中没有这种语法，可以使用 typescript 来规范。"),Object(t.b)("p",null,"多态"),Object(t.b)("p",null,"多态是子类可以重写父类的方法，或者同名方法可以根据参数个数或类型的不同表示不同功能。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"uml类图"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#uml类图"}),"#"),"UML类图"),Object(t.b)("p",null,"UML类图用来描述类和类之间的关系。"),Object(t.b)("p",null,"每个类有类名，属性和方法。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"public"),"使用 + 号"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"protected"),"使用 # 号"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"private"),"使用 - 号")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"关系")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"泛化：表示继承，使用空心箭头。"),Object(t.b)("li",{parentName:"ul"},"关联：表示引用，使用实心箭头")),Object(t.b)("p",null,Object(t.b)("img",l({parentName:"p"},{src:"./oop/a.png",alt:null}))),Object(t.b)("p",null,"上面的这张图表示 A,B 类继承自 Person类，Person中引用了 House类。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"设计原则与编程技巧"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#设计原则与编程技巧"}),"#"),"设计原则与编程技巧"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"什么是设计"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#什么是设计"}),"#"),"什么是设计"),Object(t.b)("p",null,"unix/linux设计哲学一书的总结："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"小即是美。"),Object(t.b)("li",{parentName:"ol"},"让每个程序只做好一件事。"),Object(t.b)("li",{parentName:"ol"},"快速建立原型，给用户用，使用过程中根据反馈和自己的规划继续完成。"),Object(t.b)("li",{parentName:"ol"},"舍弃高效率而取可移植性，可移植性>高效率，因为计算机配置是不断升高的。"),Object(t.b)("li",{parentName:"ol"},"采用纯文本来存储数据，即可读性，让适合人阅读，不要用二进制之类。"),Object(t.b)("li",{parentName:"ol"},"充分利用软件的杠杆效应(软件复用)。"),Object(t.b)("li",{parentName:"ol"},"使用 shell 脚本来提高杠杆效应和可移植性。"),Object(t.b)("li",{parentName:"ol"},"避免强制性的用户界面。"),Object(t.b)("li",{parentName:"ol"},"让每个程序都称为过滤器。")),Object(t.b)("p",null,"小准则："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"允许用户定制环境。"),Object(t.b)("li",{parentName:"ol"},"尽量使操作系统内核小而轻量化。"),Object(t.b)("li",{parentName:"ol"},"使用小写字母并尽量简短。"),Object(t.b)("li",{parentName:"ol"},"沉默是金。"),Object(t.b)("li",{parentName:"ol"},"各部分之和大于整体。"),Object(t.b)("li",{parentName:"ol"},"寻求 90% 的解决方案。不要什么都做到完美，因为会耗费很大精力。")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"solid五大设计原则"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#solid五大设计原则"}),"#"),"SOLID五大设计原则"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"S: 单一职责原则：一个程序只做好一件事，如果功能复杂就拆分开"),Object(t.b)("li",{parentName:"ul"},"O: 开放封闭原则：对扩展开放，对修改封闭。增加需求时，扩展新代码，而非修改已有代码。"),Object(t.b)("li",{parentName:"ul"},"L: 李氏置换原则：子类能覆盖父类，父类能出现的地方子类就能出现，js使用较少（继承使用较少）。"),Object(t.b)("li",{parentName:"ul"},"I: 接口独立原则：保持接口的单一独立，避免出现胖接口。js没有接口，使用较少。"),Object(t.b)("li",{parentName:"ul"},"D: 依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现。js中使用较少(没有接口&弱类型)。")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"第二题"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#第二题"}),"#"),"第二题"),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"某停车场，分3层，每层100车位 "),Object(t.b)("li",{parentName:"ol"},"每个车位能监控到车辆的驶入和离开"),Object(t.b)("li",{parentName:"ol"},"车辆进入前，显示每层的空余车位数量"),Object(t.b)("li",{parentName:"ol"},"车辆进入时，摄像头可识别车辆号和时间"),Object(t.b)("li",{parentName:"ol"},"车辆出来时，出口显示器显示车牌号和停车时长")))}o.isMDXComponent=!0},217:function(e,a,n){"use strict";n.d(a,"a",function(){return c}),n.d(a,"b",function(){return u});var t=n(0),l=n.n(t),r=l.a.createContext({}),b=function(e){var a=l.a.useContext(r),n=a;return e&&(n="function"==typeof e?e(a):Object.assign({},a,e)),n},c=function(e){var a=b(e.components);return l.a.createElement(r.Provider,{value:a},e.children)},i="mdxType",p={inlineCode:"code",wrapper:function(e){return l.a.createElement(l.a.Fragment,{},e.children)}},o=function(e){var a=e.components,n=e.mdxType,t=e.originalType,r=e.parentName,c=function(e,a){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===a.indexOf(t)&&(n[t]=e[t]);return n}(e,["components","mdxType","originalType","parentName"]),i=b(a);return l.a.createElement(i[r+"."+n]||i[n]||p[n]||t,a?Object.assign({},c,{components:a}):c)};function u(e,a){var n=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var r=n.length,b=new Array(r);b[0]=o;var c={};for(var p in a)hasOwnProperty.call(a,p)&&(c[p]=a[p]);c.originalType=e,c[i]="string"==typeof e?e:t,b[1]=c;for(var u=2;u<r;u++)b[u]=n[u];return l.a.createElement.apply(null,b)}return l.a.createElement.apply(null,n)}o.displayName="MDXCreateElement"}}]);