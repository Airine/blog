(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{191:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return i}),n.d(t,"rightToc",function(){return r}),n.d(t,"default",function(){return o});n(0);var l=n(301);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var l in n)Object.prototype.hasOwnProperty.call(n,l)&&(e[l]=n[l])}return e}).apply(this,arguments)}function b(e,t){if(null==e)return{};var n,l,a=function(e,t){if(null==e)return{};var n,l,a={},b=Object.keys(e);for(l=0;l<b.length;l++)n=b[l],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(l=0;l<b.length;l++)n=b[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i={title:"css 选择器",sidebar_label:"选择器"},r=[{value:"简单选择器",id:"简单选择器",children:[{value:"全体选择器",id:"全体选择器",children:[]},{value:"标签选择器",id:"标签选择器",children:[]},{value:"class 选择器",id:"class-选择器",children:[]},{value:"id 选择器",id:"id-选择器",children:[]},{value:"属性选择器",id:"属性选择器",children:[]},{value:"伪类选择器",id:"伪类选择器",children:[]}]},{value:"选择器的组合",id:"选择器的组合",children:[]},{value:"选择器的优先级",id:"选择器的优先级",children:[]},{value:"伪元素",id:"伪元素",children:[{value:"::first-line",id:"first-line",children:[]},{value:"::first-letter",id:"first-letter",children:[]},{value:"before 和 after",id:"before-和-after",children:[]},{value:":before 和 ::before 的区别",id:"before-和-before-的区别",children:[]}]},{value:"实践规则",id:"实践规则",children:[]}],c={rightToc:r},p="wrapper";function o(e){var t=e.components,n=b(e,["components"]);return Object(l.b)(p,a({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"选择器由简单到复杂，可以分类为："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"简单选择器: 针对某一特征选中元素。"),Object(l.b)("li",{parentName:"ul"},"复合选择器: 连续写在一起的简单选择器，根据元素自身特征选择单个元素。"),Object(l.b)("li",{parentName:"ul"},"复杂选择器: 由空格、>、～、+、|| 连接的复合选择器"),Object(l.b)("li",{parentName:"ul"},"选择器列表：由逗号分隔的复杂选择器，表示或。")),Object(l.b)("h2",{id:"简单选择器"},"简单选择器"),Object(l.b)("p",null,"简单选择器有："),Object(l.b)("h3",{id:"全体选择器"},"全体选择器"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"*")," "),Object(l.b)("h3",{id:"标签选择器"},"标签选择器"),Object(l.b)("p",null,"标签选择器有时候可能要加入命名空间，比如 svg 和 html 里都有 a 元素。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"@namespace svg url(http://www.w3.org/2000/svg);\n@namespace html url(http://www.w3.org/1999/xhtml);\nsvg|a {\n  stroke:blue;\n  stroke-width:1;\n}\n\nhtml|a {\n  font-size:40px\n}\n")),Object(l.b)("h3",{id:"class-选择器"},"class 选择器"),Object(l.b)("h3",{id:"id-选择器"},"id 选择器"),Object(l.b)("h3",{id:"属性选择器"},"属性选择器"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-css"}),'a[href]    : 有属性的\na[href="#"]: 完全匹配#\na[href~="a b"]: 属性值是空格分开的列表，有其中一个值则匹配\na[href^="#"]: 以#开头的\na[href$="#"]: 以#结尾的\na[href*="#"]: 包含#的\na[href|="#"]: 以 # 开头或以 #- 开头\n')),Object(l.b)("p",null,"可以将属性值扩起来，表示 CSS 字符串，里面可以用单双引号和反斜杠转义。"),Object(l.b)("h3",{id:"伪类选择器"},"伪类选择器"),Object(l.b)("p",null,"伪类选择器分为普通型和函数型。"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"树结构关系伪类选择器")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":root"),": 表示文档树的根元素。对于 HTML 来说，:root 表示",Object(l.b)("inlineCode",{parentName:"li"},"<html>"),"元素，只是优先级比 html 选择器更高。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":empty"),": 表示没有子节点的元素，有空白文本节点的元素不算。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":nth-child()"),"和",Object(l.b)("inlineCode",{parentName:"li"},":nth-last-child()"),": 这两个是函数型伪类")),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-css"}),":nth-child(even){\n  /* 选中偶数节点 */\n}\n:nth-child(4n-1){\n  /* 选中 3 7 11... */\n}\n:nth-child(3n+1 of li.important){\n  /* 选中 1 4 7 个 li.important，这里只有 li.important 会被计数 */\n}\n")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":nth-last-child"),": 和",Object(l.b)("inlineCode",{parentName:"li"},":nth-child"),"一样，只是方向是从后往前数。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":first-child"),"、",Object(l.b)("inlineCode",{parentName:"li"},":last-child"),": 表示选中第一个和最后一个元素。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":only-child"),": 选中唯一一个子元素")),Object(l.b)("p",null,"of-type 系列，是一个变形的语法糖。",Object(l.b)("inlineCode",{parentName:"p"},"S:nth-of-type(An+B)"),"是",Object(l.b)("inlineCode",{parentName:"p"},":nth-child(An+B of S)"),"的另一种写法。还有："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":nth-last-of-type")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":first-of-type")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":last-of-type")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":only-of-type"))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"链接与行为伪类选择器")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":any-link"),": 表示任意的链接，包括 a、area 和 link 都能匹配到。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":link"),": 表示未访问过的链接。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":visited"),": 表示已访问过的链接。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":hover"),": 鼠标悬停时"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":active"),": 激活时，即鼠标按下未抬起"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":focus"),": 获取焦点时"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":target"),": 用于选中浏览器 URL 的 hash 部分所指示的元素。")),Object(l.b)("p",null,"在 Selector Level 4草案中，还新增了:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":target-within"),": target 的父容器"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":focus-within"),": focus 的父容器")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"逻辑伪类选择器")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},":not(:hover)"),": 3 级标准只能选中参数是简单选择器。")),Object(l.b)("p",null,"在 Selector Level 4草案中，还新增了:is、:where、:has，但是违背了选择器匹配 DOM 不回溯的原则，方案不知会不会通过。"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"其它伪类选择器()")),Object(l.b)("p",null,"还有一些伪类，在草案中或不常用，只需了解。"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"国际化",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"dir"),Object(l.b)("li",{parentName:"ul"},"lang"))),Object(l.b)("li",{parentName:"ul"},"音频/视频: 用于区分播放状态",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"play"),Object(l.b)("li",{parentName:"ul"},"pause"))),Object(l.b)("li",{parentName:"ul"},"时序：用于配合读屏软件",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"current"),Object(l.b)("li",{parentName:"ul"},"past"),Object(l.b)("li",{parentName:"ul"},"future"))),Object(l.b)("li",{parentName:"ul"},"表格：处理 table 列的伪类",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"nth-col")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"nth-last-col"))))),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{}),".box div : 后代选择器\n\n// 新增选择器\nfather > child： 子元素选择器\nsibling + sibling：相邻兄弟选择器\nsibling ~ sibling: 后面兄弟选择器\n,        : 群组选择器\n\n// 属性选择器\n\n// 伪类选择器，相当于是自身的属性\n// 动态伪类，用户交互时触发\n:link, :visited  锚点伪类,a自带的效果\n:hover, :active, :fouces 用户行为伪类\n\n// ui元素状态伪类\n:enabled, :disabled, :checked\n\ndiv:first-child 如果是父级的第一个子元素，且是div，则选中 \ndiv:last-child\n\ndiv:nth-child()  odd=2n+1,even=2n\ndiv:nth-last-child(n)  倒着数第n个，且是div\n\ndiv:nth-of-type(2)  父级的第二个 div 子元素\ndiv:nth-last-of-type(n)\n\ndiv:first-of-type\ndiv:last-of-type\ndiv:only-child  只有一个子元素，且是唯一的\ndiv:only-of-child  只有一个div子元素\n\n:empty  没有子元素(包括文本节点)\n\na:not(:last-of-type)\n\n")),Object(l.b)("h2",{id:"选择器的组合"},"选择器的组合"),Object(l.b)("p",null,"选择器列表是由逗号分隔的复杂选择器序列；复杂选择器是用空格、>、～等符号连接的复合选择器；复合选择器是连写的简单选择器组合。"),Object(l.b)("p",null,"选择器连接方式有优先级。"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"1级： 无符号连接"),Object(l.b)("li",{parentName:"ul"},"2级： ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"空格"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("blockquote",{parentName:"li"},Object(l.b)("p",{parentName:"blockquote"},"：子代"))),Object(l.b)("li",{parentName:"ul"},"～: 后继，选择后面满足条件的所有同级元素"),Object(l.b)("li",{parentName:"ul"},"+：直接后继"),Object(l.b)("li",{parentName:"ul"},"||：列选择器"))),Object(l.b)("li",{parentName:"ul"},"3级： , ")),Object(l.b)("p",null,"实践中，一般设置 class 来避免过于复杂的选择器结构。组件开发时，一般给外层容器加上独立的 class 避免冲突。"),Object(l.b)("h2",{id:"选择器的优先级"},"选择器的优先级"),Object(l.b)("p",null,"假设:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"id 数目为 a"),Object(l.b)("li",{parentName:"ul"},"伪类选择器和 class 数目为 b"),Object(l.b)("li",{parentName:"ul"},"伪元素选择器和标签选择器数目为 c"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"*")," 不影响优先级")),Object(l.b)("p",null,"选择器的优先级算法是："),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{}),"specificity = base * base * a + base * b + c\n")),Object(l.b)("p",null,"base 表示一个足够大的整数，IE6 之前采用 256 进制，于是 256 个 class 等于一个 id。之后扩大到 65536，才避免这个问题。现代浏览器采用更大的数量。"),Object(l.b)("p",null,"行内样式优先级高于 CSS 选择器。而",Object(l.b)("inlineCode",{parentName:"p"},"!import"),"优先级要高于行内样式。"),Object(l.b)("p",null,"重复 class 还有如下特点(下图)："),Object(l.b)("p",null,Object(l.b)("img",a({parentName:"p"},{src:"/img/css/selector/1.png",alt:null}))),Object(l.b)("h2",{id:"伪元素"},"伪元素"),Object(l.b)("p",null,"伪元素实际是一种机制，而不是元素，它是硬生的选出一个虚拟元素。"),Object(l.b)("p",null,"目前兼容性达到可用的伪元素有："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"::first-line")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"::first-letter")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"::before")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"::after"))),Object(l.b)("h3",{id:"first-line"},"::first-line"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"::first-line"),": 只对块级元素有效，作用是选择元素的第一行，这里的第一行是排版后显示的第一行，与 HTML 代码中的换行无关。注意它是包裹在元素之外，所以下面代码第一行是绿色的。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"<div>\n  <span id=a>First paragraph</span><br/>\n  <span>Second paragraph</span>\n</div>\n\ndiv>span#a {\n    color:green;\n}\n\ndiv::first-line { \n    color:blue; \n}\n")),Object(l.b)("h3",{id:"first-letter"},"::first-letter"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"::first-letter"),": 只对块级元素有效，作用是选择元素的第一个字母。常见英文效果，实现首字母变大且大写。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-css"}),"p::first-letter { \n    text-transform: uppercase;\n    font-size:2em;\n    float:left; \n}\n")),Object(l.b)("p",null,"注意它是包裹在元素内，所以下面代码首字母是绿色的。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-html"}),"<div>\n  <span id=a>First paragraph</span><br/>\n  <span>Second paragraph</span>\n</div>\n\ndiv>span#a {\n    color:green;\n}\n\ndiv::first-letter{ \n    color:blue; \n}\n")),Object(l.b)("p",null,"CSS 标准只要求",Object(l.b)("inlineCode",{parentName:"p"},"::first-letter"),"和",Object(l.b)("inlineCode",{parentName:"p"},"::first-line"),"实现如下属性："),Object(l.b)("p",null,Object(l.b)("img",a({parentName:"p"},{src:"/img/css/selector/2.png",alt:null}))),Object(l.b)("h3",{id:"before-和-after"},"before 和 after"),Object(l.b)("p",null,"这两个元素是在元素中新增一个虚拟元素。"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"::before"),": 相当于在元素内容开头插入一个虚拟元素。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"::after"),": 相当于在元素内容末尾插入一个虚拟元素。")),Object(l.b)("p",null,"它们都只有指定了 content 属性才有效。比如下面的计数器。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-html"}),'<p class="special">I\'m real element</p>\np.special::before {\n    display: block;\n    content: counter(chapno, upper-roman) ". ";\n}\n')),Object(l.b)("h3",{id:"before-和-before-的区别"},":before 和 ::before 的区别"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},":before"),"和",Object(l.b)("inlineCode",{parentName:"p"},"::before"),"效果是一样的，",Object(l.b)("inlineCode",{parentName:"p"},":before"),"是 CSS2 提出的，兼容 IE8，",Object(l.b)("inlineCode",{parentName:"p"},"::before"),"是 CSS3 提出的，目的是为了区分伪元素和伪类。"),Object(l.b)("p",null,"H5 开发时如果不考虑兼容性，建议使用",Object(l.b)("inlineCode",{parentName:"p"},"::before"),"。"),Object(l.b)("h2",{id:"实践规则"},"实践规则"),Object(l.b)("p",null,"实践中，不要使用太复杂的选择器。应该遵循规则如下："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"id 选择单个元素。"),Object(l.b)("li",{parentName:"ol"},"class 和 class 组合选择组元素。"),Object(l.b)("li",{parentName:"ol"},"tag 确定页面布局。"),Object(l.b)("li",{parentName:"ol"},"尽量不要使用伪类选择器。")),Object(l.b)("p",null,"练习题："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"用 JavaScript 实现一个能够处理所有简单选择器的querySelector（行为伪类除外)"),Object(l.b)("li",{parentName:"ul"},"你所在的团队，如何规定 CSS 选择器的编写规范？"),Object(l.b)("li",{parentName:"ul"},"用 JavaScript 写一个仅包含 inline-block 的正常流布局算法。"),Object(l.b)("li",{parentName:"ul"},"src 属性支持哪些协议的 uri   ",Object(l.b)("a",a({parentName:"li"},{href:"http://,https://,file://,data.."}),"http://,https://,file://,data.."),". blob")))}o.isMDXComponent=!0},301:function(e,t,n){"use strict";n.d(t,"a",function(){return r}),n.d(t,"b",function(){return u});var l=n(0),a=n.n(l),b=a.a.createContext({}),i=function(e){var t=a.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},r=function(e){var t=i(e.components);return a.a.createElement(b.Provider,{value:t},e.children)};var c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},o=function(e){var t=e.components,n=e.mdxType,l=e.originalType,b=e.parentName,r=function(e,t){var n={};for(var l in e)Object.prototype.hasOwnProperty.call(e,l)&&-1===t.indexOf(l)&&(n[l]=e[l]);return n}(e,["components","mdxType","originalType","parentName"]),c=i(t),o=n,u=c[b+"."+o]||c[o]||p[o]||l;return t?a.a.createElement(u,Object.assign({},r,{components:t})):a.a.createElement(u,r)};function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var b=n.length,i=new Array(b);i[0]=o;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r[c]="string"==typeof e?e:l,i[1]=r;for(var u=2;u<b;u++)i[u]=n[u];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}o.displayName="MDXCreateElement"}}]);