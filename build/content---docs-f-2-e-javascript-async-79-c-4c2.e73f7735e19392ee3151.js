(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{143:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return i}),a.d(n,"rightToc",function(){return c}),a.d(n,"default",function(){return b});a(0);var t=a(217);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i={title:"javascript 异步编程",sidebar_label:"异步编程"},c=[{value:"概念",id:"概念",children:[{value:"并发和并行",id:"并发和并行",children:[]}]},{value:"异步发展",id:"异步发展",children:[]},{value:"回调函数",id:"回调函数",children:[]},{value:"生成器 Generator",id:"生成器-generator",children:[{value:"简介",id:"简介",children:[]},{value:"co库原理",id:"co库原理",children:[]}]},{value:"Promise",id:"promise",children:[{value:"简介",id:"简介-1",children:[]},{value:"Promise.prototype.then()",id:"promiseprototypethen",children:[]},{value:"Promise.prototype.catch()",id:"promiseprototypecatch",children:[]},{value:"Promise.prototype.finally()",id:"promiseprototypefinally",children:[]},{value:"Promise.all()",id:"promiseall",children:[]},{value:"Promise.race()",id:"promiserace",children:[]},{value:"Promise.resolve()",id:"promiseresolve",children:[]},{value:"Promise.reject()",id:"promisereject",children:[]},{value:"实现符合PromiseA+规范的Promise",id:"实现符合promisea规范的promise",children:[]}]},{value:"async + await",id:"async--await",children:[]},{value:"定时器",id:"定时器",children:[{value:"setTimeout",id:"settimeout",children:[]},{value:"setInterval",id:"setinterval",children:[]},{value:"循环间隔 60Hz",id:"循环间隔-60hz",children:[]},{value:"requestAnimationFrame",id:"requestanimationframe",children:[]},{value:"使用 requestAnimatinFrame 实现动画",id:"使用-requestanimatinframe-实现动画",children:[]}]}],o={rightToc:c},s="wrapper";function b(e){var n=e.components,a=l(e,["components"]);return Object(t.b)(s,r({},o,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"概念"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#概念"}),"#"),"概念"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"并发和并行"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#并发和并行"}),"#"),"并发和并行"),Object(t.b)("p",null,Object(t.b)("img",r({parentName:"p"},{src:"/static/img/js/async-1.jpg",alt:"Erlang 之父 Joe Armstrong画的并发和并行图片"}))),Object(t.b)("p",null,"上图可以看到，并发(concurrency)同时来了多个任务；并行(parallelism)是多个任务同时在处理。"),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"异步发展"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#异步发展"}),"#"),"异步发展"),Object(t.b)("p",null,"javascript 异步的发展大致经历了下面几个过程："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"回调函数"),Object(t.b)("li",{parentName:"ol"},"Generator"),Object(t.b)("li",{parentName:"ol"},"Promise"),Object(t.b)("li",{parentName:"ol"},"async + await ")),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"回调函数"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#回调函数"}),"#"),"回调函数"),Object(t.b)("p",null,"回调函数就是一个通过函数指针调用的函数。回调函数有个缺点，就是很容易多层嵌套，也叫做回调地狱。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"fn0(0, function(){\n    fn1(1, function(){\n        fn2(2, function(){\n        })\n    })\n})\n")),Object(t.b)("p",null,"上面这样的代码很不容易阅读和维护。它的主要问题是："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"嵌套函数存在耦合性，修改会影响其它的。"),Object(t.b)("li",{parentName:"ol"},"错误不好处理。")),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"生成器-generator"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#生成器-generator"}),"#"),"生成器 Generator"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"简介"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#简介"}),"#"),"简介"),Object(t.b)("p",null,"Generator 是 ES6 的概念，叫做生成器，它会生成一个迭代器。迭代器有一个",Object(t.b)("inlineCode",{parentName:"p"},"next()"),"方法，每次调用会返回",Object(t.b)("inlineCode",{parentName:"p"},"value"),"和",Object(t.b)("inlineCode",{parentName:"p"},"done"),"，分别是迭代的值和迭代是否完成。"),Object(t.b)("p",null,"生成器的用法如下："),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"function* g(){ \n    let a = yield 1\n    console.log(a)\n    let b = yield 2\n    console.log(b)\n    return 3\n}\nlet it = g()\nit.next('x')\n// { value: 1, done: false }\nit.next('y') \n// y\n// { value: 2, done: false }\nit.next('z') \n// z\n// { value: 3, done: true }\n")),Object(t.b)("p",null,"生成器其实就是一个特殊的函数，使用语法",Object(t.b)("inlineCode",{parentName:"p"},"function*"),"定义。它的内部可以使用",Object(t.b)("inlineCode",{parentName:"p"},"yield"),"关键字来暂停执行。generator 的执行是蛇形执行。执行过程如下："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"执行",Object(t.b)("inlineCode",{parentName:"li"},"it.next('h')"),"，函数会执行到",Object(t.b)("inlineCode",{parentName:"li"},"yield 1"),"后暂停。"),Object(t.b)("li",{parentName:"ol"},"执行",Object(t.b)("inlineCode",{parentName:"li"},"it.next('i')"),"，函数会给 a 赋值，并执行到",Object(t.b)("inlineCode",{parentName:"li"},"yield 2"),"后暂停。"),Object(t.b)("li",{parentName:"ol"},"执行",Object(t.b)("inlineCode",{parentName:"li"},"it.next('!')"),"，函数会给 b 赋值，并执行到最后。")),Object(t.b)("p",null,"关于返回值，需要注意："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"next()"),"传递的参数是 yeild 语句的返回值，所以第一次调用next传递参数没有意义，因为没有变量接收。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"next()"),"执行时返回的 value 值，是 yield 语句或 return 产出的值。")),Object(t.b)("p",null,"再来看看下面这个例子。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"function *foo(x) {\n  let y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\nlet it = foo(5)\nconsole.log(it.next())   // => {value: 6, done: false}\nconsole.log(it.next(12)) // => {value: 8, done: false}\nconsole.log(it.next(13)) // => {value: 42, done: true}\n")),Object(t.b)("p",null,"上面代码执行步骤如下："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"it.next()"),"执行到",Object(t.b)("inlineCode",{parentName:"li"},"yield (5 + 1)"),"，相当于",Object(t.b)("inlineCode",{parentName:"li"},"yield 6"),"，所以输出",Object(t.b)("inlineCode",{parentName:"li"},"{value: 6}"),"。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"it.next(12)"),"，传入的参数 12 会作为第一个 yeild 的返回值，所以 y = 2 * 12 ，即 24。",Object(t.b)("inlineCode",{parentName:"li"},"yield y/3"),"就是",Object(t.b)("inlineCode",{parentName:"li"},"yield 8"),"。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"it.next(13)"),"，13 会传给 z，所以最后结果为 5 + 24 + 13 = 42。 ")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"为什么",Object(t.b)("inlineCode",{parentName:"p"},"[...{name:'zs', age: 12}]"),"会报错？")),Object(t.b)("p",null,"因为解构或 for...of 会执行对象的",Object(t.b)("inlineCode",{parentName:"p"},"[Symbol.interator]"),"方法。普通对象 Object 不支持",Object(t.b)("inlineCode",{parentName:"p"},"for...of"),"，我们可以新增这个方法实现迭代。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"let o = {\n    name: 'zs',\n    age: 12,\n    [Symbol.iterator]: function () {\n        let index = 0, \n            keys = Object.keys(this);\n        return {\n            next: function () {\n                return {\n                    done: keys.length == index,\n                    value: this[keys[index++]]\n                }\n            }\n        }\n    },\n    // 使用 generator\n    // [Symbol.iterator]: function* () {\n    //     let index = 0, \n    //     keys = Object.keys(this);\n    //     while(index !== keys.length){\n    //         yield this[keys[index++]]\n    //     }\n    // }\n}\n\nfor (let i of o) {\n    console.log(i)  // 'zs', 12\n}\n\n[...o]  // ['zs', 12]\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"co库原理"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#co库原理"}),"#"),"co库原理"),Object(t.b)("p",null,"Generator 一般会配合 ",Object(t.b)("a",r({parentName:"p"},{href:"https://github.com/tj/co"}),"co库")," 使用。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// co 返回一个promise，并且会将迭代器的最终执行结果传递\nlet fs = require('fs')\nlet path = require('path')\nlet co = require('co')\n\nfunction readFile(filepath) {\n    return new Promise(function (resolve, reject) {\n        fs.readFile(path.join(__dirname, filepath), 'utf8', function (err, data) {\n            if (err) reject(err)\n            resolve(data)\n        })\n    })\n}\n\nfunction* read() {\n    let a = yield readFile('name.txt', 'utf8')\n    let b = yield readFile(a, 'utf8')\n    return b\n}\n\n// 使用co库\nco(read).then(function (data) {\n    console.log(data)\n})\n\n// 相当于是\nlet it = read()\nlet { value } = it.next()\nvalue.then(function (data) {\n    let { value } = it.next(data)\n    value.then(function (data) {\n        let { value } = it.next(data)\n        console.log(value)\n    })\n})\n")),Object(t.b)("p",null,"可以看到 co 库会不断的解析",Object(t.b)("inlineCode",{parentName:"p"},"read()"),"，获得最终的返回值。"),Object(t.b)("p",null,"co的实现原理:"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"function* read() {\n    let a = yield readFile('name.txt', 'utf8')\n    let b = yield readFile(a, 'utf8')\n    return b\n}\n\n// co返回一个promise\nfunction co(param) {\n    return new Promise(function (resolve, reject) {\n        let it = typeof param === 'function' ? param() : param\n        function step(data) {\n            try {\n                let { value, done } = it.next(data)\n            } catch (e) {\n                return reject(e)\n            }\n            if (done) {\n                resolve(value)\n            } else {\n                // value可能不是promise\n                Promise.resolve(value).then(function (data) {\n                    step(data)\n                }, reject)\n            }\n        }\n        step(param)\n    })\n}\n")),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"promise"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#promise"}),"#"),"Promise"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"简介-1"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#简介-1"}),"#"),"简介"),Object(t.b)("p",null,"Promise 是一个类，它的特点如下："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"Promise 初始状态是",Object(t.b)("inlineCode",{parentName:"li"},"pending"),"，通过 resolve() 或 reject() 可以将状态修改为",Object(t.b)("inlineCode",{parentName:"li"},"fulfilled(成功)"),"或",Object(t.b)("inlineCode",{parentName:"li"},"rejected(失败)"),"。如果状态是",Object(t.b)("inlineCode",{parentName:"li"},"pending"),"，回调函数永远不会被调用。而且状态一旦改变，就不能再改变。"),Object(t.b)("li",{parentName:"ol"},"Promise 无法中途取消，一旦新建它将立即执行。"),Object(t.b)("li",{parentName:"ol"},"Promise 状态是保存的，可以后续再添加回调函数。事件是错过后再监听，是监听不到的。")),Object(t.b)("p",null,"下面几个方法是非常常用的。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Promise.all()"),Object(t.b)("li",{parentName:"ul"},"Promise.resolve()"),Object(t.b)("li",{parentName:"ul"},"Promise.reject()"),Object(t.b)("li",{parentName:"ul"},"Promise.race()"),Object(t.b)("li",{parentName:"ul"},"Promise.prototype.then()"),Object(t.b)("li",{parentName:"ul"},"Promise.prototype.finally()"),Object(t.b)("li",{parentName:"ul"},"Promise.prototype.catch()")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"Promise和事件")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Promise 只关心对结果做出反应，不关心过程。"),Object(t.b)("li",{parentName:"ul"},"事件有可能之前发生了，然后没有捕获到，比如图片加载时添加",Object(t.b)("inlineCode",{parentName:"li"},"img.onload"),"。"),Object(t.b)("li",{parentName:"ul"},"多个异步事件的处理，事件会很复杂。")),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{}),"<img src='1.png' />\n\n<script src='big.js'>\n<script>\nimg.onload = () => {}  // 这里可能不会执行 onload 事件\n<\/script>\n")),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"new Promise((resolve, reject)=>{\n    if(ok){\n        resolve('ok')\n    }else{\n        reject('error')\n    }\n}).then(resolveCallback, rejectCallback)\n\nfunction resolveCallback(data){\n    // 这里调用的时候data就是ok\n}\n\nfunction rejectCallback(data){\n    // 这里调用的时候data就是error\n}\n")),Object(t.b)("p",null,"Promise 新建时就立即执行，就像执行一个函数一样，是同步的。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"new Promise((resolve, reject)=>{\n    resolve('ok')\n    console.log('promise')\n})\nconsole.log('hello')\n\n// 结果 promise -> hello\n")),Object(t.b)("p",null,"上面代码也显示出，resolve() 和 reject() 不会阻止函数后续代码的执行。"),Object(t.b)("p",null,"Promise 的 then 方法，属于 micro-task 类型的异步任务。会在同步任务执行完成后，再执行。"),Object(t.b)("p",null,"下面是一个用 Promise 实现的图片下载的例子。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"var img = new Image()\nimg.src = 'http://xx.com/1.png'\nimg.onload = ()=>{\n    resolve(img)\n}\nimg.onerror = ()=>{\n    reject('img download error')\n}\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promiseprototypethen"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promiseprototypethen"}),"#"),"Promise.prototype.then()"),Object(t.b)("p",null,"then 方法返回的是一个新的 Promise 对象，不是之前那个 Promise 对象。"),Object(t.b)("p",null,"如果前一个 then 方法返回 Promise，则后面的 then 方法会等待 Promise 状态变化后调用。如果返回的是值，则后面的 then 方法的参数就是这个返回值。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"// then返回值\nnew Promise((resolve, reject) => {\n    resolve('hello')\n}).then((res) => {\n    console.log(res)  // 'hello'\n    return 'res'\n}).then((res1) => {\n    console.log(res1)  // res\n})\n\n// then返回Promise\nnew Promise((resolve, reject) => {\n    resolve('hello')\n}).then((res) => {\n    console.log(res)  // 'hello'\n    return new Promise((resolve,reject)=>{\n        resolve('xx')\n    }) \n}).then((res1) => {\n    console.log(res1)  // xx\n})\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promiseprototypecatch"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promiseprototypecatch"}),"#"),"Promise.prototype.catch()"),Object(t.b)("p",null,"catch 方法是",Object(t.b)("inlineCode",{parentName:"p"},".then(null, rejection)"),"的别名，用于捕获 Promise 内部的错误。"),Object(t.b)("p",null,"如果 Promise 里有错误或reject()，并且没有使用 then() 的 reject 回调方法，catch则会执行。如果 then 有 reject 回调则会拦截到异常，catch 将不会执行。(错误实际会使状态变为 rejected)"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"Promise((resolve,reject)=>{\n    reject('error')\n}).then(()=>{}, ()=>{\n    console.log('reject error')  // 会执行\n}).catch(()=>{\n    console.log('catch')         // 不执行\n})\n")),Object(t.b)("p",null,"建议用 catch 来捕获异常，不要使用 then() 的 rejection。"),Object(t.b)("p",null,"在 resolve() 后抛出的异常不会被捕获。因为 Promise 状态已经改变，不会再发生变化了。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"new Promise((resolve, reject)=>{\n    resolve()\n    throw new Error('test')\n}).catch(()=>{\n    // 不会执行\n})\n")),Object(t.b)("p",null,"下面三段代码是等效的。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const promise = new Promise(function(resolve, reject) {\n  throw new Error('test');\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n// Error: test\n\n// 写法一\nconst promise = new Promise(function(resolve, reject) {\n  try {\n    throw new Error('test');\n  } catch(e) {\n    reject(e);\n  }\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n// 写法二\nconst promise = new Promise(function(resolve, reject) {\n  reject(new Error('test'));\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n")),Object(t.b)("p",null,"Node 里的 unhandledRejection 事件，用于捕获没有捕获的 reject 错误。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"process.on('unhandledRejection', (err, p)=>{})\n")),Object(t.b)("p",null,"下面这个例子。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const promise = new Promise(function (resolve, reject) {\n  resolve('ok');\n  setTimeout(function () { throw new Error('test') }, 0)\n});\npromise.then(function (value) { console.log(value) });\n// ok\n// Uncaught Error: test\n")),Object(t.b)("p",null,"setTimeout 时，Promise 已经执行完成了。所以错误会抛出到外层，成为未捕获的错误。"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promiseprototypefinally"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promiseprototypefinally"}),"#"),"Promise.prototype.finally()"),Object(t.b)("p",null,"finally 方法指定 Promise 对象最后的执行操作。不管状态是 fulfilled 还是 rejected。它不接受参数。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"promise.finally(()=>{})\n\n// 等同于\npromise.then(()=>{},()=>{})\n")),Object(t.b)("p",null,"finally 的实现是："),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"Promise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promiseall"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promiseall"}),"#"),"Promise.all()"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const p = Promise.all([task1, task2, task3])\n")),Object(t.b)("p",null,"task1, task2, task3 都是 Promise 对象。"),Object(t.b)("p",null,"当所有的 Promise 对象都是 fulfilled 时，p 才是 fulfilled。否则就是 rejected。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));  // 不会执行\n// [\"hello\", Error: 报错了]\n")),Object(t.b)("p",null,"上面的代码，p1 和 p2 都是 resolved (p2 在执行完 catch 后)。如果 p2 没有 catch，则 all 里面的 catch 会执行。"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promiserace"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promiserace"}),"#"),"Promise.race()"),Object(t.b)("p",null,"根据最快的一个决定状态。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"const p = Promise.race([task1, task2, task2])\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promiseresolve"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promiseresolve"}),"#"),"Promise.resolve()"),Object(t.b)("p",null,"Promise.resolve() 可以将一个对象转成 Promise 对象。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"Promise.resolve('foo')\n\n// 等价于\nnew Promise(resolve => resolve('foo'))\n")),Object(t.b)("p",null,"Promise.resolve() 的参数分为3种情况。"),Object(t.b)("p",null,"1、参数是 Promise 实例。会原封不动返回。\n2、 thenable 对象，也就是具有 then 方法的对象。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"let thenable = {\n    then(resolve, reject){\n        resolve(1)\n    }\n}\n\nlet p1 = Promise.resolve(thenable)\np1.then((val)=>{\n    console.log(val)  // 1\n})\n")),Object(t.b)("p",null,"Promise.resolve() 会将它转成 Promise 对象，并立即执行 then 方法。"),Object(t.b)("p",null,"3、一般参数或不带参数"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const p = Promise.resolve('hello')\np.then((res)=>{\n    console.log(res) // 'hello'\n})\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"promisereject"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#promisereject"}),"#"),"Promise.reject()"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"Promise.reject()  // 报错了\n")),Object(t.b)("p",null,"所以需要 catch 捕获。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"var p = Promise.reject()\np.catch(e=>{})\n")),Object(t.b)("p",null,"如果传入一个 thenable，后续 then 方法的参数是这个 thenable 对象。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"const thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"实现符合promisea规范的promise"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#实现符合promisea规范的promise"}),"#"),"实现符合PromiseA+规范的Promise"),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"async--await"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#async--await"}),"#"),"async + await"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"async"),"函数会返回一个",Object(t.b)("inlineCode",{parentName:"p"},"Promise"),"。如果返回值不是Promise，就使用",Object(t.b)("inlineCode",{parentName:"p"},"Promise.resolve()"),"包裹了一下。如果是Promise，就执行。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function a(){\n    return 1\n}\na()  // Promise {<resolved>: 1}\n")),Object(t.b)("p",null,"async 和 await 可以说是异步终极解决方案，它相当于将代码改造成了同步代码。可以使用",Object(t.b)("inlineCode",{parentName:"p"},"try...catch"),"捕获异常。"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"let a = 0\nlet b = async () => {\n    console.log(0)\n    a = a + await 10\n    console.log(2, a) \n}\nb()\na++\nconsole.log(1, a) \n// 结果\n// 0\n// 1 1\n// 2 10\n")),Object(t.b)("p",null,"上面代码可以看出，async 函数是同步执行的，但是 await 是异步的。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"首先执行",Object(t.b)("inlineCode",{parentName:"li"},"b()"),"，输出",Object(t.b)("inlineCode",{parentName:"li"},"0"),"。"),Object(t.b)("li",{parentName:"ul"},"然后 b 函数保存了",Object(t.b)("inlineCode",{parentName:"li"},"a = 0"),"（await 内部通过 generator 实现，generator 会保留堆栈中的内容），遇到异步的",Object(t.b)("inlineCode",{parentName:"li"},"await 10"),"时，会先去执行后面的同步代码",Object(t.b)("inlineCode",{parentName:"li"},"a++"),"，输出",Object(t.b)("inlineCode",{parentName:"li"},"1 1"),"。"),Object(t.b)("li",{parentName:"ul"},"最后再执行",Object(t.b)("inlineCode",{parentName:"li"},"await"),"，输出",Object(t.b)("inlineCode",{parentName:"li"},"2, 10"),"。")),Object(t.b)("p",null,"await 内部实现了 generator，它是 generator 和 Promise 的语法糖，内部会自动执行 generator。"),Object(t.b)("h2",null,Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"定时器"})),Object(t.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#定时器"}),"#"),"定时器"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"settimeout"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#settimeout"}),"#"),"setTimeout"),Object(t.b)("p",null,"setTimeout 要注意的几点："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"因为 javascript 是单线程的，所以 setTimeout 的时间并不准确，具体可以看浏览器事件环。"),Object(t.b)("li",{parentName:"ol"},Object(t.b)("inlineCode",{parentName:"li"},"setTimeout()"),"的返回值表示定时器的编号，可以传递给",Object(t.b)("inlineCode",{parentName:"li"},"clearTimeout()"),"取消定时器，浏览器中返回一个数字，NodeJs 中返回一个 Timeout 对象。",Object(t.b)("inlineCode",{parentName:"li"},"setTimeout()"),"和",Object(t.b)("inlineCode",{parentName:"li"},"setInterval()"),"公用一个编号池。")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"setinterval"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#setinterval"}),"#"),"setInterval"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"let intervalID = window.setInterval(func, delay[, param1, param2, ...]);\n")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"循环间隔-60hz"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#循环间隔-60hz"}),"#"),"循环间隔 60Hz"),Object(t.b)("p",null,"动画循环的关键是循环间隔的时常。循环间隔要足够长，以保证浏览器有能力渲染产生的变化。另外循环间隔要足够短，以保证动画的流畅性。显示器刷新频率为 60Hz，即相当于每秒屏幕会重绘 60 次，即循环间隔最好是 16.7ms(1000ms/60)。"),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"requestanimationframe"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#requestanimationframe"}),"#"),"requestAnimationFrame"),Object(t.b)("p",null,"requestAnimationFrame 是专门为实现高性能的帧动画而设计的一个 API。requestAnimationFrame 跟屏幕刷新频率同步(大多数是 60Hz)。这里的关键区别在于可以让浏览器在下一个可用时机去绘制动画，而不是以预定间隔绘制动画。"),Object(t.b)("p",null,"可以使用",Object(t.b)("inlineCode",{parentName:"p"},"cancelAnimationFrame(timer)"),"取消任务。"),Object(t.b)("p",null,"为了保证兼容，可以使用下面的代码："),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"// 判断是否有 requestAnimationFrame 方法，如果有则模拟实现\nwindow.requestAnimFrame =\nwindow.requestAnimationFrame ||\nwindow.webkitRequestAnimationFrame ||\nwindow.mozRequestAnimationFrame ||\nwindow.oRequestAnimationFrame ||\nwindow.msRequestAnimationFrame ||\nfunction(callback) {\n    window.setTimeout(callback, 1000 / 30);\n};\n")),Object(t.b)("p",null,"上面的代码，如果不兼容，则使用 setTimeout 模拟。"),Object(t.b)("p",null,"它的优点是："),Object(t.b)("ol",null,Object(t.b)("li",{parentName:"ol"},"浏览器可以对其进行优化，所以动画更流畅 "),Object(t.b)("li",{parentName:"ol"},"非活动选项卡中的动画会停止"),Object(t.b)("li",{parentName:"ol"},"更省电")),Object(t.b)("h3",null,Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"使用-requestanimatinframe-实现动画"})),Object(t.b)("a",r({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#使用-requestanimatinframe-实现动画"}),"#"),"使用 requestAnimatinFrame 实现动画"),Object(t.b)("pre",null,Object(t.b)("code",r({parentName:"pre"},{className:"language-js"}),"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>认识Canvas</title>\n</head>\n<body>\n    <canvas id=\"canvas\" width=\"500\" height=\"500\" style=\"border: 1px solid #333\"></canvas>\n    <script>\n        var canvas = document.getElementById('canvas');\n        var context = canvas.getContext('2d');\n        // 兼容定义 requestAnimFrame\n        window.requestAnimFrame =\n        window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.oRequestAnimationFrame ||\n        window.msRequestAnimationFrame ||\n        function(callback) {\n            window.setTimeout(callback, 1000 / 30);\n        };\n\n        // 绘制的圆的对象\n        var circle = {\n            x: 250,\n            y: 250,\n            radius: 50,\n            direction: 'right',\n            // 移动圆形\n            move: function() {\n                if (this.direction === 'right') {\n                    if (this.x <= 430) {\n                         this.x += 5;\n                    } else {\n                        this.direction = 'left';\n                    }\n                } else {\n                    if (this.x >= 60) {\n                         this.x -= 5;\n                    } else {\n                        this.direction = 'right';\n                    }\n                }\n            },\n            draw: function() {\n                // 绘制圆形\n                context.beginPath();\n                // 设置开始角度为0，结束角度为 2π 弧度\n                context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\n                context.fillStyle = '#00c09b';\n                context.fill();\n            }\n        }\n        // 动画执行函数\n        function animate() {\n            // 随机更新圆形位置\n            circle.move();\n            // 清除画布\n            context.clearRect(0, 0, canvas.width, canvas.height);\n            // 绘画圆\n            circle.draw();\n            // 使用requestAnimationFrame实现动画循环\n            requestAnimationFrame(animate);\n        }\n\n        // 先画第一帧的圆，即初始化的圆\n        circle.draw();\n        // 执行animate\n        animate();        \n    <\/script>\n</body>\n</html>\n")))}b.isMDXComponent=!0},217:function(e,n,a){"use strict";a.d(n,"a",function(){return c}),a.d(n,"b",function(){return m});var t=a(0),r=a.n(t),l=r.a.createContext({}),i=function(e){var n=r.a.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},c=function(e){var n=i(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},o="mdxType",s={inlineCode:"code",wrapper:function(e){return r.a.createElement(r.a.Fragment,{},e.children)}},b=function(e){var n=e.components,a=e.mdxType,t=e.originalType,l=e.parentName,c=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),o=i(n);return r.a.createElement(o[l+"."+a]||o[a]||s[a]||t,n?Object.assign({},c,{components:n}):c)};function m(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var l=a.length,i=new Array(l);i[0]=b;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[o]="string"==typeof e?e:t,i[1]=c;for(var m=2;m<l;m++)i[m]=a[m];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);