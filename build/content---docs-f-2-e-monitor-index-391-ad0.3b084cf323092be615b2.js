(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{209:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return c}),t.d(n,"rightToc",function(){return b}),t.d(n,"default",function(){return p});t(0);var a=t(283);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c={title:"前端监控",sidebar_label:"前端监控"},b=[{value:"domReady",id:"domready",children:[]},{value:"简介",id:"简介",children:[]},{value:"监控哪些数据",id:"监控哪些数据",children:[]},{value:"用户和行为监控",id:"用户和行为监控",children:[{value:"用户行为路径",id:"用户行为路径",children:[]},{value:"打点监控",id:"打点监控",children:[]},{value:"大量log上报策略",id:"大量log上报策略",children:[]},{value:"时效策略",id:"时效策略",children:[]}]},{value:"性能监控",id:"性能监控",children:[]},{value:"错误监控",id:"错误监控",children:[{value:"try...catch",id:"trycatch",children:[]},{value:"window.onerror",id:"windowonerror",children:[]},{value:"source map",id:"source-map",children:[]},{value:"Promise 错误",id:"promise-错误",children:[]},{value:"网络加载错误",id:"网络加载错误",children:[]},{value:"页面崩溃错误",id:"页面崩溃错误",children:[]},{value:"框架的错误处理",id:"框架的错误处理",children:[]},{value:"Ajax 错误",id:"ajax-错误",children:[]}]},{value:"上报",id:"上报",children:[{value:"使用独立域名",id:"使用独立域名",children:[]},{value:"Image src",id:"image-src",children:[]},{value:"上报时机",id:"上报时机",children:[]},{value:"单页应用上报",id:"单页应用上报",children:[]}]},{value:"监控系统设计",id:"监控系统设计",children:[]},{value:"参考资料",id:"参考资料",children:[]}],o={rightToc:b},i="wrapper";function p(e){var n=e.components,t=l(e,["components"]);return Object(a.b)(i,r({},o,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"前端监控主要是监控："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"用户行为"),Object(a.b)("li",{parentName:"ul"},"性能监控"),Object(a.b)("li",{parentName:"ul"},"错误收集"),Object(a.b)("li",{parentName:"ul"},"上报")),Object(a.b)("h2",{id:"domready"},"domReady"),Object(a.b)("p",null,"domReady 实际是 DOM 加载完成，图片等链接资源正在加载中。onload 表示资源都已经加载完毕，如果有资源错误，则会阻塞延迟 onload 的执行。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"如何判断domReady")),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"document.readyState 有三个状态：",Object(a.b)("inlineCode",{parentName:"li"},"loading/正在加载"),"、",Object(a.b)("inlineCode",{parentName:"li"},"interactive/可交互,图片、框架资源正在加载"),"、",Object(a.b)("inlineCode",{parentName:"li"},"complete/完成"),"。当这个属性值变化时，会触发",Object(a.b)("inlineCode",{parentName:"li"},"readystatechange"),"事件。"),Object(a.b)("li",{parentName:"ol"},"document 的 DOMContentLoaded 事件")),Object(a.b)("h2",{id:"简介"},"简介"),Object(a.b)("p",null,"前端监控，可以让我们及时发现线上出现的问题，根据出现问题时的场景，更快的解决它。还可以搜集用户行为，从而为用户提供更好的体验。总的来说，有了线上的监控数据统计，我们才能在问题和需求上制定更好的方案。"),Object(a.b)("h2",{id:"监控哪些数据"},"监控哪些数据"),Object(a.b)("p",null,"监控数据主要是围绕着用户、性能和错误来展开。需要监控的数据有："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"用户和用户行为",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"流量来源 url(百度、google、广告等)、去向 url"),Object(a.b)("li",{parentName:"ul"},"客户端信息(操作系统、浏览器、分辨率、ip、地域、网络类型等)"),Object(a.b)("li",{parentName:"ul"},"pv/uv、访问深度、访问路径、时间"),Object(a.b)("li",{parentName:"ul"},"点击量（总的、人均）、点击热力图、点击时间"))),Object(a.b)("li",{parentName:"ul"},"性能",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"白屏时间"),Object(a.b)("li",{parentName:"ul"},"首屏时间"),Object(a.b)("li",{parentName:"ul"},"用户可操作时间"),Object(a.b)("li",{parentName:"ul"},"页面总下载时间"),Object(a.b)("li",{parentName:"ul"},"自定义的时间(开发者关注的)"))),Object(a.b)("li",{parentName:"ul"},"错误",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"错误的堆栈信息"),Object(a.b)("li",{parentName:"ul"},"发生错误时的环境(浏览器信息、网络等)"))),Object(a.b)("li",{parentName:"ul"},"其它自定义",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"对特殊功能的支持程度(canvas)"),Object(a.b)("li",{parentName:"ul"},"轮播图的翻页次数")))),Object(a.b)("h2",{id:"用户和行为监控"},"用户和行为监控"),Object(a.b)("h3",{id:"用户行为路径"},"用户行为路径"),Object(a.b)("h3",{id:"打点监控"},"打点监控"),Object(a.b)("p",null,"一般监控 pv/uv 停留时长  流量来源 用户交互"),Object(a.b)("p",null,"监控访问的思路是："),Object(a.b)("p",null,"手写埋点: 手动插入代码，灵活，但是工作量大。\n无埋点：统计所有事件，定时上报，简单，但是后期需要过滤所需的数据。"),Object(a.b)("h3",{id:"大量log上报策略"},"大量log上报策略"),Object(a.b)("p",null,"有2个策略:\n1. 前端根据配置文件，根据 random 抽取百分比上传\n2. 全部上传给后端，后端忽略掉一些"),Object(a.b)("h3",{id:"时效策略"},"时效策略"),Object(a.b)("h2",{id:"性能监控"},"性能监控"),Object(a.b)("p",null,"性能优化是建立在性能监控前提之上的，只有统计了数据，才能对比优化前后是否达到了预期。具体查看另外一篇文章 ",Object(a.b)("a",r({parentName:"p"},{href:"/docs/f2e/performance/index"}),"性能体系的建立"),"。"),Object(a.b)("h2",{id:"错误监控"},"错误监控"),Object(a.b)("p",null,"错误监控首先需要收集错误，然后对错误再进行上报，下面来看看常见的错误有哪些:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"脚本错误，分为语法错误和运行时错误。"),Object(a.b)("li",{parentName:"ol"},"网络加载错误"),Object(a.b)("li",{parentName:"ol"},"页面崩溃"),Object(a.b)("li",{parentName:"ol"},"框架错误")),Object(a.b)("p",null,"常见的处理方案是："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"try...catch"),Object(a.b)("li",{parentName:"ul"},"window onerror事件")),Object(a.b)("p",null,"下面来详细看一下。"),Object(a.b)("h3",{id:"trycatch"},"try...catch"),Object(a.b)("p",null,"我们写代码，如果不保证代码正确的情况下，通常会用 try...catch 包裹起来。但是说实话，并不能保证没有包裹的代码一定是正确的。所以一般可以使用全局 try...catch 包裹来处理。现在的项目进行手动包裹不太现实，可以使用 UglifyJS 自动化处理。"),Object(a.b)("p",null,"try...catch 可以保证代码出错时，页面不崩溃。但是它有些问题："),Object(a.b)("p",null,"1、不能处理语法错误。语法错误后，当前代码段后面的代码就停止执行了。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"try{\n    var a =\\ 'a' \n}catch(e){\n    // 无法捕获\n}\n")),Object(a.b)("p",null,"2、不能处理异步错误。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"try{\n    setTimeout(()=>{\n        throw new Error()\n    },1000)\n}catch(e){\n    // 无法捕获\n}\n")),Object(a.b)("p",null,"上面代码无法捕获错误。除非在 setTimeout 函数里 try...catch 才行。"),Object(a.b)("p",null,"3、代码侵入。"),Object(a.b)("h3",{id:"windowonerror"},"window.onerror"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"window.onerror = function(message, source, lineno, colno, error){}\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"message: 错误信息提示"),Object(a.b)("li",{parentName:"ul"},"source: 错误脚本地址"),Object(a.b)("li",{parentName:"ul"},"lineno: 错误代码所在行号"),Object(a.b)("li",{parentName:"ul"},"colno: 错误代码所在列号"),Object(a.b)("li",{parentName:"ul"},"error: 错误对象")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"window.onerror"),"的方式对代码侵入性小，可以捕获运行时的错误，包括异步错误。但是还是无法捕获语法错误和网络错误(网络请求异常不会事件冒泡)。"),Object(a.b)("p",null,"如果想要控制台不报错，需要",Object(a.b)("inlineCode",{parentName:"p"},"window.onerror"),"需要返回 true。"),Object(a.b)("p",null,"不过如果出现语法错误，当前代码段后面的代码就不执行了。"),Object(a.b)("p",null,"对于跨域的脚本，如第三方统计，由于安全问题，",Object(a.b)("inlineCode",{parentName:"p"},"window.onerror"),"不能捕获有效的异常信息，浏览器都统一返回 Script error，返回的信息如下："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"message: Script error.\nsource: \nlineno: 0\ncolno: 0\nerror: null\n")),Object(a.b)("p",null,"解决方法是 script 脚本设置 crossorigin 属性。然后服务器设置 HTTP 头",Object(a.b)("inlineCode",{parentName:"p"},"Access-Control-Allow-Origin"),"。"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"注: 可以用 ",Object(a.b)("a",r({parentName:"p"},{href:"https://www.npmjs.com/package/http-server"}),"http-server")," 开2个服务进行实验，--cors 表示服务端开启",Object(a.b)("inlineCode",{parentName:"p"},"Access-Control-Allow-Origin"),"。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'<script src="http://xx.com/a.js" crossorigin="anonymous"><\/script>\n')),Object(a.b)("p",null,"然后就可以获取到错误信息了，如下："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"message: Uncaught ReferenceError: a is not defined\nsource: http://127.0.0.1:8081/index.js\nlineno: 1\ncolno: 23\nerror: ReferenceError: a is not defined\n    at index.js:1\n")),Object(a.b)("h3",{id:"source-map"},"source map"),Object(a.b)("p",null,"通过上面的方法，以及可以获取到错误信息了。但是如果脚本经过压缩后，那么上面的方法返回的错误信息就很难分辨，比如代码压缩成1行，返回的行号总是1。这时就需要 source map。一些构建工具都支持。"),Object(a.b)("p",null,"可以开启 webpack 的 source map。"),Object(a.b)("h3",{id:"promise-错误"},"Promise 错误"),Object(a.b)("p",null,"Promise 一般使用 catch 来进行捕获错误。还可以使用 ESlint 插件基于 AST 实现自动给所有 Promise 添加 catch 处理。不过最好的方式是通过",Object(a.b)("inlineCode",{parentName:"p"},"unhandledrejection"),"事件。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"window.addEventListener('unhandledrejection', e => {\n    e.preventDefault()\n    console.log(e.reason)\n    return true\n})\n")),Object(a.b)("p",null,"Promise 里面写语法错误不会影响外面的同步代码，因为它是异步的。上面代码中，",Object(a.b)("inlineCode",{parentName:"p"},"e.preventDefault()"),"可以阻止控制台的报错。"),Object(a.b)("h3",{id:"网络加载错误"},"网络加载错误"),Object(a.b)("p",null,"有时候因为网络不好，资源加载时可能会导致错误。可以通过 onerror 来捕获错误。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'<script onerror="errorHandler(this)" src="x.js"><\/script>\n<link href="x.css" onerror="errorHandler(this)">\n')),Object(a.b)("p",null,"除了上面的方法，还可以使用 window.addEventListener('error') 的方式处理。但是这里无法使用 window.onerror 进行处理，因为网络加载错误不会进行事件冒泡。而 window.addEventListener 是通过事件捕获来捕获错误的。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"window.addEventListener('error', e => {\n    if(!e.message){\n        console.log(e)\n    }\n}, true)\n")),Object(a.b)("p",null,"注意，网络加载错误时，事件对象是没有 message 信息的，这也是我们判断网络资源加载错误的条件。不过目前无法区分具体的错误类别，如404资源不存在还是服务器错误，只能配合后端日志进行排查。"),Object(a.b)("h3",{id:"页面崩溃错误"},"页面崩溃错误"),Object(a.b)("p",null,"一个成熟的监控系统还需要监控页面崩溃和页面卡顿。监听页面崩溃可以通过监听 window 的 load 和 beforeunload 事件，并结合 sessionStorage 来实现。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"window.addEventListener('load', function () {\n    sessionStorage.setItem('good_exit', 'pending');\n    setInterval(function () {\n       sessionStorage.setItem('time_before_crash', new Date().toString());\n    }, 1000);\n });\n\n window.addEventListener('beforeunload', function () {\n    sessionStorage.setItem('good_exit', 'true');\n });\n\n if(sessionStorage.getItem('good_exit') &&\n    sessionStorage.getItem('good_exit') !== 'true') {\n    /*\n       insert crash logging code here\n   */\n    alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash'));\n }\n")),Object(a.b)("p",null,"上面的代码，如果页面正常关闭，则会触发 beforeunload 事件，所以 good_exit 为 true，而页面崩溃时，不会触发 beforeunload 事件，所以重新访问页面时，good_exit 还是 pending，可以判断上次发生了页面崩溃。"),Object(a.b)("p",null,"但是上面方案有两个问题："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"通常页面崩溃后，用户会强制关闭网页或浏览器，再重新打开，sessionStorage 将不存在。"),Object(a.b)("li",{parentName:"ol"},"如果用 localStorage 或 Cookie 存储，如果用户打开多个页面，但不关闭，good_exit 存储的一直都是 pending。所以新开一个网页，就会上报一次 crash。")),Object(a.b)("p",null,"所以，通常采用 Service Worker 实现页面崩溃的监控。Service Worker 的特点如下："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Service Worker 有独立的线程，页面崩溃了，它一般也不会崩溃。"),Object(a.b)("li",{parentName:"ul"},"Service Worker 声明周期一般比网页要长，可以用来监控网页的状态。"),Object(a.b)("li",{parentName:"ul"},"网页可以通过 navigator.serviceWorker.controller.postMessage 向掌管自己的 SW 发送消息。")),Object(a.b)("h3",{id:"框架的错误处理"},"框架的错误处理"),Object(a.b)("p",null,"React 16 之前，使用 unstable_handleError 来处理，React 16 之后，使用 componentDidCatch 来处理错误。"),Object(a.b)("p",null,"Vue 提供了 Vue.config.errorHandler 来处理错误。如果开发者没使用它捕获错误，错误会以 console.error 方式输出。我们可以劫持 console.error 进行自己的处理。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const nativeConsoleError = window.console.error\nwindow.console.error = (...args) => nativeConsoleError.apply(this, [args])\n")),Object(a.b)("h3",{id:"ajax-错误"},"Ajax 错误"),Object(a.b)("p",null,"ajax 请求错误可以通过 xhr 的 error 事件进行处理。"),Object(a.b)("h2",{id:"上报"},"上报"),Object(a.b)("p",null,"收集到了性能数据和错误信息，就需要上报了。上报的方案是："),Object(a.b)("h3",{id:"使用独立域名"},"使用独立域名"),Object(a.b)("p",null,"因为浏览器会限制同一个域名的请求并发数量，并且使用独立域名(服务器)，可以减轻主业务服务器压力。"),Object(a.b)("h3",{id:"image-src"},"Image src"),Object(a.b)("p",null,"首先如果使用了独立域名，则有跨域问题，而 Image 的 src 是没有跨域的。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"let url = 'xxx?data=' + JSON.stringify(data)\nlet img = new Image()\nimg.src = url\n")),Object(a.b)("h3",{id:"上报时机"},"上报时机"),Object(a.b)("p",null,"页面加载性能数据可以再页面稳定后上报。对于错误的上报，如果日志量很大，则可以合并后统一时间上报。"),Object(a.b)("p",null,"一般的场景是："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"页面加载和重新刷新。"),Object(a.b)("li",{parentName:"ol"},"页面路由切换。"),Object(a.b)("li",{parentName:"ol"},"页面 Tab 变为可见。通过 webkitvisibilitychange 事件和 document.hidden 来判断。"),Object(a.b)("li",{parentName:"ol"},"页面关闭。")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"// 关闭窗口前执行 \nwindow.onbeforeunload = function(event){\n    return '确定离开此页面？'\n}\n// 关闭窗口后执行\nwindow.onunload = function(event){\n    return '确定离开此页面？'\n}\n")),Object(a.b)("p",null,"但是如果在页面离开时上报，那么页面卸载时不能保证数据安全的发送。如果使用同步 ajax，又会对页面流畅度和用户体验造成影响。"),Object(a.b)("p",null,"推荐使用 ",Object(a.b)("a",r({parentName:"p"},{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon"}),"sendBeacon")," 方法。它可以用来向服务器发送 post 请求，特点是：异步，页面卸载也可靠。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"window.addEventListener('unload', log, false)\nfunction log(){\n    navigator.sendBeacon('/log', data)\n}\n")),Object(a.b)("p",null,"所以，如果数据小(url 长度是有限制的)使用 Image 上传，数据量太大就使用 sendBeacon，如果不兼容，就使用 ajax post。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const reportData = url => {\n    // ...\n    if (urlLength < 2083) {\n        imgReport(url, times)\n    } else if (navigator.sendBeacon) {\n        sendBeacon(url, times)\n    } else {\n        xmlLoadData(url, times)\n    }\n}\n")),Object(a.b)("p",null,"最后，如果页面访问量太多，错误发送的信息太多，可以设置采集率。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const reportData = url => {\n    // 只采集 30%\n    if (Math.random() < 0.3) {\n        send(data)\n    }\n}\n")),Object(a.b)("h3",{id:"单页应用上报"},"单页应用上报"),Object(a.b)("p",null,"如果切换路由是通过 hash 来实现的，则只需要监听 hashchange 事件。如果通过 history API，那么需要使用 pushState 和 replaceState 事件。"),Object(a.b)("p",null,"可以使用下面的方法："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const patchMethod = type => \n    () => {\n       const result = history[type].apply(this, arguments)\n       const event = new Event(type)\n       event.arguments = arguments\n       window.dispatchEvent(event)\n       return result\n       }\n\nhistory.pushState = patchMethod('pushState')\nhistory.replaceState = patchMethod('replaceState')\n\nwindow.addEventListener('replaceState', e => {\n    // report...\n})\nwindow.addEventListener('pushState', e => {\n    // report...\n})\n")),Object(a.b)("h2",{id:"监控系统设计"},"监控系统设计"),Object(a.b)("p",null,"监控系统分为：采集、存储、分析过滤、上报四个阶段。"),Object(a.b)("p",null,"数据上报，可以借助 http2 持续优化。"),Object(a.b)("p",null,"接口方面：可以识别流量高峰，动态设置采集率。对垃圾信息进行过滤。通过配置减少业务接入成本。短时间相同错误过滤。"),Object(a.b)("p",null,"后台设置阈值进行邮件或短信提醒。业界流行 ",Object(a.b)("a",r({parentName:"p"},{href:"https://baike.baidu.com/item/3%CF%83%E5%87%86%E5%88%99/9361985"}),"3-sigma")," 阈值设置。"),Object(a.b)("h2",{id:"参考资料"},"参考资料"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://zhyjor.github.io/2018/01/17/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%EF%BC%9A%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86/"}),"打造自己前端监控系统之一：性能信息采集")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://zhyjor.github.io/2018/01/18/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%AE%9E%E6%88%98%E7%AF%87/"}),"打造自己前端监控系统之二：实战篇")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://juejin.im/post/5b9214c2f265da0aeb70e36e"}),"2018你应该知道的Web性能信息采集指南")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://juejin.im/post/5a52f138f265da3e5b32a41b"}),"把前端监控做到极致")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://www.w3.org/TR/performance-timeline-2/#dom-performance"}),"https://www.w3.org/TR/performance-timeline-2/#dom-performance")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://segmentfault.com/a/1190000014922668"}),"web 埋点实现原理了解一下")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html"}),"JavaScript Source Map 详解")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://webpack.js.org/guides/development/#using-source-maps"}),"Using source maps")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/39292837"}),"如何监控网页的卡顿？")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/40273861"}),"如何监控网页的崩溃? ")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/"}),"前端异常监控解决方案研究 ")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/37275225"}),"解密 ARMS 前端监控数据上报技术内幕")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://mp.weixin.qq.com/s/Z8daa96JD5NbjTPn9mGPPg"}),"别再让你的 Web 页面在用户浏览器端裸奔")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485669&idx=1&sn=a4d4aee73b606d412aba71abafb88325&source=41#wechat_redirect"}),"浏览器端 JS 异常监控探索与实践")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://time.geekbang.org/column/article/94156"}),"重学前端"))))}p.isMDXComponent=!0},283:function(e,n,t){"use strict";t.d(n,"a",function(){return b}),t.d(n,"b",function(){return u});var a=t(0),r=t.n(a),l=r.a.createContext({}),c=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},b=function(e){var n=c(e.components);return r.a.createElement(l.Provider,{value:n},e.children)};var o="mdxType",i={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},p=function(e){var n=e.components,t=e.mdxType,a=e.originalType,l=e.parentName,b=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),o=c(n),p=t,u=o[l+"."+p]||o[p]||i[p]||a;return n?r.a.createElement(u,Object.assign({},b,{components:n})):r.a.createElement(u,b)};function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,c=new Array(l);c[0]=p;var b={};for(var i in n)hasOwnProperty.call(n,i)&&(b[i]=n[i]);b.originalType=e,b[o]="string"==typeof e?e:a,c[1]=b;for(var u=2;u<l;u++)c[u]=t[u];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);