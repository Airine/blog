(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{267:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return o}),t.d(n,"rightToc",function(){return l}),t.d(n,"default",function(){return u});t(0);var r=t(301);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o={title:"vue 知识点总结",sidebar_label:"知识点总结"},l=[{value:"虚拟 DOM",id:"虚拟-dom",children:[{value:"什么是虚拟DOM",id:"什么是虚拟dom",children:[]},{value:"key 有什么用？",id:"key-有什么用？",children:[]}]},{value:"参考资料",id:"参考资料",children:[]}],d={rightToc:l},c="wrapper";function u(e){var n=e.components,t=i(e,["components"]);return Object(r.b)(c,a({},d,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"虚拟-dom"},"虚拟 DOM"),Object(r.b)("h3",{id:"什么是虚拟dom"},"什么是虚拟DOM"),Object(r.b)("p",null,"虚拟 DOM 就是利用一个简单的对象去代替复杂的 dom 对象。它实际是一种开发与性能的平衡。"),Object(r.b)("p",null,"人为的操作 DOM，理想情况下当然是性能最高的。但是开发起来非常复杂，每个地方都要手动操作 DOM，并且考虑性能。虚拟 DOM 库将操作 DOM 封装起来，我们不再需要操作 DOM，这可以大大提高开发效率。"),Object(r.b)("h3",{id:"key-有什么用？"},"key 有什么用？"),Object(r.b)("p",null,"key的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。"),Object(r.b)("p",null,"1、 某些时候性能高。默认情况下，不带 key 时，会对节点进行就地复用，提高性能。而带 key 时，会根据 key 进行对比增删节点，不但要销毁和创建vnode，在 DOM 里添加移除节点对性能的影响更大。不过在搜索要替换的旧 VNode 时，带 key 使用 map 映射查找的方式，要比不带 key 时遍历查找的方式更快。总的来说，不带 key 性能高。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"// vue项目  src/core/vdom/patch.js  -488行\nif (isUndef(oldKeyToIdx)) {\n  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n}\nif(isDef(newStartVnode.key)) {\n  // map 方式获取\n  idxInOld = oldKeyToIdx[newStartVnode.key]\n} else {\n  // 遍历方式获取\n  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n\n// 遍历寻找\nfunction findIdxInOld (node, oldCh, start, end) {\n  for (let i = start; i < end; i++) {\n     const c = oldCh[i]\n      \n     if (isDef(c) && sameVnode(node, c)) return i\n  }\n}\n")),Object(r.b)("p",null,'2、 更准确。key 的作用主要用于虚拟 DOM 算法，用于标识 VNode，在替换更新节点时更准确，防止"原地复用"带来的问题，比如表单输入值。'),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'<div id="app">\n    <div>\n        <input type="text" v-model="name">\n        <button @click="add">添加</button>\n    </div>\n    <ul>\n        <li v-for="(item, i) in list">\n            <input type="checkbox"> {{item.name}}\n        </li>\n    </ul>\n</div>\n<script>\n    var vm = new Vue({\n        el: \'#app\',\n        data: {\n            name: \'\',\n            list: [{\n                    name: \'a\'\n                }\n            ]\n        },\n        methods: {\n            add() {\n                this.list.unshift({\n                    name: this.name\n                })\n                this.name = \'\'\n            }\n        }\n    });\n<\/script>\n')),Object(r.b)("p",null,"比如上面代码，首先选中 a，然后添加 b，结果添加之后，选中的变成了 b。这是因为添加后和添加前的 vnode 进行对比时，发现input 没有变，名称变了，所以只更新了名称(从 a 变成 b)，后面又添加了一条 a。"),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"/img/vue/1.jpg",alt:null}))),Object(r.b)("p",null,"对于不更新的简单列表，可以不带 key 提升性能。而对于要更新的列表，建议使用 key，因为准确有时比性能重要。"),Object(r.b)("h2",{id:"参考资料"},"参考资料"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1"}),"写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？")),Object(r.b)("li",{parentName:"ul"},"[解析vue2.0的diff算法]",Object(r.b)("a",a({parentName:"li"},{href:"https://github.com/aooy/blog/issues/2"}),"https://github.com/aooy/blog/issues/2"),")")))}u.isMDXComponent=!0},301:function(e,n,t){"use strict";t.d(n,"a",function(){return l}),t.d(n,"b",function(){return p});var r=t(0),a=t.n(r),i=a.a.createContext({}),o=function(e){var n=a.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},l=function(e){var n=o(e.components);return a.a.createElement(i.Provider,{value:n},e.children)};var d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=function(e){var n=e.components,t=e.mdxType,r=e.originalType,i=e.parentName,l=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),d=o(n),u=t,p=d[i+"."+u]||d[u]||c[u]||r;return n?a.a.createElement(p,Object.assign({},l,{components:n})):a.a.createElement(p,l)};function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);