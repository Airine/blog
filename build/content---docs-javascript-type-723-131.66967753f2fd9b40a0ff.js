(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{69:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return r}),a.d(n,"rightToc",function(){return i}),a.d(n,"default",function(){return o});a(0);var t=a(88);function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function b(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},b=Object.keys(e);for(t=0;t<b.length;t++)a=b[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(t=0;t<b.length;t++)a=b[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var r={id:"type",title:"javascript 数据类型",sidebar_label:"数据类型"},i=[{value:"简介",id:"简介",children:[]},{value:"Undefined、Null",id:"undefined、null",children:[]},{value:"Boolean",id:"boolean",children:[]},{value:"String",id:"string",children:[]},{value:"Number",id:"number",children:[{value:"Number、parseInt、parseFloat",id:"number、parseint、parsefloat",children:[]}]},{value:"Symbol",id:"symbol",children:[]},{value:"Object",id:"object",children:[{value:"普通对象",id:"普通对象",children:[]}]},{value:"类型判断",id:"类型判断",children:[{value:"typeof()",id:"typeof",children:[]},{value:"instanceof",id:"instanceof",children:[]},{value:"Object.prototype.toString()",id:"objectprototypetostring",children:[]}]},{value:"类型转换",id:"类型转换",children:[{value:"toBoolean",id:"toboolean",children:[]},{value:"StringToNumber",id:"stringtonumber",children:[]},{value:"NumberToString",id:"numbertostring",children:[]},{value:"运算符",id:"运算符",children:[]},{value:"装箱转换",id:"装箱转换",children:[]},{value:"拆箱转换",id:"拆箱转换",children:[]}]}],c={rightToc:i},p="wrapper";function o(e){var n=e.components,a=b(e,["components"]);return Object(t.b)(p,l({},c,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"简介"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#简介"}),"#"),"简介"),Object(t.b)("p",null,"Javascript 语义规定了 7 种数据类型："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Undefined"),Object(t.b)("li",{parentName:"ul"},"Null"),Object(t.b)("li",{parentName:"ul"},"Boolean"),Object(t.b)("li",{parentName:"ul"},"String"),Object(t.b)("li",{parentName:"ul"},"Number"),Object(t.b)("li",{parentName:"ul"},"Symbol"),Object(t.b)("li",{parentName:"ul"},"Object")),Object(t.b)("p",null,"前6个也叫做原始(Primitive)类型或基本类型。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"undefined、null"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#undefined、null"}),"#"),"Undefined、Null"),Object(t.b)("p",null,"Undefined 表示未定义，在变量赋值之前，它是 Undefined 类型，值为 undefined。但是 javascript 中 undefined 是一个变量，而不是关键字。所以可能被修改。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"function a() {\n    var undefined = 12\n    console.log(undefined)  \n}\na()\n\nvar undefined = 12\nconsole.log(undefined) \n")),Object(t.b)("p",null,"上面的代码，在 Chrome/75.0.3770.80 下输出 ",Object(t.b)("inlineCode",{parentName:"p"},"12"),"、",Object(t.b)("inlineCode",{parentName:"p"},"undefined"),"。在 node v12.3.1 下输出",Object(t.b)("inlineCode",{parentName:"p"},"12"),"、",Object(t.b)("inlineCode",{parentName:"p"},"12"),"。可以看出，undefined 是有可能被修改的。所以可以使用",Object(t.b)("inlineCode",{parentName:"p"},"void 0"),"来代替 ",Object(t.b)("inlineCode",{parentName:"p"},"undefined"),"。"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"void"),"操作符会执行表达式，并返回 ",Object(t.b)("inlineCode",{parentName:"p"},"undefined"),"。它通常用来获取原始的 undefined，或阻止 a 链接的点击。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"void (2 == '2'); // void (2 == '2'), returns undefined\n\nvoid 2 == '2';   // (void 2) == '2', returns false\n\n<a href=\"javascript:void(0);\">\n  当用户点击一个以 javascript: URI 时，它会执行URI中的代码,\n  然后用返回的值替换页面内容，除非返回的值是undefined\n  如果去掉 void()，点击之后整个页面会被替换成一个字符 0\n</a>\n")),Object(t.b)("p",null,"Null 表示定义了但是为空，它只有一个值 null。可以放心使用 null，因为它是一个关键字。"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"typeof null"),"会返回",Object(t.b)("inlineCode",{parentName:"p"},"object"),"，但是它并非对象，而是 JS 设计时的一个 Bug，JS 最初使用的是 32 位系统，为了性能考虑，使用地位存储变量的类型信息，",Object(t.b)("inlineCode",{parentName:"p"},"000"),"开头表示对象，然而",Object(t.b)("inlineCode",{parentName:"p"},"null"),"表示为全零，所以它被错误判断为",Object(t.b)("inlineCode",{parentName:"p"},"object"),"。虽然现在内部类型判断已经改变了，但是这个 Bug 一直都在。"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"面试题：原始类型有哪几种？null 是对象嘛？")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"boolean"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#boolean"}),"#"),"Boolean"),Object(t.b)("p",null,"Boolean 类型有两个值，true 和 false。在转换时只有下面 6 个值为 false，其余都为 true。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"布尔值",Object(t.b)("inlineCode",{parentName:"li"},"false")),Object(t.b)("li",{parentName:"ul"},"空字符串",Object(t.b)("inlineCode",{parentName:"li"},"'' 或 \"\"")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"0(包括+0、-0)")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"NaN")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"undefined")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"null"))),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"string"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#string"}),"#"),"String"),Object(t.b)("p",null,"Javascript 字符串是以 UTF16 编码的，字符串的最大长度是 2^53 - 1，它并不是字符数，而是受字符串编码长度影响。Javascript 字符串把每个 UTF16 单元当作一个字符来处理，所以非 BMP 字符(Unicode 码点超出 U+0000 - U+FFFF区间,即超出 0-65536)会当作两个 UTF16 单元。"),Object(t.b)("p",null,"这样的设计是为了性能和实现起来更加简单。因为现实中很少用到 BMP 之外的字符。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"number"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#number"}),"#"),"Number"),Object(t.b)("p",null,"JavaScript中的Number类型有 18437736874454810627 (即2^64-2^53+3) 个值。JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是JavaScript为了表达几个额外的语言场景(比如不让除以0出错，而引入了无穷大的概念)，规定了几个例外情况:"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"NaN"),"，占用了 9007199254740990，这原本是符合 IEEE 规则的数字。"),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"Infinity")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("inlineCode",{parentName:"li"},"-Infinity"))),Object(t.b)("p",null,"注意，除法时，除以-0，会得到-Infinity。区分+0和-0的方式就是检测 1/x 是 Infinity 还是 -Infinity。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"var a = -0\na.toString()  // 0\n\n1/a   // -Infinity\n")),Object(t.b)("p",null,"根据双精度浮点数的定义，Number类型中有效的整数范围是-0x1fffffffffffff至0x1fffffffffffff，所以Number 无法精确表示此范围外的整数。"),Object(t.b)("p",null,"同样根据浮点数的定义，非整数的Number类型无法用 ==(===也不行) 来比较，这也正是为什么在JavaScript中，0.1+0.2!=0.3，正确的比较方法是:"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{}),"Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON   // true\n")),Object(t.b)("p",null,"检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"number、parseint、parsefloat"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#number、parseint、parsefloat"}),"#"),"Number、parseInt、parseFloat"),Object(t.b)("p",null,"Number() 可以将字符串转换成数字。如果参数无法被转换为数字，则返回 NaN。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'// 转换日期\nnew Date("December 17, 1995 03:24:00").getTime() //819141840000\nnew Date("December 17, 1995 03:24:00").valueOf() //819141840000\nNumber(new Date("December 17, 1995 03:24:00"))  //819141840000\n\nNumber(\'.1\') // 0.1\nNumber(\'hello\') // NaN\n')),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"parseInt(string, radix)"),"用于将字符串以 radix 进制转为 10 进制，radix 介于 2-36 之间，未指定时默认为 10。如果参数不是字符串，将其转为字符串。它遇到非数值字符就终止。如果第一个字符就是非数值，则返回 NaN。"),Object(t.b)("p",null,"当 radix 为 undefined、0 或 未指定情况时，如果："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"字符串以 0x 或 0X 开头，则 radix 为 16。"),Object(t.b)("li",{parentName:"ul"},"字符串以 0 开头，radix 为 8 或 10，具体看浏览器实现。"),Object(t.b)("li",{parentName:"ul"},"字符串以其它值开头，radix 为 10。")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),'parseInt(\'123\', 5) // 将\'123\'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38\n\n// 下面例子都返回 15\nparseInt("0xF", 16);\nparseInt("F", 16);\nparseInt("17", 8);\nparseInt(021, 8);\nparseInt("015", 10);   // parseInt(015, 10); 返回 15\nparseInt(15.99, 10);\nparseInt("15,123", 10);\nparseInt("FXX123", 16);\nparseInt("1111", 2);\nparseInt("15 * 3", 10);\nparseInt("15e2", 10);\nparseInt("15px", 10);\nparseInt("12", 13);\n\n// 下面例子都返回NaN\nparseInt("Hello", 8); // 根本就不是数值\nparseInt("546", 2);   // 除了“0、1”外，其它数字都不是有效二进制数字\n\n// 下面例子返回4\nparseInt(4.7, 10);\nparseInt(4.7 * 1e22, 10); // Very large number becomes 4\nparseInt(0.00000000000434, 10); // Very small number becomes 4\n')),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"parseFloat()")," 将它的字符串参数解析成为浮点数并返回.如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略."),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"parseFloat('e')   // NaN\nparseFloat('1e3') // 1000\n")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"['1', '2', '3']",".map(parseInt) what & why ?")),Object(t.b)("p",null,"相当于下面的代码："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"['1','2','3'].map((item, i)=>{\n    return parseInt(item, i)\n})\n// item i -> 结果\n// '1' 0  -> 1\n// '2' 1  -> radix 为 2-36之间，NaN\n// '3' 2  -> 2进制没有3， NaN\n// 最终输出 [1, NaN, NaN]\n")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"symbol"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#symbol"}),"#"),"Symbol"),Object(t.b)("p",null,"Symbol 是具有字符串类型的描述，它是唯一的，即使描述相同，也不相等。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var s = Symbol('hello')\n")),Object(t.b)("p",null,"可以使用 Symbol.iterator 来自定义 for...of 在对象上的行为。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var o = {\n    name: 'zs',\n    age: 32,\n    [Symbol.iterator]: function () {\n        let i = 0\n        return {\n            next: function () {\n                return {\n                    value: i++,\n                    done: i > 3\n                }\n            }\n        }\n    }\n}\n\nfor (let i of o) {\n    console.log(i)   // 0 1 2\n}\n")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"object"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#object"}),"#"),"Object"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"普通对象"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#普通对象"}),"#"),"普通对象"),Object(t.b)("p",null,"对象是属性的集合，属性分为数据属性和访问器属性，二者都是key-value结构，key 可以是字符串或 Symbol 类型。"),Object(t.b)("p",null,"javascript 中的类，实际是运行时对象的一个私有属性，而 javascript 是无法自定义类型的。"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？")),Object(t.b)("p",null,"原始类型存储的是值，赋值时，会复制值。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var a = 1\nvar b = a\nb // 1\n")),Object(t.b)("p",null,"上面 a 赋值给 b 时，会将值 1 复制给 b。"),Object(t.b)("p",null,"对象类型存储的是指针，当存储对象时，计算机会在内存中新开辟一个空间来存放值，对象类型存储的是这个空间地址。赋值时，是复制的地址。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var a = []\nvar b = a\na.push(1)\nb  // [1]\n")),Object(t.b)("p",null,"上面代码中，a 实际是一个空间地址，将 a 赋值给 b 时，是将空间地址给 b。所以使用 push 改变空间值后，b 也会变化。"),Object(t.b)("p",null,"函数传参是对象时，实际会将地址传递给局部参数变量。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"function test(person) {\n  person.age = 26\n  person = {\n    name: 'yyy',\n    age: 30\n  }\n\n  return person\n}\nconst p1 = {\n  name: 'yck',\n  age: 25\n}\nconst p2 = test(p1)\nconsole.log(p1) // -> { name: 'yck', age: 26 }\nconsole.log(p2) // -> { name: 'yyy', age: 30 }\n")),Object(t.b)("p",null,"上面代码将 p1 传递给 test 时，person 就是 p1 执行的空间，"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"为什么给对象添加的方法能用在基本类型上？")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},".")," 运算符提供了装箱操作，会根据基础类型创建一个临时对象，使得我们可以在基本类型上调用对象的方法。。Number、String、Boolean 使用 new 时，会产生对象。当直接调用时，表示强制转换类型。Symbol 使用 new 会报错，但是它仍然 Symbol 对象的是构造器。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var o = {\n    name: 'zs',\n    age: 32,\n    [Symbol.iterator]: function () {\n        let i = 0\n        return {\n            next: function () {\n                return {\n                    value: i++,\n                    done: i > 3\n                }\n            }\n        }\n    }\n}\n\nfor (let i of o) {\n    console.log(i)   // 0 1 2\n}\n")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？")),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"类型判断"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#类型判断"}),"#"),"类型判断"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"typeof"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#typeof"}),"#"),"typeof()"),Object(t.b)("p",null,"javascript 类型是很有争议的，typeof 和运行时类型有些不一致。typeof 设计有缺陷，但是错过了修正它的时机。"),Object(t.b)("table",null,Object(t.b)("thead",{parentName:"table"},Object(t.b)("tr",{parentName:"thead"},Object(t.b)("th",l({parentName:"tr"},{align:null}),"示例"),Object(t.b)("th",l({parentName:"tr"},{align:null}),"typeof 结果"),Object(t.b)("th",l({parentName:"tr"},{align:null}),"运行时类型行为"))),Object(t.b)("tbody",{parentName:"table"},Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"null"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"object"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Null")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"{}"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"object"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Object")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"(function(){})"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"function"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Object")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"3"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"number"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Number")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"'ok'"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"string"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"String")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"true"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"boolean"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Boolean")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"void"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"undefined"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Undefined")),Object(t.b)("tr",{parentName:"tbody"},Object(t.b)("td",l({parentName:"tr"},{align:null}),"Symbol('a')"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"symbol"),Object(t.b)("td",l({parentName:"tr"},{align:null}),"Symbol")))),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"instanceof"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#instanceof"}),"#"),"instanceof"),Object(t.b)("p",null,"instanceof 可以判断某个对象是否是类的实例。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"[] instanceof Array\n{} instanceof Object\n")),Object(t.b)("p",null,"对于基本类型，它是无法正确判断的。当然可以用下面方法："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"class PrimitiveString{\n    static [Symbol.hasInstance](x){\n        return typeof x === 'string'\n    }\n}\n\n'hello' instanceof Primitivestring  // true\n")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"Symbol.hasInstance"),"可以让我们自定义 instanceof 的行为。所以上面",Object(t.b)("inlineCode",{parentName:"p"},"'hello' instanceof Primitivestring"),"结果返回 true。这也可以看出 instanceof 不是十分可靠。"),Object(t.b)("p",null,"另外，如果页面里嵌套了 iframe，将无法使用 instanceof 判断跨文档的对象，比如",Object(t.b)("inlineCode",{parentName:"p"},"父页面中的数组 instanceof iframe的Array"),"将返回 false，因为父页面的 window.Array 和 iframe 里的 window.Array 不是同一个。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"objectprototypetostring"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#objectprototypetostring"}),"#"),"Object.prototype.toString()"),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"Object.prototype.toString.call()"),"可以准确的判断数据的类型，在下面装箱转换详细说。"),Object(t.b)("h2",null,Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"类型转换"})),Object(t.b)("a",l({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#类型转换"}),"#"),"类型转换"),Object(t.b)("p",null,"不要使用 == 进行判断，因为它的规则太复杂，属于设计失误，很多实践都进制使用它。"),Object(t.b)("p",null,"JS 中类型转换只有三种情况，分别是："),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"转换为布尔值"),Object(t.b)("li",{parentName:"ul"},"转换为 Number"),Object(t.b)("li",{parentName:"ul"},"转换为 String ")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"toboolean"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#toboolean"}),"#"),"toBoolean"),Object(t.b)("p",null,"转布尔值很简单。除了下面这 6 个，其它都是 true。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"false"),Object(t.b)("li",{parentName:"ul"},"'' 或 \"\""),Object(t.b)("li",{parentName:"ul"},"undefined"),Object(t.b)("li",{parentName:"ul"},"null"),Object(t.b)("li",{parentName:"ul"},"0(含+0、-0)"),Object(t.b)("li",{parentName:"ul"},"NaN")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"stringtonumber"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#stringtonumber"}),"#"),"StringToNumber"),Object(t.b)("p",null,"字符串转数字，存在一个语法结构，类型转换支持十进制、二进制、八进制、十六进制，如:"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"30"),Object(t.b)("li",{parentName:"ul"},"0b111"),Object(t.b)("li",{parentName:"ul"},"0o13"),Object(t.b)("li",{parentName:"ul"},"0xFF")),Object(t.b)("p",null,"还支持正负号科学计数法。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"1e3 (1000)"),Object(t.b)("li",{parentName:"ul"},"-1e-2 (-0.01)")),Object(t.b)("p",null,Object(t.b)("inlineCode",{parentName:"p"},"parseInt()")," 在不传入第二个参数情况下，只支持16进制前缀",Object(t.b)("inlineCode",{parentName:"p"},"0x"),"，而且忽略非数字字符，不支持科学计数法。在一些浏览器上，还支持0开头的数作为8进制前缀，这是很多错误的来源。所以任何情况下，都建议传入第二个参数。parseFloat 会将原字符串作为十进制解析，不会引入任何其它进制。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"parseInt(0x11)  // 17\nparseInt('011')   // 11  \nparseInt(011)     // 9\n\nparseFloat('1e2')   // 100\nparseFloat('1ae2')  // 1\nparseFloat('0x11')  // 0\n")),Object(t.b)("p",null,"多数情况下，使用 ",Object(t.b)("inlineCode",{parentName:"p"},"Number")," 比 ",Object(t.b)("inlineCode",{parentName:"p"},"parseInt")," 和 ",Object(t.b)("inlineCode",{parentName:"p"},"parseFloat")," 更好。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"numbertostring"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#numbertostring"}),"#"),"NumberToString"),Object(t.b)("p",null,"在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"0x11.toString()  // 17\n")),Object(t.b)("p",null,"注：基本类型的隐式转换貌似是内部进行的。并没有调用 toString 或 String 方法。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var nf = Number.prototype.toString\nvar s = String \nString = function(...args){\n    console.log('called String')\n    return s(...args)\n}\nNumber.prototype.toString = function (...args) {\n    console.log('called number toString')\n    return nf.call(this, ...args)\n}\n2.1 + ''  // 无输出console\n")),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"运算符"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#运算符"}),"#"),"运算符"),Object(t.b)("p",null,"四则运算符会触发数据类型的转换。规律是:"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"运算中其中一方为字符串，那么就会把另一方也转换为字符串"),Object(t.b)("li",{parentName:"ul"},"如果一方不是字符串或者数字，那么会将它转换为数字或者字符串")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"1 + '1' // '11'\ntrue + true // 2\n4 + [1,2,3] // \"41,2,3\"\n\n'a' + + 'b' // -> \"aNaN\" 因为 +'b' 是 NaN\n\n+ '1' // 1\n+ new Date() // 1563891201093\n\n4 * '3' // 12\n4 * [] // 0\n4 * [1, 2] // NaN\n")),Object(t.b)("p",null,"比较运算符"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"如果是对象，就通过 toPrimitive 转换对象"),Object(t.b)("li",{parentName:"ul"},"如果是字符串，就通过 unicode 字符索引来比较")),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return -2\n  }\n}\na > -1 // true\n")),Object(t.b)("p",null,"上面代码，a 会首先通过 valueOf() 转换为原始类型，即数字 0，然后再和 -1 进行比较。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"装箱转换"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#装箱转换"}),"#"),"装箱转换"),Object(t.b)("p",null,"基本类型存储的是值，是没有方法可以调用的。比如",Object(t.b)("inlineCode",{parentName:"p"},"null.toString()"),"会报错。但是为什么",Object(t.b)("inlineCode",{parentName:"p"},"(100).toString()"),"可以呢？这涉及到 JS 自带的装箱转换。"),Object(t.b)("p",null,"装箱转换，就是把基本类型转换为对应的对象。所以对于",Object(t.b)("inlineCode",{parentName:"p"},"(100).toString()"),"，实际上 JS 会将100进行装箱转换，变成对象",Object(t.b)("inlineCode",{parentName:"p"},"new Number(100)"),"。"),Object(t.b)("p",null,"每次装箱都会新建一个对象，所以给基本类型添加属性是无效的。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var a = 1\na.id = 'hello'\na.id  // undefined\n")),Object(t.b)("p",null,"Number、String、Boolean、Symbol 都有对应的类。"),Object(t.b)("p",null,"Symbol 的装箱操作，可以使用下面方法："),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var symbolObj = (function(){ return this }).call(Symbol('a'))\n\ntypeof symbolObj   // object\nsymbolObj instanceof Symbol // true\nsymbolObj.constructor    // Symbol\n")),Object(t.b)("p",null,"装箱机制会频繁产生临时对象，在一些性能高的场景下，应该避免对基本类型做装箱转换。"),Object(t.b)("p",null,"使用内置的 Object() 函数，也可以显示调用装箱能力。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var symbolObj = Object(Symbol('a'))\n\ntypeof symbolObj   // object\nsymbolObj instanceof Symbol // true\nsymbolObj.constructor    // Symbol\n\nObject.prototype.toString.call(symbolObj)  // [object Symbol]\n")),Object(t.b)("p",null,"Object.prototype.toString 可以准确识别对象对应的基本类型。比instance 更加准确。但是 call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型和对象类型。"),Object(t.b)("h3",null,Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"拆箱转换"})),Object(t.b)("a",l({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#拆箱转换"}),"#"),"拆箱转换"),Object(t.b)("p",null,"拆箱转换，就是对象类型转成基本类型。它会调用内置的",Object(t.b)("inlineCode",{parentName:"p"},"[[ToPrimitive]]"),"方法。"),Object(t.b)("p",null,"对象到 String 和 Number 的转换都遵循",Object(t.b)("inlineCode",{parentName:"p"},"先拆箱，再转换"),"的规则，通过拆箱转换，将对象变为基本类型，再从基本类型转换为对应的 String 或 Number。"),Object(t.b)("p",null,"拆箱转换会尝试调用 valueOf 和 toString 来获取拆箱后的基本类型，如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会报错 TypeError。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"var a = {\n    valueOf() {\n        console.log('valueOf')\n        return {}\n    },\n    toString() {\n        console.log('toString')\n        return {}\n    }\n}\n\n// 对象转Number\na * 2\n// valueOf\n// toString\n// TypeError: Cannot convert object to primitive value\n\n// 对象转String\nString(a)\n// toString\n// valueOf\n// TypeError\n")),Object(t.b)("p",null,"可以看到，转 Number 是先调用 valueOf()，再调用 toString()。转 String 是先调用 toString() 再调用 valueOf()。"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"规范指出，类型转换的内部实现是通过ToPrimitive ( input ","[ , PreferredType ]",' )方法进行转换的，这个方法 的作用就是将input转换成一个非对象类型。\n参数preferredType是可选的，它的作用是，指出了input被期待转成的类型。 如果不传preferredType进来，默认的是\'number\'。\n如果preferredType的值是"string"，那就先执行"toString", 后执行"valueOf"。否则，先执行"valueOf", 后 执行"toString"。\n由此可见，"toString", "valueOf"的执行顺序，取决于preferred的值。\n加法运算符的规则，ToPrimitive 没有传第二个参数，默认是 number')),Object(t.b)("p",null,"在 ES6 之后，可以重写",Object(t.b)("inlineCode",{parentName:"p"},"Symbol.toPrimitive"),"来覆盖原有的行为，不再调用 ",Object(t.b)("inlineCode",{parentName:"p"},"valueOf")," 或 ",Object(t.b)("inlineCode",{parentName:"p"},"toString"),"。"),Object(t.b)("pre",null,Object(t.b)("code",l({parentName:"pre"},{className:"language-js"}),"a[Symbol.toPrimitive] = function(){\n    console.log('@@toPrimitive Symbol')\n    return 2\n\n    // 如果 return {}， 会报错 TypeError\n}\n\nString(a)\n// @@toPrimitive Symbol\n// 2\n")),Object(t.b)("p",null,"上面代码中，",Object(t.b)("inlineCode",{parentName:"p"},"Symbol.toPrimitive"),"返回了一个基本类型，所以直接执行",Object(t.b)("inlineCode",{parentName:"p"},"String(2)"),"。如果返回一个对象，则会报错",Object(t.b)("inlineCode",{parentName:"p"},"TypeError: Cannot convert object to primitive value"),"。"),Object(t.b)("p",null,"除了这七种语言类型，还有一些语言的实现者更关心的规范类型。"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"List 和 Record: 用于描述函数传参过程。"),Object(t.b)("li",{parentName:"ul"},"Set: 主要用于解释字符集等。"),Object(t.b)("li",{parentName:"ul"},"Completion Record: 用于描述异常、跳出等语句执行过程。"),Object(t.b)("li",{parentName:"ul"},"Reference: 用于描述对象属性访问、delete等。"),Object(t.b)("li",{parentName:"ul"},"Property Descriptor: 用于描述对象的属性。"),Object(t.b)("li",{parentName:"ul"},"Lexical Environment 和 Environment Record: 用于描述变量和作用域。"),Object(t.b)("li",{parentName:"ul"},"Data Block: 用于描述二进制数据。")),Object(t.b)("p",null,"关于Number类型，如果想要进一步理解可以去参考IEEE 754中关于浮点数的表达规范，了解这64位中各\n个位数段表达的含义\n文中有几个叙述不清的地方:\n1. NaN和+Infinity的规定实际是IEEE 754标准规定的特殊值: (e为指数的位数，双精度中e=11)"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"指数为2^e – 1且尾数的小数部分全0，这个数字是±∞。(符号位决定正负)"),Object(t.b)("li",{parentName:"ul"},"指数为2^e – 1且尾数的小数部分非全0，这个数字是NaN，比如单精度浮点数中按位表示:S111 1111 1 AXX XXXX XXXX XXXX XXXX XXXX，S为符号位值无所谓，A是小数位的最高位(整数位1省略)，其取值表 示了NaN的类型:X不能全为0，并被称为NaN的payload")),Object(t.b)("ol",{start:2},Object(t.b)("li",{parentName:"ol"},"NaN，占用了 9007199254740990，这个叙述不对\n留言里很多童鞋都提出了 9007199254740990 被占用是什么意思的疑问，实际是第一点描述的关于NaN 规定和参考双精度浮点数的表达方式，尾数共有53位，指数固定为2^e – 1并去掉±∞两个值，那么NaN其 实是 2^53-2 个特殊数字的合集(2^53-2 = 9007199254740990 );\n并不是 9007199254740990 被占用，而是 9007199254740990 个特殊值被占用来表示 NaN 扩展一下，我们就可以理解为什么NaN !== NaN了，它确实不是一个值，而是一群值呢0 0!")))}o.isMDXComponent=!0},88:function(e,n,a){"use strict";a.d(n,"a",function(){return i}),a.d(n,"b",function(){return u});var t=a(0),l=a.n(t),b=l.a.createContext({}),r=function(e){var n=l.a.useContext(b),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},i=function(e){var n=r(e.components);return l.a.createElement(b.Provider,{value:n},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){return l.a.createElement(l.a.Fragment,{},e.children)}},o=function(e){var n=e.components,a=e.mdxType,t=e.originalType,b=e.parentName,i=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),c=r(n);return l.a.createElement(c[b+"."+a]||c[a]||p[a]||t,n?Object.assign({},i,{components:n}):i)};function u(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var b=a.length,r=new Array(b);r[0]=o;var i={};for(var p in n)hasOwnProperty.call(n,p)&&(i[p]=n[p]);i.originalType=e,i[c]="string"==typeof e?e:t,r[1]=i;for(var u=2;u<b;u++)r[u]=a[u];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,a)}o.displayName="MDXCreateElement"}}]);